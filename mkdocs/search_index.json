{
    "docs": [
        {
            "location": "/context.coffee/",
            "text": "Nikita Context\n\n\ncalled_deprecate_destination = false\ncalled_deprecate_local_source = false\nmodule.exports = ->\n  if arguments.length is 2\n    obj = arguments[0]\n    obj.options = arguments[1]\n  else if arguments.length is 1\n    obj = new EventEmitter\n    obj.options = arguments[0]\n  else\n    obj = new EventEmitter\n    obj.options = {}\n  obj.registry ?= {}\n  obj.propagation ?= obj.options.propagation or {}\n  obj.store ?= {}\n  # Merge global default propagation\n  for k, v of module.exports.propagation\n    obj.propagation[k] = v unless obj.propagation[k] isnt undefined\n  # Internal state\n  state = {}\n  state.properties = {}\n  state.stack = []\n  state.todos = todos_create()\n  state.befores = []\n  state.afters = []\n  state.depth = 0\n  state.headers = []\n  state.once = {}\n  state.killed = false\n  state.index_counter = 0\n  # Domain\n  obj.options.domain =  domain.create() if obj.options.domain is true\n  domain_on_error = (err) ->\n    err.message = \"Invalid State Error [#{err.message}]\"\n    handle_multiple_call err\n  obj.options.domain?.on 'error', domain_on_error\n  # Proxify\n  proxy = new Proxy obj,\n    has: (target, name) ->\n      console.warns 'proxy has is being called', name\n      # target[name]? or target.registry.registered(proxy.type)? or registry.registered(name)?\n    apply: (target, thisArg, argumentsList) ->\n      console.warn 'apply'\n    get: (target, name) ->\n      return target[name] if obj[name]?\n      return target[name] if name in ['domain', '_events', '_maxListeners']\n      proxy.type = []\n      proxy.type.push name\n      if not obj.registry.registered(proxy.type, parent: true) and not registry.registered(proxy.type, parent: true)\n        proxy.type = []\n        return undefined\n      get_proxy_builder = ->\n        builder = ->\n          args = [].slice.call(arguments)\n          options = normalize_options args, proxy.type\n          {get, values} = handle_get proxy, options\n          return values if get\n          proxy.type = []\n          state.todos.push opts for opts in options\n          setImmediate _run_ if state.todos.length is options.length # Activate the pump\n          proxy\n        new Proxy builder,\n          get: (target, name) ->\n            return target[name] if target[name]?\n            proxy.type.push name\n            if not obj.registry.registered(proxy.type, parent: true) and not registry.registered(proxy.type, parent: true)\n              proxy.type = []\n              return undefined\n            get_proxy_builder()\n      get_proxy_builder()\n  normalize_options = (_arguments, type, enrich=true) ->\n    empty = false\n    middleware = obj.registry.get(type) or registry.get(type) if Array.isArray(type)\n    _arguments.unshift middleware.handler if middleware\n    handler = null\n    callback = null\n    options = []\n    for arg in _arguments\n      if typeof arg is 'function'\n        if not handler then handler = arg\n        else unless callback then callback = arg\n        else throw Error \"Invalid third function argument\"\n      else if Array.isArray arg\n        empty = true if arg.length is 0\n        for a in arg\n          if type is 'call'\n            a = handler: a unless typeof a is 'object' and not Array.isArray(a) and a isnt null\n          else\n            a = argument: a unless typeof a is 'object' and not Array.isArray(a) and a isnt null\n          options.push a\n      else\n        if typeof arg isnt 'object' and arg isnt null\n          arg = argument: arg\n        if options.length is 0\n          cloned_arg = {}\n          for k, v of arg then cloned_arg[k] = v\n          options.push cloned_arg\n        else for opts in options\n          for k, v of arg then opts[k] = v\n    return options if options.length is 0 and empty\n    options.push {} if options.length is 0\n    if options.length and options.filter( (opts) -> not opts.handler ).length is 0\n      callback = handler\n      handler = null\n    # Normalize\n    for opts, i in options\n      # Clone\n      options[i] = {}\n      merge options[i], middleware if Array.isArray(type)\n      options[i][k] = v for k, v of opts\n      opts = options[i]\n      # Argument\n      if type is 'call' and not opts.handler #and typeof opts.argument is 'function'\n        opts.handler = opts.argument\n        opts.argument = undefined\n      # Enrich\n      if opts.destination\n        console.info 'Use options target instead of destination' unless called_deprecate_destination\n        called_deprecate_destination = true\n        opts.target ?= opts.destination\n      if opts.local_source\n        console.info 'Use options local instead of local_source' unless called_deprecate_local_source\n        called_deprecate_local_source = true\n        opts.local ?= opts.local_source\n      opts.type = type if type\n      opts.type = [opts.type] unless Array.isArray opts.type\n      opts.handler ?= handler if handler\n      opts.callback ?= callback if callback\n      opts.user_args = true if enrich and opts.callback?.length > 2\n      opts.once = ['handler'] if opts.once is true\n      delete opts.once if opts.once is false\n      opts.once = opts.once.sort() if Array.isArray opts.once\n      opts.sleep ?= 3000 # Wait 3s between retry\n      opts.retry ?= 0\n      opts.disabled ?= false\n      opts.status ?= true\n      throw Error 'Incompatible Options: status \"false\" implies shy \"true\"' if opts.status is false and opts.shy is false # Room for argument, leave it strict for now until we come accross a usecase justifying it.\n      opts.shy ?= true if opts.status is false\n      # Validation\n      jump_to_error Error \"Invalid options sleep, got #{JSON.stringify opts.sleep}\" unless typeof opts.sleep is 'number' and opts.sleep >= 0\n    options\n  enrich_options = (user_options) ->\n    user_options.enriched = true\n    global_options = obj.options\n    parent_options = state.todos.options\n    options = {}\n    for k, v of user_options then options[k] = user_options[k]\n    for k, v of parent_options\n      options[k] = v if options[k] is undefined and obj.propagation[k]\n    for k, v of global_options\n      options[k] = v if options[k] is undefined\n    unless options.log?.dont\n      if options.log and not Array.isArray options.log\n        _logs = [options.log]\n      else if not options.log\n        _logs = []\n    log_disabled = true if options.log is false\n    options.log = [] if log_disabled\n    options.log = [] if options.log?._nikita_ # not clean but no better way to detect user provided option with the one from nikita\n    options.log ?= []\n    options.log = [options.log] unless Array.isArray options.log\n    _logs = options.log\n    if options.debug\n      _logs.push (log) ->\n        return unless log.type in ['text', 'stdin', 'stdout_stream', 'stderr_stream']\n        return if log.type in ['stdout_stream', 'stderr_stream'] and log.message is null\n        msg = if log.message?.toString? then log.message.toString() else log.message\n        msg = \"[#{log.total_depth}.#{log.level} #{log.module}] #{JSON.stringify msg}\"\n        msg = switch log.type\n          when 'stdin' then \"\\x1b[33m#{msg}\\x1b[39m\"\n          when 'stdout_stream' then \"\\x1b[36m#{msg}\\x1b[39m\"\n          when 'stderr_stream' then \"\\x1b[35m#{msg}\\x1b[39m\"\n          else \"\\x1b[32m#{msg}\\x1b[39m\"\n        process.stdout.write \"#{msg}\\n\" # todo: switch with stderr\n    options.log = (log) ->\n      log = message: log if typeof log is 'string'\n      log.level ?= 'INFO'\n      log.time ?= Date.now()\n      log.module ?= undefined\n      log.header_depth ?= state.depth\n      log.headers ?= header for header in state.headers\n      log.total_depth ?= state.stack.length\n      log.type ?= 'text'\n      log.shy ?= options.shy\n      args = if 1 <= arguments.length then [].slice.call(arguments, 0) else []\n      stackTrace = require 'stack-trace'\n      frame = stackTrace.get()[1]\n      file = path.basename(frame.getFileName())\n      line = frame.getLineNumber()\n      method = frame.getFunctionName()\n      log.file = file\n      log.line = line\n      args.unshift(\"\" + file + \":\" + line + \" in \" + method + \"()\");\n      _log log for _log in _logs\n      obj.emit? log.type, log unless log_disabled\n    options.log._nikita_ = true\n    if options.source and match = /~($|\\/.*)/.exec options.source\n      unless obj.store['nikita:ssh:connection']\n      then options.source = path.join process.env.HOME, match[1]\n      else options.source = path.posix.join '.', match[1]\n    if options.target and match = /~($|\\/.*)/.exec options.target\n      unless obj.store['nikita:ssh:connection']\n      then options.target = path.join process.env.HOME, match[1]\n      else options.target = path.posix.join '.', match[1]\n    options\n  call_callback = (fn, args) ->\n    state.stack.unshift state.todos\n    state.todos = todos_create()\n    try\n      fn.apply proxy, args\n    catch err\n      state.todos = state.stack.shift()\n      jump_to_error err\n      args[0] = err\n      return run()\n    mtodos = state.todos\n    state.todos = state.stack.shift()\n    state.todos.unshift mtodos... if mtodos.length\n  handle_multiple_call = (err) ->\n    state.killed = true\n    state.todos = state.stack.shift() while state.stack.length\n    jump_to_error err\n    run()\n  jump_to_error = (err) ->\n    while state.todos[0] and state.todos[0].type not in ['catch', 'next', 'promise'] then state.todos.shift()\n    state.todos.err = err\n  _run_ = ->\n    if obj.options.domain\n    then obj.options.domain.run run\n    else run()\n  run = (options, callback) ->\n    options = state.todos.shift() unless options\n    unless options # Nothing more to do in current queue\n      if callback\n        callback state.todos.err\n      else\n        throw state.todos.err if not state.killed and state.stack.length is 0 and state.todos.err and state.todos.throw_if_error\n      if state.stack.length is 0\n        obj.options.domain?.removeListener 'error', domain_on_error\n      return\n    org_options = options\n    parent_options = state.todos.options\n    for k, v of parent_options\n      org_options[k] = v if org_options[k] is undefined and k isnt 'log' and obj.propagation[k] is true\n    options = enrich_options options\n    options.original = org_options\n    if options.type is 'next'\n      {err, status} = state.todos\n      status = status.some (status) -> not status.shy and !!status.value\n      state.todos.final_err = err\n      todos_reset state.todos\n      options.handler?.call proxy, err, status\n      run()\n      return\n    if options.type is 'promise'\n      {err, status} = state.todos\n      status = status.some (status) -> not status.shy and !!status.value\n      state.todos.final_err = err\n      todos_reset state.todos\n      options.handler?.call proxy, err, status\n      unless err\n      then options.deferred.resolve status\n      else options.deferred.reject err\n      return\n    return if state.killed\n    if array.compare options.type, ['end']\n      return conditions.all proxy, options\n      , ->\n        while state.todos[0] and state.todos[0].type not in ['next', 'promise'] then state.todos.shift()\n        callback err if callback\n        run()\n      , (err) ->\n        callback err if callback\n        run()\n    index = state.index_counter++\n    state.depth++ if options.header\n    state.headers.push options.header if options.header\n    options.log message: options.header, type: 'header', index: index, depth: state.depth, headers: (header for header in state.headers) if options.header\n    state.todos.status.unshift shy: options.shy, value: undefined\n    state.stack.unshift state.todos\n    state.todos = todos_create()\n    state.todos.options = org_options\n    wrap.options options, (err) ->\n      do_disabled = ->\n        unless options.disabled\n          options.log type: 'lifecycle', message: 'disabled_false', level: 'DEBUG', index: index, depth: state.depth, error: null, status: false\n          do_once()\n        else\n          options.log type: 'lifecycle', message: 'disabled_true', level: 'INFO', index: index, depth: state.depth, error: null, status: false\n          do_callback []\n      do_once = ->\n        hashme = (value) ->\n          if typeof value is 'string'\n            value = \"string:#{string.hash value}\"\n          else if typeof value is 'boolean'\n            value = \"boolean:#{value}\"\n          else if typeof value is 'function'\n            value = \"function:#{string.hash value.toString()}\"\n          else if value is undefined or value is null\n            value = 'null'\n          else if Array.isArray value\n            value = 'array:' + value.sort().map((value) -> hashme value).join ':'\n          else if typeof value is 'object'\n            value = 'object'\n          else throw Error \"Invalid data type: #{JSON.stringify value}\"\n          value\n        if options.once\n          if typeof options.once is 'string'\n            hash = string.hash options.once\n          else if Array.isArray options.once\n            hash = string.hash options.once.map((k) -> hashme options[k]).join '|'\n          else\n            throw Error \"Invalid Option 'once': #{JSON.stringify options.once} must be a string or an array of string\"\n          return do_callback [] if state.once[hash]\n          state.once[hash] = true\n        do_options_before()\n      do_options_before = ->\n        return do_intercept_before() if options.options_before\n        options.before ?= []\n        options.before = [options.before] unless Array.isArray options.before\n        each options.before\n        .call (before, next) ->\n          before = normalize_options [before], 'call', false\n          before = before[0]\n          opts = options_before: true\n          for k, v of before\n            opts[k] = v\n          for k, v of options\n            continue if k in ['handler', 'callback']\n            opts[k] ?= v\n          run opts, next\n        .error (err) -> do_callback [err]\n        .next do_intercept_before\n      do_intercept_before = ->\n        return do_conditions() if options.intercepting\n        each state.befores\n        .call (before, next) ->\n          for k, v of before then switch k\n            when 'handler' then continue\n            when 'type' then return next() unless array.compare v, options[k]\n            else return next() unless v is options[k]\n          opts = intercepting: true\n          for k, v of before\n            opts[k] = v\n          for k, v of options\n            continue if k in ['handler', 'callback']\n            opts[k] ?= v\n          run opts, next\n        .error (err) -> do_callback [err]\n        .next do_conditions\n      do_conditions = ->\n        conditions.all proxy, options\n        , ->\n          for k, v of options # Remove conditions from options\n            delete options[k] if /^if.*/.test(k) or /^unless.*/.test(k)\n          options.log type: 'lifecycle', message: 'conditions_passed', index: index, depth: state.depth, error: null, status: false\n          do_handler()\n        , (err) ->\n          options.log type: 'lifecycle', message: 'conditions_failed', index: index, depth: state.depth, error: err, status: false\n          do_callback [err]\n      options.attempt = -1\n      do_handler = ->\n        options.attempt++\n        do_next = ([err]) ->\n          options.handler = options_handler\n          options.callback = options_callback\n          if err and err not instanceof Error\n            err = Error 'First argument not a valid error'\n            arguments[0][0] = err\n          options.log message: err.message, level: 'ERROR', index: index, module: 'nikita' if err\n          if err and ( options.retry is true or options.attempt < options.retry - 1 )\n            options.log message: \"Retry on error, attempt #{options.attempt+1}\", level: 'WARN', index: index, module: 'nikita'\n            return setTimeout do_handler, options.sleep\n          do_intercept_after arguments...\n        options.handler ?= obj.registry.get(options.type)?.handler or registry.get(options.type)?.handler\n        return handle_multiple_call Error \"Unregistered Middleware: #{options.type.join('.')}\" unless options.handler\n        options_handler = options.handler\n        options_handler_length = options.handler.length\n        options.handler = undefined\n        options_callback = options.callback\n        options.callback = undefined\n        called = false\n        try\n          # Option to inject\n          opts = {}\n          # Clone first level properties\n          for k, v of options then opts[k] = v\n          for option, propagate of obj.propagation\n            delete opts[option] if propagate is false\n          # Handle deprecation\n          options_handler = ( (options_handler) ->\n            util.deprecate ->\n              options_handler.apply @, arguments\n            , if options.deprecate is true\n            then \"#{options.type.join '/'} is deprecated\"\n            else \"#{options.type.join '/'} is deprecated, use #{options.deprecate}\"\n          )(options_handler) if options.deprecate\n          handle_async_and_promise = ->\n            return if state.killed\n            return handle_multiple_call Error 'Multiple call detected' if called\n            called = true\n            args = [].slice.call(arguments, 0)\n            setImmediate ->\n              do_next args\n          if options_handler_length is 2 # Async style\n            promise_returned = false\n            result = options_handler.call proxy, opts, ->\n              return if promise_returned\n              handle_async_and_promise.apply null, arguments\n            if promise.is result\n              promise_returned = true\n              return handle_async_and_promise Error 'Invalid Promise: returning promise is not supported in asynchronuous mode'\n          else # Sync style\n            result = options_handler.call proxy, opts\n            if promise.is result # result is a promisee\n              result.then (value) ->\n                value = [value] unless Array.isArray value\n                handle_async_and_promise null, value...\n              , (reason) ->\n                reason = Error 'Rejected Promise: reject called without any arguments' unless reason?\n                handle_async_and_promise reason\n            else\n              return if state.killed\n              return handle_multiple_call Error 'Multiple call detected' if called\n              called = true\n              status_sync = false\n              wait_children = ->\n                unless state.todos.length\n                  return setImmediate ->\n                    do_next [null, status_sync]\n                loptions = state.todos.shift()\n                run loptions, (err, status) ->\n                  return do_next [err] if err\n                  # Discover status of all unshy children\n                  status_sync = true if status and not loptions.shy\n                  wait_children()\n              wait_children()\n        catch err\n          state.todos = []\n          do_next [err]\n      do_intercept_after = (args, callback) ->\n        return do_options_after args if options.intercepting\n        each state.afters\n        .call (after, next) ->\n          for k, v of after then switch k\n            when 'handler' then continue\n            when 'type' then return next() unless array.compare v, options[k]\n            else return next() unless v is options[k]\n          opts = intercepting: true\n          for k, v of after\n            opts[k] = v\n          for k, v of options\n            continue if k in ['handler', 'callback']\n            opts[k] ?= v\n          opts.callback_arguments = args\n          run opts, next\n        .error (err) -> do_callback [err]\n        .next -> do_options_after args\n      do_options_after = (args) ->\n        return do_callback args if options.options_after\n        options.after ?= []\n        options.after = [options.after] unless Array.isArray options.after\n        each options.after\n        .call (after, next) ->\n          after = normalize_options [after], 'call', false\n          after = after[0]\n          opts = options_after: true\n          for k, v of after\n            opts[k] = v\n          for k, v of options\n            continue if k in ['handler', 'callback']\n            opts[k] ?= v\n          run opts, next\n        .error (err) -> do_callback [err]\n        .next -> do_callback args\n      do_callback = (args) ->\n        state.depth-- if options.header\n        state.headers.pop() if options.header\n        options.log type: 'handled', index: index, depth: state.depth, error: args[0], status: args[1]\n        return if state.killed\n        args[0] = undefined unless args[0] # Error is undefined and not null or false\n        args[1] = !!args[1] if options.status # Status is a boolean, error or not\n        state.todos = state.stack.shift() if state.todos.length is 0\n        jump_to_error args[0] if args[0] and not options.relax\n        state.todos.throw_if_error = false if args[0] and options.callback\n        # todo: we might want to log here a change of status, sth like:\n        # options.log type: 'lifecycle', message: 'status', index: index, depth: state.depth, error: err, status: true if options.status and args[1] and not state.todos.status.some (satus) -> status\n        state.todos.status[0].value = args[1] if options.status\n        call_callback options.callback, args if options.callback\n        args[0] = null if options.relax\n        callback args[0], args[1] if callback\n        run()\n      do_disabled()\n  state.properties.child = get: -> ->\n    module.exports(obj.options)\n  state.properties.next = get: -> ->\n    state.todos.push type: 'next', handler: arguments[0]\n    setImmediate _run_ if state.todos.length is 1 # Activate the pump\n    proxy\n  state.properties.promise = get: -> ->\n    deferred = {}\n    promise = new Promise (resolve, reject)->\n      deferred.resolve = resolve\n      deferred.reject = reject\n    state.todos.push type: 'promise', deferred: deferred # handler: arguments[0],\n    setImmediate _run_ if state.todos.length is 1 # Activate the pump\n    promise\n  state.properties.end = get: -> ->\n    args = [].slice.call(arguments)\n    options = normalize_options args, 'end'\n    state.todos.push opts for opts in options\n    setImmediate _run_ if state.todos.length is options.length # Activate the pump\n    proxy\n  state.properties.call = get: -> ->\n    args = [].slice.call(arguments)\n    options = normalize_options args, 'call'\n    for opts in options\n      if typeof opts.handler is 'string'\n        opts.handler = path.resolve process.cwd(), opts.handler if opts.handler.substr(0, 1) is '.'\n        mod = require.main.require opts.handler\n        throw Error 'Array modules not yet supported' if Array.isArray mod\n        mod = normalize_options [mod], 'call'\n        opts.handler = mod.handler\n        opts[k] ?= v for k, v of mod[0]\n      throw Error 'Missing handler option' unless opts.handler\n      throw Error \"Invalid Handler: expect a function, got '#{opts.handler}'\" unless typeof opts.handler is 'function'\n    {get, values} = handle_get proxy, options\n    return values if get\n    state.todos.push opts for opts in options\n    setImmediate _run_ if state.todos.length is options.length # Activate the pump\n    proxy\n  state.properties.each = get: -> ->\n    args = [].slice.call(arguments)\n    arg = args.shift()\n    if not arg? or typeof arg isnt 'object'\n      jump_to_error Error \"Invalid Argument: first argument must be an array or an object to iterate, got #{JSON.stringify arg}\"\n      return proxy\n    options = normalize_options args, 'call'\n    for opts in options\n      if Array.isArray arg\n        for key in arg\n          opts.key = key\n          @call opts\n      else\n        for key, value of arg\n          opts.key = key\n          opts.value = value\n          @call opts\n    proxy\n  state.properties.before = get: -> ->\n    arguments[0] = type: arguments[0] if typeof arguments[0] is 'string' or Array.isArray(arguments[0])\n    options = normalize_options arguments, null, false\n    for opts in options\n      throw Error \"Invalid handler #{JSON.stringify opts.handler}\" unless typeof opts.handler is 'function'\n      state.befores.push opts\n    proxy\n  state.properties.after = get: -> ->\n    arguments[0] = type: arguments[0] if typeof arguments[0] is 'string' or Array.isArray(arguments[0])\n    options = normalize_options arguments, null, false\n    for opts in options\n      throw Error \"Invalid handler #{JSON.stringify opts.handler}\" unless typeof opts.handler is 'function'\n      state.afters.push opts\n    proxy\n  state.properties.status = get: -> (index) ->\n    if arguments.length is 0\n      return state.stack[0].status.some (status) -> not status.shy and !!status.value\n    else if index is false\n      value = state.stack[0].status.some (status) -> not status.shy and !!status.value\n      status.value = false for status in state.stack[0].status\n      return value\n    else if index is true\n      value = state.stack[0].status.some (status) -> not status.shy and !!status.value\n      status.value = true for status in state.stack[0].status\n      return value\n    else\n      state.stack[0].status[Math.abs index]?.value\n  Object.defineProperties obj, state.properties\n  reg = registry.registry {}\n  Object.defineProperty obj.registry, 'get', get: -> (name, handler) ->\n    reg.get arguments...\n  Object.defineProperty obj.registry, 'register', get: -> (name, handler) ->\n    reg.register arguments...\n    proxy\n  Object.defineProperty obj.registry, 'registered', get: -> (name, handler) ->\n    reg.registered arguments...\n  Object.defineProperty obj.registry, 'unregister', get: -> (name, handler) ->\n    reg.unregister arguments...\n    proxy\n  if obj.options.ssh\n    if obj.options.ssh.config\n      obj.store['nikita:ssh:connection'] = obj.options.ssh\n      delete obj.options.ssh\n    else\n      proxy.ssh.open obj.options.ssh if not obj.options.no_ssh\n  proxy\n\nmodule.exports.propagation =\n  ssh: true\n  log: true\n  stdout: true\n  stderr: true\n  debug: true\n  after: false\n  before: false\n  disabled: false\n  domain: false\n  handler: false\n  header: false\n  once: false\n  relax: false\n  shy: false\n  sleep: false\n  sudo: true\n\n\n\nHelper functions\n\n\ntodos_create = ->\n  todos = []\n  todos_reset todos\n  todos\ntodos_reset = (todos) ->\n  todos.err = null\n  todos.status = []\n  todos.throw_if_error = true\nhandle_get = (proxy, options) ->\n  return get: false unless options.length is 1\n  if options.length is options.filter( (opts) -> opts.get is true ).length\n    get = true\n    values = for opts in options\n      opts.handler.call proxy, opts, opts.callback\n    values = values[0] if values.length is 1\n  get: get, values: values\n\n\n\nDependencies\n\n\nregistry = require './registry'\ndomain = require 'domain'\neach = require 'each'\npath = require 'path'\nutil = require 'util'\narray = require './misc/array'\npromise = require './misc/promise'\nconditions = require './misc/conditions'\nwrap = require './misc/wrap'\nstring = require './misc/string'\n{merge} = require './misc'\n{EventEmitter} = require 'events'",
            "title": "Context.coffee"
        },
        {
            "location": "/context.coffee/#nikita-context",
            "text": "called_deprecate_destination = false\ncalled_deprecate_local_source = false\nmodule.exports = ->\n  if arguments.length is 2\n    obj = arguments[0]\n    obj.options = arguments[1]\n  else if arguments.length is 1\n    obj = new EventEmitter\n    obj.options = arguments[0]\n  else\n    obj = new EventEmitter\n    obj.options = {}\n  obj.registry ?= {}\n  obj.propagation ?= obj.options.propagation or {}\n  obj.store ?= {}\n  # Merge global default propagation\n  for k, v of module.exports.propagation\n    obj.propagation[k] = v unless obj.propagation[k] isnt undefined\n  # Internal state\n  state = {}\n  state.properties = {}\n  state.stack = []\n  state.todos = todos_create()\n  state.befores = []\n  state.afters = []\n  state.depth = 0\n  state.headers = []\n  state.once = {}\n  state.killed = false\n  state.index_counter = 0\n  # Domain\n  obj.options.domain =  domain.create() if obj.options.domain is true\n  domain_on_error = (err) ->\n    err.message = \"Invalid State Error [#{err.message}]\"\n    handle_multiple_call err\n  obj.options.domain?.on 'error', domain_on_error\n  # Proxify\n  proxy = new Proxy obj,\n    has: (target, name) ->\n      console.warns 'proxy has is being called', name\n      # target[name]? or target.registry.registered(proxy.type)? or registry.registered(name)?\n    apply: (target, thisArg, argumentsList) ->\n      console.warn 'apply'\n    get: (target, name) ->\n      return target[name] if obj[name]?\n      return target[name] if name in ['domain', '_events', '_maxListeners']\n      proxy.type = []\n      proxy.type.push name\n      if not obj.registry.registered(proxy.type, parent: true) and not registry.registered(proxy.type, parent: true)\n        proxy.type = []\n        return undefined\n      get_proxy_builder = ->\n        builder = ->\n          args = [].slice.call(arguments)\n          options = normalize_options args, proxy.type\n          {get, values} = handle_get proxy, options\n          return values if get\n          proxy.type = []\n          state.todos.push opts for opts in options\n          setImmediate _run_ if state.todos.length is options.length # Activate the pump\n          proxy\n        new Proxy builder,\n          get: (target, name) ->\n            return target[name] if target[name]?\n            proxy.type.push name\n            if not obj.registry.registered(proxy.type, parent: true) and not registry.registered(proxy.type, parent: true)\n              proxy.type = []\n              return undefined\n            get_proxy_builder()\n      get_proxy_builder()\n  normalize_options = (_arguments, type, enrich=true) ->\n    empty = false\n    middleware = obj.registry.get(type) or registry.get(type) if Array.isArray(type)\n    _arguments.unshift middleware.handler if middleware\n    handler = null\n    callback = null\n    options = []\n    for arg in _arguments\n      if typeof arg is 'function'\n        if not handler then handler = arg\n        else unless callback then callback = arg\n        else throw Error \"Invalid third function argument\"\n      else if Array.isArray arg\n        empty = true if arg.length is 0\n        for a in arg\n          if type is 'call'\n            a = handler: a unless typeof a is 'object' and not Array.isArray(a) and a isnt null\n          else\n            a = argument: a unless typeof a is 'object' and not Array.isArray(a) and a isnt null\n          options.push a\n      else\n        if typeof arg isnt 'object' and arg isnt null\n          arg = argument: arg\n        if options.length is 0\n          cloned_arg = {}\n          for k, v of arg then cloned_arg[k] = v\n          options.push cloned_arg\n        else for opts in options\n          for k, v of arg then opts[k] = v\n    return options if options.length is 0 and empty\n    options.push {} if options.length is 0\n    if options.length and options.filter( (opts) -> not opts.handler ).length is 0\n      callback = handler\n      handler = null\n    # Normalize\n    for opts, i in options\n      # Clone\n      options[i] = {}\n      merge options[i], middleware if Array.isArray(type)\n      options[i][k] = v for k, v of opts\n      opts = options[i]\n      # Argument\n      if type is 'call' and not opts.handler #and typeof opts.argument is 'function'\n        opts.handler = opts.argument\n        opts.argument = undefined\n      # Enrich\n      if opts.destination\n        console.info 'Use options target instead of destination' unless called_deprecate_destination\n        called_deprecate_destination = true\n        opts.target ?= opts.destination\n      if opts.local_source\n        console.info 'Use options local instead of local_source' unless called_deprecate_local_source\n        called_deprecate_local_source = true\n        opts.local ?= opts.local_source\n      opts.type = type if type\n      opts.type = [opts.type] unless Array.isArray opts.type\n      opts.handler ?= handler if handler\n      opts.callback ?= callback if callback\n      opts.user_args = true if enrich and opts.callback?.length > 2\n      opts.once = ['handler'] if opts.once is true\n      delete opts.once if opts.once is false\n      opts.once = opts.once.sort() if Array.isArray opts.once\n      opts.sleep ?= 3000 # Wait 3s between retry\n      opts.retry ?= 0\n      opts.disabled ?= false\n      opts.status ?= true\n      throw Error 'Incompatible Options: status \"false\" implies shy \"true\"' if opts.status is false and opts.shy is false # Room for argument, leave it strict for now until we come accross a usecase justifying it.\n      opts.shy ?= true if opts.status is false\n      # Validation\n      jump_to_error Error \"Invalid options sleep, got #{JSON.stringify opts.sleep}\" unless typeof opts.sleep is 'number' and opts.sleep >= 0\n    options\n  enrich_options = (user_options) ->\n    user_options.enriched = true\n    global_options = obj.options\n    parent_options = state.todos.options\n    options = {}\n    for k, v of user_options then options[k] = user_options[k]\n    for k, v of parent_options\n      options[k] = v if options[k] is undefined and obj.propagation[k]\n    for k, v of global_options\n      options[k] = v if options[k] is undefined\n    unless options.log?.dont\n      if options.log and not Array.isArray options.log\n        _logs = [options.log]\n      else if not options.log\n        _logs = []\n    log_disabled = true if options.log is false\n    options.log = [] if log_disabled\n    options.log = [] if options.log?._nikita_ # not clean but no better way to detect user provided option with the one from nikita\n    options.log ?= []\n    options.log = [options.log] unless Array.isArray options.log\n    _logs = options.log\n    if options.debug\n      _logs.push (log) ->\n        return unless log.type in ['text', 'stdin', 'stdout_stream', 'stderr_stream']\n        return if log.type in ['stdout_stream', 'stderr_stream'] and log.message is null\n        msg = if log.message?.toString? then log.message.toString() else log.message\n        msg = \"[#{log.total_depth}.#{log.level} #{log.module}] #{JSON.stringify msg}\"\n        msg = switch log.type\n          when 'stdin' then \"\\x1b[33m#{msg}\\x1b[39m\"\n          when 'stdout_stream' then \"\\x1b[36m#{msg}\\x1b[39m\"\n          when 'stderr_stream' then \"\\x1b[35m#{msg}\\x1b[39m\"\n          else \"\\x1b[32m#{msg}\\x1b[39m\"\n        process.stdout.write \"#{msg}\\n\" # todo: switch with stderr\n    options.log = (log) ->\n      log = message: log if typeof log is 'string'\n      log.level ?= 'INFO'\n      log.time ?= Date.now()\n      log.module ?= undefined\n      log.header_depth ?= state.depth\n      log.headers ?= header for header in state.headers\n      log.total_depth ?= state.stack.length\n      log.type ?= 'text'\n      log.shy ?= options.shy\n      args = if 1 <= arguments.length then [].slice.call(arguments, 0) else []\n      stackTrace = require 'stack-trace'\n      frame = stackTrace.get()[1]\n      file = path.basename(frame.getFileName())\n      line = frame.getLineNumber()\n      method = frame.getFunctionName()\n      log.file = file\n      log.line = line\n      args.unshift(\"\" + file + \":\" + line + \" in \" + method + \"()\");\n      _log log for _log in _logs\n      obj.emit? log.type, log unless log_disabled\n    options.log._nikita_ = true\n    if options.source and match = /~($|\\/.*)/.exec options.source\n      unless obj.store['nikita:ssh:connection']\n      then options.source = path.join process.env.HOME, match[1]\n      else options.source = path.posix.join '.', match[1]\n    if options.target and match = /~($|\\/.*)/.exec options.target\n      unless obj.store['nikita:ssh:connection']\n      then options.target = path.join process.env.HOME, match[1]\n      else options.target = path.posix.join '.', match[1]\n    options\n  call_callback = (fn, args) ->\n    state.stack.unshift state.todos\n    state.todos = todos_create()\n    try\n      fn.apply proxy, args\n    catch err\n      state.todos = state.stack.shift()\n      jump_to_error err\n      args[0] = err\n      return run()\n    mtodos = state.todos\n    state.todos = state.stack.shift()\n    state.todos.unshift mtodos... if mtodos.length\n  handle_multiple_call = (err) ->\n    state.killed = true\n    state.todos = state.stack.shift() while state.stack.length\n    jump_to_error err\n    run()\n  jump_to_error = (err) ->\n    while state.todos[0] and state.todos[0].type not in ['catch', 'next', 'promise'] then state.todos.shift()\n    state.todos.err = err\n  _run_ = ->\n    if obj.options.domain\n    then obj.options.domain.run run\n    else run()\n  run = (options, callback) ->\n    options = state.todos.shift() unless options\n    unless options # Nothing more to do in current queue\n      if callback\n        callback state.todos.err\n      else\n        throw state.todos.err if not state.killed and state.stack.length is 0 and state.todos.err and state.todos.throw_if_error\n      if state.stack.length is 0\n        obj.options.domain?.removeListener 'error', domain_on_error\n      return\n    org_options = options\n    parent_options = state.todos.options\n    for k, v of parent_options\n      org_options[k] = v if org_options[k] is undefined and k isnt 'log' and obj.propagation[k] is true\n    options = enrich_options options\n    options.original = org_options\n    if options.type is 'next'\n      {err, status} = state.todos\n      status = status.some (status) -> not status.shy and !!status.value\n      state.todos.final_err = err\n      todos_reset state.todos\n      options.handler?.call proxy, err, status\n      run()\n      return\n    if options.type is 'promise'\n      {err, status} = state.todos\n      status = status.some (status) -> not status.shy and !!status.value\n      state.todos.final_err = err\n      todos_reset state.todos\n      options.handler?.call proxy, err, status\n      unless err\n      then options.deferred.resolve status\n      else options.deferred.reject err\n      return\n    return if state.killed\n    if array.compare options.type, ['end']\n      return conditions.all proxy, options\n      , ->\n        while state.todos[0] and state.todos[0].type not in ['next', 'promise'] then state.todos.shift()\n        callback err if callback\n        run()\n      , (err) ->\n        callback err if callback\n        run()\n    index = state.index_counter++\n    state.depth++ if options.header\n    state.headers.push options.header if options.header\n    options.log message: options.header, type: 'header', index: index, depth: state.depth, headers: (header for header in state.headers) if options.header\n    state.todos.status.unshift shy: options.shy, value: undefined\n    state.stack.unshift state.todos\n    state.todos = todos_create()\n    state.todos.options = org_options\n    wrap.options options, (err) ->\n      do_disabled = ->\n        unless options.disabled\n          options.log type: 'lifecycle', message: 'disabled_false', level: 'DEBUG', index: index, depth: state.depth, error: null, status: false\n          do_once()\n        else\n          options.log type: 'lifecycle', message: 'disabled_true', level: 'INFO', index: index, depth: state.depth, error: null, status: false\n          do_callback []\n      do_once = ->\n        hashme = (value) ->\n          if typeof value is 'string'\n            value = \"string:#{string.hash value}\"\n          else if typeof value is 'boolean'\n            value = \"boolean:#{value}\"\n          else if typeof value is 'function'\n            value = \"function:#{string.hash value.toString()}\"\n          else if value is undefined or value is null\n            value = 'null'\n          else if Array.isArray value\n            value = 'array:' + value.sort().map((value) -> hashme value).join ':'\n          else if typeof value is 'object'\n            value = 'object'\n          else throw Error \"Invalid data type: #{JSON.stringify value}\"\n          value\n        if options.once\n          if typeof options.once is 'string'\n            hash = string.hash options.once\n          else if Array.isArray options.once\n            hash = string.hash options.once.map((k) -> hashme options[k]).join '|'\n          else\n            throw Error \"Invalid Option 'once': #{JSON.stringify options.once} must be a string or an array of string\"\n          return do_callback [] if state.once[hash]\n          state.once[hash] = true\n        do_options_before()\n      do_options_before = ->\n        return do_intercept_before() if options.options_before\n        options.before ?= []\n        options.before = [options.before] unless Array.isArray options.before\n        each options.before\n        .call (before, next) ->\n          before = normalize_options [before], 'call', false\n          before = before[0]\n          opts = options_before: true\n          for k, v of before\n            opts[k] = v\n          for k, v of options\n            continue if k in ['handler', 'callback']\n            opts[k] ?= v\n          run opts, next\n        .error (err) -> do_callback [err]\n        .next do_intercept_before\n      do_intercept_before = ->\n        return do_conditions() if options.intercepting\n        each state.befores\n        .call (before, next) ->\n          for k, v of before then switch k\n            when 'handler' then continue\n            when 'type' then return next() unless array.compare v, options[k]\n            else return next() unless v is options[k]\n          opts = intercepting: true\n          for k, v of before\n            opts[k] = v\n          for k, v of options\n            continue if k in ['handler', 'callback']\n            opts[k] ?= v\n          run opts, next\n        .error (err) -> do_callback [err]\n        .next do_conditions\n      do_conditions = ->\n        conditions.all proxy, options\n        , ->\n          for k, v of options # Remove conditions from options\n            delete options[k] if /^if.*/.test(k) or /^unless.*/.test(k)\n          options.log type: 'lifecycle', message: 'conditions_passed', index: index, depth: state.depth, error: null, status: false\n          do_handler()\n        , (err) ->\n          options.log type: 'lifecycle', message: 'conditions_failed', index: index, depth: state.depth, error: err, status: false\n          do_callback [err]\n      options.attempt = -1\n      do_handler = ->\n        options.attempt++\n        do_next = ([err]) ->\n          options.handler = options_handler\n          options.callback = options_callback\n          if err and err not instanceof Error\n            err = Error 'First argument not a valid error'\n            arguments[0][0] = err\n          options.log message: err.message, level: 'ERROR', index: index, module: 'nikita' if err\n          if err and ( options.retry is true or options.attempt < options.retry - 1 )\n            options.log message: \"Retry on error, attempt #{options.attempt+1}\", level: 'WARN', index: index, module: 'nikita'\n            return setTimeout do_handler, options.sleep\n          do_intercept_after arguments...\n        options.handler ?= obj.registry.get(options.type)?.handler or registry.get(options.type)?.handler\n        return handle_multiple_call Error \"Unregistered Middleware: #{options.type.join('.')}\" unless options.handler\n        options_handler = options.handler\n        options_handler_length = options.handler.length\n        options.handler = undefined\n        options_callback = options.callback\n        options.callback = undefined\n        called = false\n        try\n          # Option to inject\n          opts = {}\n          # Clone first level properties\n          for k, v of options then opts[k] = v\n          for option, propagate of obj.propagation\n            delete opts[option] if propagate is false\n          # Handle deprecation\n          options_handler = ( (options_handler) ->\n            util.deprecate ->\n              options_handler.apply @, arguments\n            , if options.deprecate is true\n            then \"#{options.type.join '/'} is deprecated\"\n            else \"#{options.type.join '/'} is deprecated, use #{options.deprecate}\"\n          )(options_handler) if options.deprecate\n          handle_async_and_promise = ->\n            return if state.killed\n            return handle_multiple_call Error 'Multiple call detected' if called\n            called = true\n            args = [].slice.call(arguments, 0)\n            setImmediate ->\n              do_next args\n          if options_handler_length is 2 # Async style\n            promise_returned = false\n            result = options_handler.call proxy, opts, ->\n              return if promise_returned\n              handle_async_and_promise.apply null, arguments\n            if promise.is result\n              promise_returned = true\n              return handle_async_and_promise Error 'Invalid Promise: returning promise is not supported in asynchronuous mode'\n          else # Sync style\n            result = options_handler.call proxy, opts\n            if promise.is result # result is a promisee\n              result.then (value) ->\n                value = [value] unless Array.isArray value\n                handle_async_and_promise null, value...\n              , (reason) ->\n                reason = Error 'Rejected Promise: reject called without any arguments' unless reason?\n                handle_async_and_promise reason\n            else\n              return if state.killed\n              return handle_multiple_call Error 'Multiple call detected' if called\n              called = true\n              status_sync = false\n              wait_children = ->\n                unless state.todos.length\n                  return setImmediate ->\n                    do_next [null, status_sync]\n                loptions = state.todos.shift()\n                run loptions, (err, status) ->\n                  return do_next [err] if err\n                  # Discover status of all unshy children\n                  status_sync = true if status and not loptions.shy\n                  wait_children()\n              wait_children()\n        catch err\n          state.todos = []\n          do_next [err]\n      do_intercept_after = (args, callback) ->\n        return do_options_after args if options.intercepting\n        each state.afters\n        .call (after, next) ->\n          for k, v of after then switch k\n            when 'handler' then continue\n            when 'type' then return next() unless array.compare v, options[k]\n            else return next() unless v is options[k]\n          opts = intercepting: true\n          for k, v of after\n            opts[k] = v\n          for k, v of options\n            continue if k in ['handler', 'callback']\n            opts[k] ?= v\n          opts.callback_arguments = args\n          run opts, next\n        .error (err) -> do_callback [err]\n        .next -> do_options_after args\n      do_options_after = (args) ->\n        return do_callback args if options.options_after\n        options.after ?= []\n        options.after = [options.after] unless Array.isArray options.after\n        each options.after\n        .call (after, next) ->\n          after = normalize_options [after], 'call', false\n          after = after[0]\n          opts = options_after: true\n          for k, v of after\n            opts[k] = v\n          for k, v of options\n            continue if k in ['handler', 'callback']\n            opts[k] ?= v\n          run opts, next\n        .error (err) -> do_callback [err]\n        .next -> do_callback args\n      do_callback = (args) ->\n        state.depth-- if options.header\n        state.headers.pop() if options.header\n        options.log type: 'handled', index: index, depth: state.depth, error: args[0], status: args[1]\n        return if state.killed\n        args[0] = undefined unless args[0] # Error is undefined and not null or false\n        args[1] = !!args[1] if options.status # Status is a boolean, error or not\n        state.todos = state.stack.shift() if state.todos.length is 0\n        jump_to_error args[0] if args[0] and not options.relax\n        state.todos.throw_if_error = false if args[0] and options.callback\n        # todo: we might want to log here a change of status, sth like:\n        # options.log type: 'lifecycle', message: 'status', index: index, depth: state.depth, error: err, status: true if options.status and args[1] and not state.todos.status.some (satus) -> status\n        state.todos.status[0].value = args[1] if options.status\n        call_callback options.callback, args if options.callback\n        args[0] = null if options.relax\n        callback args[0], args[1] if callback\n        run()\n      do_disabled()\n  state.properties.child = get: -> ->\n    module.exports(obj.options)\n  state.properties.next = get: -> ->\n    state.todos.push type: 'next', handler: arguments[0]\n    setImmediate _run_ if state.todos.length is 1 # Activate the pump\n    proxy\n  state.properties.promise = get: -> ->\n    deferred = {}\n    promise = new Promise (resolve, reject)->\n      deferred.resolve = resolve\n      deferred.reject = reject\n    state.todos.push type: 'promise', deferred: deferred # handler: arguments[0],\n    setImmediate _run_ if state.todos.length is 1 # Activate the pump\n    promise\n  state.properties.end = get: -> ->\n    args = [].slice.call(arguments)\n    options = normalize_options args, 'end'\n    state.todos.push opts for opts in options\n    setImmediate _run_ if state.todos.length is options.length # Activate the pump\n    proxy\n  state.properties.call = get: -> ->\n    args = [].slice.call(arguments)\n    options = normalize_options args, 'call'\n    for opts in options\n      if typeof opts.handler is 'string'\n        opts.handler = path.resolve process.cwd(), opts.handler if opts.handler.substr(0, 1) is '.'\n        mod = require.main.require opts.handler\n        throw Error 'Array modules not yet supported' if Array.isArray mod\n        mod = normalize_options [mod], 'call'\n        opts.handler = mod.handler\n        opts[k] ?= v for k, v of mod[0]\n      throw Error 'Missing handler option' unless opts.handler\n      throw Error \"Invalid Handler: expect a function, got '#{opts.handler}'\" unless typeof opts.handler is 'function'\n    {get, values} = handle_get proxy, options\n    return values if get\n    state.todos.push opts for opts in options\n    setImmediate _run_ if state.todos.length is options.length # Activate the pump\n    proxy\n  state.properties.each = get: -> ->\n    args = [].slice.call(arguments)\n    arg = args.shift()\n    if not arg? or typeof arg isnt 'object'\n      jump_to_error Error \"Invalid Argument: first argument must be an array or an object to iterate, got #{JSON.stringify arg}\"\n      return proxy\n    options = normalize_options args, 'call'\n    for opts in options\n      if Array.isArray arg\n        for key in arg\n          opts.key = key\n          @call opts\n      else\n        for key, value of arg\n          opts.key = key\n          opts.value = value\n          @call opts\n    proxy\n  state.properties.before = get: -> ->\n    arguments[0] = type: arguments[0] if typeof arguments[0] is 'string' or Array.isArray(arguments[0])\n    options = normalize_options arguments, null, false\n    for opts in options\n      throw Error \"Invalid handler #{JSON.stringify opts.handler}\" unless typeof opts.handler is 'function'\n      state.befores.push opts\n    proxy\n  state.properties.after = get: -> ->\n    arguments[0] = type: arguments[0] if typeof arguments[0] is 'string' or Array.isArray(arguments[0])\n    options = normalize_options arguments, null, false\n    for opts in options\n      throw Error \"Invalid handler #{JSON.stringify opts.handler}\" unless typeof opts.handler is 'function'\n      state.afters.push opts\n    proxy\n  state.properties.status = get: -> (index) ->\n    if arguments.length is 0\n      return state.stack[0].status.some (status) -> not status.shy and !!status.value\n    else if index is false\n      value = state.stack[0].status.some (status) -> not status.shy and !!status.value\n      status.value = false for status in state.stack[0].status\n      return value\n    else if index is true\n      value = state.stack[0].status.some (status) -> not status.shy and !!status.value\n      status.value = true for status in state.stack[0].status\n      return value\n    else\n      state.stack[0].status[Math.abs index]?.value\n  Object.defineProperties obj, state.properties\n  reg = registry.registry {}\n  Object.defineProperty obj.registry, 'get', get: -> (name, handler) ->\n    reg.get arguments...\n  Object.defineProperty obj.registry, 'register', get: -> (name, handler) ->\n    reg.register arguments...\n    proxy\n  Object.defineProperty obj.registry, 'registered', get: -> (name, handler) ->\n    reg.registered arguments...\n  Object.defineProperty obj.registry, 'unregister', get: -> (name, handler) ->\n    reg.unregister arguments...\n    proxy\n  if obj.options.ssh\n    if obj.options.ssh.config\n      obj.store['nikita:ssh:connection'] = obj.options.ssh\n      delete obj.options.ssh\n    else\n      proxy.ssh.open obj.options.ssh if not obj.options.no_ssh\n  proxy\n\nmodule.exports.propagation =\n  ssh: true\n  log: true\n  stdout: true\n  stderr: true\n  debug: true\n  after: false\n  before: false\n  disabled: false\n  domain: false\n  handler: false\n  header: false\n  once: false\n  relax: false\n  shy: false\n  sleep: false\n  sudo: true",
            "title": "Nikita Context"
        },
        {
            "location": "/context.coffee/#helper-functions",
            "text": "todos_create = ->\n  todos = []\n  todos_reset todos\n  todos\ntodos_reset = (todos) ->\n  todos.err = null\n  todos.status = []\n  todos.throw_if_error = true\nhandle_get = (proxy, options) ->\n  return get: false unless options.length is 1\n  if options.length is options.filter( (opts) -> opts.get is true ).length\n    get = true\n    values = for opts in options\n      opts.handler.call proxy, opts, opts.callback\n    values = values[0] if values.length is 1\n  get: get, values: values",
            "title": "Helper functions"
        },
        {
            "location": "/context.coffee/#dependencies",
            "text": "registry = require './registry'\ndomain = require 'domain'\neach = require 'each'\npath = require 'path'\nutil = require 'util'\narray = require './misc/array'\npromise = require './misc/promise'\nconditions = require './misc/conditions'\nwrap = require './misc/wrap'\nstring = require './misc/string'\n{merge} = require './misc'\n{EventEmitter} = require 'events'",
            "title": "Dependencies"
        },
        {
            "location": "/index.coffee/",
            "text": "Nikita\n\n\nNikita gather a set of functions usually used during system deployment. All the\nfunctions share a common API with flexible options.\n\n\n\n\nRun actions both locally and remotely over SSH.\n\n\nAbility to see if an action had an effect through the second argument\n    provided in the callback.\n\n\nCommon API with options and callback arguments and calling the callback with\n    an error and the number of affected actions.\n\n\nRun one or multiple actions depending on option argument being an object or\n    an array of objects.\n\n\n\n\nSource Code\n\n\nmodule.exports = new Proxy (-> context arguments...),\n  get: (target, name) ->\n    return registry if name in ['registry']\n    ctx = context()\n    return undefined unless ctx[name]\n    return ctx[name] if name in ['propagation']\n    tree = []\n    tree.push name\n    builder = ->\n      a = ctx[tree.shift()]\n      return a unless typeof a is 'function'\n      while name = tree.shift()\n        a[name]\n      a.apply ctx, arguments\n    proxy = new Proxy builder,\n      get: (target, name) ->\n        tree.push name\n        if not registry.registered(tree, parent: true)\n          tree = []\n          return undefined\n        proxy\n    proxy\n\n\n\nDependencies\n\n\ncontext = require './context'\nregistry = require './registry'\n\n\n\nRegister\n\n\nregistry.register\n  assert: 'nikita/core/assert'\n  kv:\n    get: 'nikita/core/kv/get'\n    engine: 'nikita/core/kv/engine'\n    set: 'nikita/core/kv/set'\n  core:\n    ping: 'nikita/core/ping'\n  cron:\n    add: 'nikita/cron/add'\n    remove: 'nikita/cron/remove'\n  db:\n    database:\n      '': 'nikita/db/database'\n      exists: 'nikita/db/database/exists'\n      remove: 'nikita/db/database/remove'\n      wait: 'nikita/db/database/wait'\n    schema:\n      '': 'nikita/db/schema'\n      remove: 'nikita/db/schema/remove'\n    user:\n      '': 'nikita/db/user'\n      exists: 'nikita/db/user/exists'\n      remove: 'nikita/db/user/remove'\n  docker:\n    build: 'nikita/docker/build'\n    checksum: 'nikita/docker/checksum'\n    compose:\n      '': 'nikita/docker/compose'\n      up: 'nikita/docker/compose'\n    cp: 'nikita/docker/cp'\n    exec: 'nikita/docker/exec'\n    kill: 'nikita/docker/kill'\n    load: 'nikita/docker/load'\n    pause: 'nikita/docker/pause'\n    pull: 'nikita/docker/pull'\n    restart: 'nikita/docker/restart'\n    rm: 'nikita/docker/rm'\n    rmi: 'nikita/docker/rmi'\n    run: 'nikita/docker/run'\n    save: 'nikita/docker/save'\n    service: 'nikita/docker/service'\n    start: 'nikita/docker/start'\n    status: 'nikita/docker/status'\n    stop: 'nikita/docker/stop'\n    unpause: 'nikita/docker/unpause'\n    volume_create: 'nikita/docker/volume_create'\n    volume_rm: 'nikita/docker/volume_rm'\n    wait: 'nikita/docker/wait'\n  file:\n    '': 'nikita/file'\n    assert: 'nikita/file/assert'\n    cache: 'nikita/file/cache'\n    cson: 'nikita/file/cson'\n    download: 'nikita/file/download'\n    ini: 'nikita/file/ini'\n    json: 'nikita/file/json'\n    properties:\n      '': 'nikita/file/properties'\n      'read': 'nikita/file/properties/read'\n    render: 'nikita/file/render'\n    touch: 'nikita/file/touch'\n    upload: 'nikita/file/upload'\n    yaml: 'nikita/file/yaml'\n    types:\n      ceph_conf: 'nikita/file/types/ceph_conf'\n      etc_group:\n        'read': 'nikita/file/types/etc_group/read'\n      etc_passwd:\n        'read': 'nikita/file/types/etc_passwd/read'\n      locale_gen: 'nikita/file/types/locale_gen'\n      pacman_conf: 'nikita/file/types/pacman_conf'\n      ssh_authorized_keys: 'nikita/file/types/ssh_authorized_keys'\n      yum_repo: 'nikita/file/types/yum_repo'\n  fs:\n    chmod: 'nikita/fs/chmod'\n    chown: 'nikita/fs/chown'\n    copy: 'nikita/fs/copy'\n    createReadStream: 'nikita/fs/createReadStream'\n    exists: 'nikita/fs/exists'\n    lstat: 'nikita/fs/lstat'\n    mkdir: 'nikita/fs/mkdir'\n    rmdir: 'nikita/fs/rmdir'\n    readFile: 'nikita/fs/readFile'\n    readlink: 'nikita/fs/readlink'\n    rename: 'nikita/fs/rename'\n    stat: 'nikita/fs/stat'\n    symlink: 'nikita/fs/symlink'\n    unlink: 'nikita/fs/unlink'\n    writeFile: 'nikita/fs/writeFile'\n  java:\n    keystore_add: 'nikita/java/keystore_add'\n    keystore_remove: 'nikita/java/keystore_remove'\n  krb5:\n    addprinc: 'nikita/krb5/addprinc'\n    delprinc: 'nikita/krb5/delprinc'\n    ktadd: 'nikita/krb5/ktadd'\n    ticket: 'nikita/krb5/ticket'\n    ktutil:\n      add: 'nikita/krb5/ktutil/add'\n  ldap:\n    acl: 'nikita/ldap/acl'\n    add: 'nikita/ldap/add'\n    delete: 'nikita/ldap/delete'\n    index: 'nikita/ldap/index'\n    schema: 'nikita/ldap/schema'\n    user: 'nikita/ldap/user'\n  log:\n    cli: 'nikita/log/cli'\n    fs: 'nikita/log/fs'\n    md: 'nikita/log/md'\n    csv: 'nikita/log/csv'\n  connection:\n    assert: 'nikita/connection/assert'\n    wait: '': 'nikita/connection/wait'\n  service:\n    '': 'nikita/service'\n    assert: 'nikita/service/assert'\n    discover: 'nikita/service/discover'\n    install: 'nikita/service/install'\n    init: 'nikita/service/init'\n    remove: 'nikita/service/remove'\n    restart: 'nikita/service/restart'\n    start: 'nikita/service/start'\n    startup: 'nikita/service/startup'\n    status: 'nikita/service/status'\n    stop: 'nikita/service/stop'\n  system:\n    cgroups: 'nikita/system/cgroups'\n    chmod: 'nikita/system/chmod'\n    chown: 'nikita/system/chown'\n    copy: 'nikita/system/copy'\n    discover: 'nikita/system/discover'\n    execute:\n      '': 'nikita/system/execute'\n      'assert': 'nikita/system/execute/assert'\n    group:\n      '': 'nikita/system/group/index'\n      remove: 'nikita/system/group/remove'\n    limits: 'nikita/system/limits'\n    link: 'nikita/system/link'\n    mkdir: 'nikita/system/mkdir'\n    mod: 'nikita/system/mod'\n    move: 'nikita/system/move'\n    remove: 'nikita/system/remove'\n    tmpfs: 'nikita/system/tmpfs'\n    uid_gid: 'nikita/system/uid_gid'\n    user:\n      '': 'nikita/system/user/index'\n      remove: 'nikita/system/user/remove'\n  ssh:\n    '': 'nikita/ssh'\n    open: 'nikita/ssh/open'\n    close: 'nikita/ssh/close'\n    root: 'nikita/ssh/root'\n  tools:\n    backup: 'nikita/tools/backup'\n    compress: 'nikita/tools/compress'\n    extract: 'nikita/tools/extract'\n    rubygems:\n      'fetch': 'nikita/tools/rubygems/fetch'\n      'install': 'nikita/tools/rubygems/install'\n      'remove': 'nikita/tools/rubygems/remove'\n    iptables: 'nikita/tools/iptables'\n    git: 'nikita/tools/git'\n    repo: 'nikita/tools/repo'\n    sysctl: 'nikita/tools/sysctl'\n  wait:\n    '': 'nikita/wait'\n    execute: 'nikita/wait/execute'\n    exist: 'nikita/wait/exist'\n\n# Backward compatibility\nregistry.deprecate 'backup', 'nikita/tools/backup'\nregistry.deprecate 'cgroups', 'nikita/system/cgroups'\nregistry.deprecate 'chmod', 'nikita/system/chmod'\nregistry.deprecate 'chown', 'nikita/system/chown'\nregistry.deprecate 'compress', 'nikita/tools/compress'\nregistry.deprecate 'copy', 'nikita/system/copy'\nregistry.deprecate 'cron_add', 'nikita/cron/add'\nregistry.deprecate 'cron_remove', 'nikita/cron/remove'\nregistry.deprecate 'docker_build', 'nikita/docker/build'\nregistry.deprecate 'docker_checksum', 'nikita/docker/checksum'\nregistry.deprecate 'docker_cp', 'nikita/docker/cp'\nregistry.deprecate 'docker_exec', 'nikita/docker/exec'\nregistry.deprecate 'docker_kill', 'nikita/docker/kill'\nregistry.deprecate 'docker_load', 'nikita/docker/load'\nregistry.deprecate 'docker_pause', 'nikita/docker/pause'\nregistry.deprecate 'docker_restart', 'nikita/docker/restart'\nregistry.deprecate 'docker_rm', 'nikita/docker/rm'\nregistry.deprecate 'docker_rmi', 'nikita/docker/rmi'\nregistry.deprecate 'docker_run', 'nikita/docker/run'\nregistry.deprecate 'docker_save', 'nikita/docker/save'\nregistry.deprecate 'docker_service', 'nikita/docker/service'\nregistry.deprecate 'docker_start', 'nikita/docker/start'\nregistry.deprecate 'docker_status', 'nikita/docker/status'\nregistry.deprecate 'docker_stop', 'nikita/docker/stop'\nregistry.deprecate 'docker_unpause', 'nikita/docker/unpause'\nregistry.deprecate 'docker_volume_create', 'nikita/docker/volume_create'\nregistry.deprecate 'docker_volume_rm', 'nikita/docker/volume_rm'\nregistry.deprecate 'docker_wait', 'nikita/docker/wait'\nregistry.deprecate 'download', 'nikita/file/download'\nregistry.deprecate 'execute', 'nikita/system/execute'\nregistry.deprecate 'extract', 'nikita/tools/extract'\nregistry.deprecate 'cache', 'nikita/file/cache'\nregistry.deprecate 'git', 'nikita/tools/git'\nregistry.deprecate 'group', 'nikita/system/group'\nregistry.deprecate 'java_keystore_add', 'nikita/java/keystore_add'\nregistry.deprecate 'java_keystore_remove', 'nikita/java/keystore_remove'\nregistry.deprecate 'iptables', 'nikita/tools/iptables'\nregistry.deprecate 'krb5_addprinc', 'nikita/krb5/addprinc'\nregistry.deprecate 'krb5_delprinc', 'nikita/krb5/delprinc'\nregistry.deprecate 'krb5_ktadd', 'nikita/krb5/ktadd'\nregistry.deprecate 'ldap_acl', 'nikita/ldap/acl'\nregistry.deprecate 'ldap_add', 'nikita/ldap/add'\nregistry.deprecate 'ldap_delete', 'nikita/ldap/delete'\nregistry.deprecate 'ldap_index', 'nikita/ldap/index'\nregistry.deprecate 'ldap_schema', 'nikita/ldap/schema'\nregistry.deprecate 'ldap_user', 'nikita/ldap/user'\nregistry.deprecate 'link', 'nikita/system/link'\nregistry.deprecate 'mkdir', 'nikita/system/mkdir'\nregistry.deprecate 'move', 'nikita/system/move'\nregistry.deprecate 'remove', 'nikita/system/remove'\nregistry.deprecate 'render', 'nikita/file/render'\nregistry.deprecate 'service_install', 'nikita/service/install'\nregistry.deprecate 'service_remove', 'nikita/service/remove'\nregistry.deprecate 'service_restart', 'nikita/service/restart'\nregistry.deprecate 'service_start', 'nikita/service/start'\nregistry.deprecate 'service_startup', 'nikita/service/startup'\nregistry.deprecate 'service_status', 'nikita/service/status'\nregistry.deprecate 'service_stop', 'nikita/service/stop'\nregistry.deprecate 'system_limits', 'nikita/system/limits'\nregistry.deprecate 'touch', 'nikita/file/touch'\nregistry.deprecate 'upload', 'nikita/file/upload'\nregistry.deprecate 'user', 'nikita/system/user'\nregistry.deprecate 'wait_connect', 'nikita/connection/wait'\nregistry.deprecate 'wait_execute', 'nikita/wait/execute'\nregistry.deprecate 'wait_exist', 'nikita/wait/exist'\nregistry.deprecate 'write', 'nikita/file'\nregistry.deprecate 'write_ini', 'nikita/file/ini'\nregistry.deprecate 'write_properties', 'nikita/file/properties'\nregistry.deprecate 'write_yaml', 'nikita/file/yaml'",
            "title": "Index.coffee"
        },
        {
            "location": "/index.coffee/#nikita",
            "text": "Nikita gather a set of functions usually used during system deployment. All the\nfunctions share a common API with flexible options.   Run actions both locally and remotely over SSH.  Ability to see if an action had an effect through the second argument\n    provided in the callback.  Common API with options and callback arguments and calling the callback with\n    an error and the number of affected actions.  Run one or multiple actions depending on option argument being an object or\n    an array of objects.",
            "title": "Nikita"
        },
        {
            "location": "/index.coffee/#source-code",
            "text": "module.exports = new Proxy (-> context arguments...),\n  get: (target, name) ->\n    return registry if name in ['registry']\n    ctx = context()\n    return undefined unless ctx[name]\n    return ctx[name] if name in ['propagation']\n    tree = []\n    tree.push name\n    builder = ->\n      a = ctx[tree.shift()]\n      return a unless typeof a is 'function'\n      while name = tree.shift()\n        a[name]\n      a.apply ctx, arguments\n    proxy = new Proxy builder,\n      get: (target, name) ->\n        tree.push name\n        if not registry.registered(tree, parent: true)\n          tree = []\n          return undefined\n        proxy\n    proxy",
            "title": "Source Code"
        },
        {
            "location": "/index.coffee/#dependencies",
            "text": "context = require './context'\nregistry = require './registry'",
            "title": "Dependencies"
        },
        {
            "location": "/index.coffee/#register",
            "text": "registry.register\n  assert: 'nikita/core/assert'\n  kv:\n    get: 'nikita/core/kv/get'\n    engine: 'nikita/core/kv/engine'\n    set: 'nikita/core/kv/set'\n  core:\n    ping: 'nikita/core/ping'\n  cron:\n    add: 'nikita/cron/add'\n    remove: 'nikita/cron/remove'\n  db:\n    database:\n      '': 'nikita/db/database'\n      exists: 'nikita/db/database/exists'\n      remove: 'nikita/db/database/remove'\n      wait: 'nikita/db/database/wait'\n    schema:\n      '': 'nikita/db/schema'\n      remove: 'nikita/db/schema/remove'\n    user:\n      '': 'nikita/db/user'\n      exists: 'nikita/db/user/exists'\n      remove: 'nikita/db/user/remove'\n  docker:\n    build: 'nikita/docker/build'\n    checksum: 'nikita/docker/checksum'\n    compose:\n      '': 'nikita/docker/compose'\n      up: 'nikita/docker/compose'\n    cp: 'nikita/docker/cp'\n    exec: 'nikita/docker/exec'\n    kill: 'nikita/docker/kill'\n    load: 'nikita/docker/load'\n    pause: 'nikita/docker/pause'\n    pull: 'nikita/docker/pull'\n    restart: 'nikita/docker/restart'\n    rm: 'nikita/docker/rm'\n    rmi: 'nikita/docker/rmi'\n    run: 'nikita/docker/run'\n    save: 'nikita/docker/save'\n    service: 'nikita/docker/service'\n    start: 'nikita/docker/start'\n    status: 'nikita/docker/status'\n    stop: 'nikita/docker/stop'\n    unpause: 'nikita/docker/unpause'\n    volume_create: 'nikita/docker/volume_create'\n    volume_rm: 'nikita/docker/volume_rm'\n    wait: 'nikita/docker/wait'\n  file:\n    '': 'nikita/file'\n    assert: 'nikita/file/assert'\n    cache: 'nikita/file/cache'\n    cson: 'nikita/file/cson'\n    download: 'nikita/file/download'\n    ini: 'nikita/file/ini'\n    json: 'nikita/file/json'\n    properties:\n      '': 'nikita/file/properties'\n      'read': 'nikita/file/properties/read'\n    render: 'nikita/file/render'\n    touch: 'nikita/file/touch'\n    upload: 'nikita/file/upload'\n    yaml: 'nikita/file/yaml'\n    types:\n      ceph_conf: 'nikita/file/types/ceph_conf'\n      etc_group:\n        'read': 'nikita/file/types/etc_group/read'\n      etc_passwd:\n        'read': 'nikita/file/types/etc_passwd/read'\n      locale_gen: 'nikita/file/types/locale_gen'\n      pacman_conf: 'nikita/file/types/pacman_conf'\n      ssh_authorized_keys: 'nikita/file/types/ssh_authorized_keys'\n      yum_repo: 'nikita/file/types/yum_repo'\n  fs:\n    chmod: 'nikita/fs/chmod'\n    chown: 'nikita/fs/chown'\n    copy: 'nikita/fs/copy'\n    createReadStream: 'nikita/fs/createReadStream'\n    exists: 'nikita/fs/exists'\n    lstat: 'nikita/fs/lstat'\n    mkdir: 'nikita/fs/mkdir'\n    rmdir: 'nikita/fs/rmdir'\n    readFile: 'nikita/fs/readFile'\n    readlink: 'nikita/fs/readlink'\n    rename: 'nikita/fs/rename'\n    stat: 'nikita/fs/stat'\n    symlink: 'nikita/fs/symlink'\n    unlink: 'nikita/fs/unlink'\n    writeFile: 'nikita/fs/writeFile'\n  java:\n    keystore_add: 'nikita/java/keystore_add'\n    keystore_remove: 'nikita/java/keystore_remove'\n  krb5:\n    addprinc: 'nikita/krb5/addprinc'\n    delprinc: 'nikita/krb5/delprinc'\n    ktadd: 'nikita/krb5/ktadd'\n    ticket: 'nikita/krb5/ticket'\n    ktutil:\n      add: 'nikita/krb5/ktutil/add'\n  ldap:\n    acl: 'nikita/ldap/acl'\n    add: 'nikita/ldap/add'\n    delete: 'nikita/ldap/delete'\n    index: 'nikita/ldap/index'\n    schema: 'nikita/ldap/schema'\n    user: 'nikita/ldap/user'\n  log:\n    cli: 'nikita/log/cli'\n    fs: 'nikita/log/fs'\n    md: 'nikita/log/md'\n    csv: 'nikita/log/csv'\n  connection:\n    assert: 'nikita/connection/assert'\n    wait: '': 'nikita/connection/wait'\n  service:\n    '': 'nikita/service'\n    assert: 'nikita/service/assert'\n    discover: 'nikita/service/discover'\n    install: 'nikita/service/install'\n    init: 'nikita/service/init'\n    remove: 'nikita/service/remove'\n    restart: 'nikita/service/restart'\n    start: 'nikita/service/start'\n    startup: 'nikita/service/startup'\n    status: 'nikita/service/status'\n    stop: 'nikita/service/stop'\n  system:\n    cgroups: 'nikita/system/cgroups'\n    chmod: 'nikita/system/chmod'\n    chown: 'nikita/system/chown'\n    copy: 'nikita/system/copy'\n    discover: 'nikita/system/discover'\n    execute:\n      '': 'nikita/system/execute'\n      'assert': 'nikita/system/execute/assert'\n    group:\n      '': 'nikita/system/group/index'\n      remove: 'nikita/system/group/remove'\n    limits: 'nikita/system/limits'\n    link: 'nikita/system/link'\n    mkdir: 'nikita/system/mkdir'\n    mod: 'nikita/system/mod'\n    move: 'nikita/system/move'\n    remove: 'nikita/system/remove'\n    tmpfs: 'nikita/system/tmpfs'\n    uid_gid: 'nikita/system/uid_gid'\n    user:\n      '': 'nikita/system/user/index'\n      remove: 'nikita/system/user/remove'\n  ssh:\n    '': 'nikita/ssh'\n    open: 'nikita/ssh/open'\n    close: 'nikita/ssh/close'\n    root: 'nikita/ssh/root'\n  tools:\n    backup: 'nikita/tools/backup'\n    compress: 'nikita/tools/compress'\n    extract: 'nikita/tools/extract'\n    rubygems:\n      'fetch': 'nikita/tools/rubygems/fetch'\n      'install': 'nikita/tools/rubygems/install'\n      'remove': 'nikita/tools/rubygems/remove'\n    iptables: 'nikita/tools/iptables'\n    git: 'nikita/tools/git'\n    repo: 'nikita/tools/repo'\n    sysctl: 'nikita/tools/sysctl'\n  wait:\n    '': 'nikita/wait'\n    execute: 'nikita/wait/execute'\n    exist: 'nikita/wait/exist'\n\n# Backward compatibility\nregistry.deprecate 'backup', 'nikita/tools/backup'\nregistry.deprecate 'cgroups', 'nikita/system/cgroups'\nregistry.deprecate 'chmod', 'nikita/system/chmod'\nregistry.deprecate 'chown', 'nikita/system/chown'\nregistry.deprecate 'compress', 'nikita/tools/compress'\nregistry.deprecate 'copy', 'nikita/system/copy'\nregistry.deprecate 'cron_add', 'nikita/cron/add'\nregistry.deprecate 'cron_remove', 'nikita/cron/remove'\nregistry.deprecate 'docker_build', 'nikita/docker/build'\nregistry.deprecate 'docker_checksum', 'nikita/docker/checksum'\nregistry.deprecate 'docker_cp', 'nikita/docker/cp'\nregistry.deprecate 'docker_exec', 'nikita/docker/exec'\nregistry.deprecate 'docker_kill', 'nikita/docker/kill'\nregistry.deprecate 'docker_load', 'nikita/docker/load'\nregistry.deprecate 'docker_pause', 'nikita/docker/pause'\nregistry.deprecate 'docker_restart', 'nikita/docker/restart'\nregistry.deprecate 'docker_rm', 'nikita/docker/rm'\nregistry.deprecate 'docker_rmi', 'nikita/docker/rmi'\nregistry.deprecate 'docker_run', 'nikita/docker/run'\nregistry.deprecate 'docker_save', 'nikita/docker/save'\nregistry.deprecate 'docker_service', 'nikita/docker/service'\nregistry.deprecate 'docker_start', 'nikita/docker/start'\nregistry.deprecate 'docker_status', 'nikita/docker/status'\nregistry.deprecate 'docker_stop', 'nikita/docker/stop'\nregistry.deprecate 'docker_unpause', 'nikita/docker/unpause'\nregistry.deprecate 'docker_volume_create', 'nikita/docker/volume_create'\nregistry.deprecate 'docker_volume_rm', 'nikita/docker/volume_rm'\nregistry.deprecate 'docker_wait', 'nikita/docker/wait'\nregistry.deprecate 'download', 'nikita/file/download'\nregistry.deprecate 'execute', 'nikita/system/execute'\nregistry.deprecate 'extract', 'nikita/tools/extract'\nregistry.deprecate 'cache', 'nikita/file/cache'\nregistry.deprecate 'git', 'nikita/tools/git'\nregistry.deprecate 'group', 'nikita/system/group'\nregistry.deprecate 'java_keystore_add', 'nikita/java/keystore_add'\nregistry.deprecate 'java_keystore_remove', 'nikita/java/keystore_remove'\nregistry.deprecate 'iptables', 'nikita/tools/iptables'\nregistry.deprecate 'krb5_addprinc', 'nikita/krb5/addprinc'\nregistry.deprecate 'krb5_delprinc', 'nikita/krb5/delprinc'\nregistry.deprecate 'krb5_ktadd', 'nikita/krb5/ktadd'\nregistry.deprecate 'ldap_acl', 'nikita/ldap/acl'\nregistry.deprecate 'ldap_add', 'nikita/ldap/add'\nregistry.deprecate 'ldap_delete', 'nikita/ldap/delete'\nregistry.deprecate 'ldap_index', 'nikita/ldap/index'\nregistry.deprecate 'ldap_schema', 'nikita/ldap/schema'\nregistry.deprecate 'ldap_user', 'nikita/ldap/user'\nregistry.deprecate 'link', 'nikita/system/link'\nregistry.deprecate 'mkdir', 'nikita/system/mkdir'\nregistry.deprecate 'move', 'nikita/system/move'\nregistry.deprecate 'remove', 'nikita/system/remove'\nregistry.deprecate 'render', 'nikita/file/render'\nregistry.deprecate 'service_install', 'nikita/service/install'\nregistry.deprecate 'service_remove', 'nikita/service/remove'\nregistry.deprecate 'service_restart', 'nikita/service/restart'\nregistry.deprecate 'service_start', 'nikita/service/start'\nregistry.deprecate 'service_startup', 'nikita/service/startup'\nregistry.deprecate 'service_status', 'nikita/service/status'\nregistry.deprecate 'service_stop', 'nikita/service/stop'\nregistry.deprecate 'system_limits', 'nikita/system/limits'\nregistry.deprecate 'touch', 'nikita/file/touch'\nregistry.deprecate 'upload', 'nikita/file/upload'\nregistry.deprecate 'user', 'nikita/system/user'\nregistry.deprecate 'wait_connect', 'nikita/connection/wait'\nregistry.deprecate 'wait_execute', 'nikita/wait/execute'\nregistry.deprecate 'wait_exist', 'nikita/wait/exist'\nregistry.deprecate 'write', 'nikita/file'\nregistry.deprecate 'write_ini', 'nikita/file/ini'\nregistry.deprecate 'write_properties', 'nikita/file/properties'\nregistry.deprecate 'write_yaml', 'nikita/file/yaml'",
            "title": "Register"
        },
        {
            "location": "/registry.coffee/",
            "text": "Register all functions\n\n\nload = (middleware) ->\n  middleware = handler: middleware unless typeof middleware is 'object' and middleware? and not Array.isArray middleware\n  throw Error \"Invalid middleware handler: got #{JSON.stringify middleware.handler}\" unless typeof middleware.handler in ['function', 'string']\n  return middleware unless typeof middleware.handler is 'string'\n  middleware.module = middleware.handler\n  middleware.handler = if /^nikita\\//.test(middleware.handler) then require(\".#{middleware.handler.substr(6)}\") else require.main.require middleware.handler\n  middleware\n\nregistry = (obj) ->\n\n\n\nGet\n\n\nRetrieve an action by name.\n\n\nOptions include: flatten, deprecate\n\n\n  Object.defineProperty obj, 'get',\n    configurable: true\n    enumerable: false\n    get: -> (name, options) ->\n      if arguments.length is 1 and is_object arguments[0]\n        options = name\n        name = null\n      options ?= {}\n      unless name\n        # Flatten result\n        if options.flatten\n          flatobj = {}\n          walk = (obj, keys) ->\n            for k, v of obj\n              if k is ''\n                continue if v.deprecate and not options.deprecate\n                flatobj[keys.join '.'] = merge {}, v\n              else\n                walk v, [keys..., k]\n          walk obj, []\n          return flatobj\n        # Tree result\n        else\n          walk = (obj, keys) ->\n            res = {}\n            for k, v of obj\n              if k is ''\n                continue if v.deprecate and not options.deprecate\n                res[k] = merge {}, v\n              else\n                v = walk v, [keys..., k]\n                res[k] = v unless Object.values(v).length is 0\n            res\n          return walk obj, []\n        # return merge {}, obj if arguments.length is 0\n      name = [name] if typeof name is 'string'\n      cnames = obj\n      for n, i in name\n        return null unless cnames[n]\n        return cnames[n][''] if cnames[n] and cnames[n][''] and i is name.length - 1\n        cnames = cnames[n]\n      return null\n\n\n\nRegister\n\n\nRegister new actions.\n\n\nWith an action path:\n\n\nnikita.register('first_action', 'path/to/action')\nnikita.first_action(options);\n\n\n\n\nWith a namespace and an action path:\n\n\nnikita.register(['second', 'action'], 'path/to/action')\nnikita.second.action(options);\n\n\n\n\nWith an action object:\n\n\nnikita.register('third_action', {\n  relax: true,\n  handler: function(options){ console.log(options.relax) }\n})\nnikita.third_action(options);\n\n\n\n\nWith a namespace and an action object:\n\n\nnikita.register(['fourth', 'action'], {\n  relax: true,\n  handler: function(options){ console.log(options.relax) }\n})\nnikita.fourth.action(options);\n\n\n\n\nMultiple actions:\n\n\nnikita.register({\n  'fifth_action': 'path/to/action'\n  'sixth': {\n    '': 'path/to/sixth',\n    'action': : 'path/to/sixth/actkon'\n  }\n})\nnikita\n.fifth_action(options);\n.sixth(options);\n.sixth.action(options);\n\n\n\n\n  Object.defineProperty obj, 'register',\n    configurable: true\n    enumerable: false\n    get: -> (name, handler) ->\n      name = [name] if typeof name is 'string'\n      if Array.isArray name\n        handler = load handler\n        cnames = names = obj\n        for n in [0...name.length - 1]\n          n = name[n]\n          cnames[n] ?= {}\n          cnames = cnames[n]\n        cnames[name[name.length-1]] ?= {}\n        cnames[name[name.length-1]][''] = handler\n        merge obj, names\n      else\n        walk = (obj) ->\n          for k, v of obj\n            if k isnt '' and v and typeof v is 'object' and not Array.isArray(v) and not v.handler\n              walk v\n            else\n              v = load v\n              obj[k] = if k is '' then v else '': v\n        walk name\n        merge obj, name\n\n\n\nDeprecate\n\n\nnikita.deprecate(old_function, [new_function], action)\n\n\nDeprecate an old or renamed action. Internally, it leverages \n\nNode.js \nutil.deprecate\n.\n\n\nFor example:\n\n\nnikita.deprecate('old_function', 'new_function', -> 'my_function')\nnikita.new_function()\n# Print\n# (node:75923) DeprecationWarning: old_function is deprecated, use new_function\n\n\n\n\n  Object.defineProperty obj, 'deprecate',\n    configurable: true\n    enumerable: false\n    get: -> (old_name, new_name, handler) ->\n      if arguments.length is 2\n        handler = new_name\n        new_name = null\n      handler = load handler\n      handler.deprecate = new_name\n      handler.deprecate ?= handler.module if typeof handler.module is 'string'\n      handler.deprecate ?= true\n      obj.register old_name, handler\n\n\n\nRegistered\n\n\nTest if a function is registered or not.\n\n\nOptions:\n\n\n\n\n\n\nparent\n (boolean) \n\n  Return true if the name match an parent action name.\n\n\nObject.defineProperty obj, 'registered',\n    configurable: true\n    enumerable: false\n    get: -> (name, options = {}) ->\n      return true if module.exports isnt obj and module.exports.registered name\n      name = [name] if typeof name is 'string'\n      cnames = obj\n      for n, i in name\n        return false if not cnames[n]? or not cnames.propertyIsEnumerable(n)\n        return true if options.parent and cnames[n] and i is name.length - 1\n        return true if cnames[n][''] and i is name.length - 1\n        cnames = cnames[n]\n      return false\n\n\n\n\n\n\nUnregister\n\n\nRemove an action from registry.\n\n\n  Object.defineProperty obj, 'unregister',\n    configurable: true\n    enumerable: false\n    get: -> (name) ->\n      name = [name] if typeof name is 'string'\n      cnames = obj\n      for n, i in name\n        delete cnames[n] if i is name.length - 1\n        cnames = cnames[n]\n        return unless cnames\n\nregistry module.exports\n\nObject.defineProperty module.exports, 'registry',\n  configurable: true\n  enumerable: false\n  get: -> registry\n\n\n\nDependencies\n\n\n{merge} = require './misc'\n{is_object} = require './misc/object'",
            "title": "Registry.coffee"
        },
        {
            "location": "/registry.coffee/#register-all-functions",
            "text": "load = (middleware) ->\n  middleware = handler: middleware unless typeof middleware is 'object' and middleware? and not Array.isArray middleware\n  throw Error \"Invalid middleware handler: got #{JSON.stringify middleware.handler}\" unless typeof middleware.handler in ['function', 'string']\n  return middleware unless typeof middleware.handler is 'string'\n  middleware.module = middleware.handler\n  middleware.handler = if /^nikita\\//.test(middleware.handler) then require(\".#{middleware.handler.substr(6)}\") else require.main.require middleware.handler\n  middleware\n\nregistry = (obj) ->",
            "title": "Register all functions"
        },
        {
            "location": "/registry.coffee/#get",
            "text": "Retrieve an action by name.  Options include: flatten, deprecate    Object.defineProperty obj, 'get',\n    configurable: true\n    enumerable: false\n    get: -> (name, options) ->\n      if arguments.length is 1 and is_object arguments[0]\n        options = name\n        name = null\n      options ?= {}\n      unless name\n        # Flatten result\n        if options.flatten\n          flatobj = {}\n          walk = (obj, keys) ->\n            for k, v of obj\n              if k is ''\n                continue if v.deprecate and not options.deprecate\n                flatobj[keys.join '.'] = merge {}, v\n              else\n                walk v, [keys..., k]\n          walk obj, []\n          return flatobj\n        # Tree result\n        else\n          walk = (obj, keys) ->\n            res = {}\n            for k, v of obj\n              if k is ''\n                continue if v.deprecate and not options.deprecate\n                res[k] = merge {}, v\n              else\n                v = walk v, [keys..., k]\n                res[k] = v unless Object.values(v).length is 0\n            res\n          return walk obj, []\n        # return merge {}, obj if arguments.length is 0\n      name = [name] if typeof name is 'string'\n      cnames = obj\n      for n, i in name\n        return null unless cnames[n]\n        return cnames[n][''] if cnames[n] and cnames[n][''] and i is name.length - 1\n        cnames = cnames[n]\n      return null",
            "title": "Get"
        },
        {
            "location": "/registry.coffee/#register",
            "text": "Register new actions.  With an action path:  nikita.register('first_action', 'path/to/action')\nnikita.first_action(options);  With a namespace and an action path:  nikita.register(['second', 'action'], 'path/to/action')\nnikita.second.action(options);  With an action object:  nikita.register('third_action', {\n  relax: true,\n  handler: function(options){ console.log(options.relax) }\n})\nnikita.third_action(options);  With a namespace and an action object:  nikita.register(['fourth', 'action'], {\n  relax: true,\n  handler: function(options){ console.log(options.relax) }\n})\nnikita.fourth.action(options);  Multiple actions:  nikita.register({\n  'fifth_action': 'path/to/action'\n  'sixth': {\n    '': 'path/to/sixth',\n    'action': : 'path/to/sixth/actkon'\n  }\n})\nnikita\n.fifth_action(options);\n.sixth(options);\n.sixth.action(options);    Object.defineProperty obj, 'register',\n    configurable: true\n    enumerable: false\n    get: -> (name, handler) ->\n      name = [name] if typeof name is 'string'\n      if Array.isArray name\n        handler = load handler\n        cnames = names = obj\n        for n in [0...name.length - 1]\n          n = name[n]\n          cnames[n] ?= {}\n          cnames = cnames[n]\n        cnames[name[name.length-1]] ?= {}\n        cnames[name[name.length-1]][''] = handler\n        merge obj, names\n      else\n        walk = (obj) ->\n          for k, v of obj\n            if k isnt '' and v and typeof v is 'object' and not Array.isArray(v) and not v.handler\n              walk v\n            else\n              v = load v\n              obj[k] = if k is '' then v else '': v\n        walk name\n        merge obj, name",
            "title": "Register"
        },
        {
            "location": "/registry.coffee/#deprecate",
            "text": "nikita.deprecate(old_function, [new_function], action)  Deprecate an old or renamed action. Internally, it leverages  Node.js  util.deprecate .  For example:  nikita.deprecate('old_function', 'new_function', -> 'my_function')\nnikita.new_function()\n# Print\n# (node:75923) DeprecationWarning: old_function is deprecated, use new_function    Object.defineProperty obj, 'deprecate',\n    configurable: true\n    enumerable: false\n    get: -> (old_name, new_name, handler) ->\n      if arguments.length is 2\n        handler = new_name\n        new_name = null\n      handler = load handler\n      handler.deprecate = new_name\n      handler.deprecate ?= handler.module if typeof handler.module is 'string'\n      handler.deprecate ?= true\n      obj.register old_name, handler",
            "title": "Deprecate"
        },
        {
            "location": "/registry.coffee/#registered",
            "text": "Test if a function is registered or not.  Options:    parent  (boolean)  \n  Return true if the name match an parent action name.  Object.defineProperty obj, 'registered',\n    configurable: true\n    enumerable: false\n    get: -> (name, options = {}) ->\n      return true if module.exports isnt obj and module.exports.registered name\n      name = [name] if typeof name is 'string'\n      cnames = obj\n      for n, i in name\n        return false if not cnames[n]? or not cnames.propertyIsEnumerable(n)\n        return true if options.parent and cnames[n] and i is name.length - 1\n        return true if cnames[n][''] and i is name.length - 1\n        cnames = cnames[n]\n      return false",
            "title": "Registered"
        },
        {
            "location": "/registry.coffee/#unregister",
            "text": "Remove an action from registry.    Object.defineProperty obj, 'unregister',\n    configurable: true\n    enumerable: false\n    get: -> (name) ->\n      name = [name] if typeof name is 'string'\n      cnames = obj\n      for n, i in name\n        delete cnames[n] if i is name.length - 1\n        cnames = cnames[n]\n        return unless cnames\n\nregistry module.exports\n\nObject.defineProperty module.exports, 'registry',\n  configurable: true\n  enumerable: false\n  get: -> registry",
            "title": "Unregister"
        },
        {
            "location": "/registry.coffee/#dependencies",
            "text": "{merge} = require './misc'\n{is_object} = require './misc/object'",
            "title": "Dependencies"
        },
        {
            "location": "/alt/ldap_acl.coffee/",
            "text": "nikita.ldap.acl(options, [goptions], callback)\n\n\nCreate new \nACLs\n for the OpenLDAP server.   \n\n\nThis implementation currently doesn't execute remote SSH commands. Instead, it\nconnects directly to the LDAP database and thus requires a specific port to be\naccessible.   \n\n\nOptions\n\n\n\n\nto\n \n\n    What to control access to as a string.   \n\n\nby\n \n\n    Who to grant access to and the access to grant as an array\n    (eg: \n{..., by:[\"ssf=64 anonymous auth\"]}\n).   \n\n\nurl\n \n\n    Specify URI referring to the ldap server, alternative to providing an\n    [ldapjs client] instance.   \n\n\nbinddn\n \n\n    Distinguished Name to bind to the LDAP directory, alternative to providing\n    an [ldapjs client] instance.   \n\n\npasswd\n \n\n    Password for simple authentication, alternative to providing an\n    [ldapjs client] instance.   \n\n\nldap\n \n\n    Instance of an \nldapjs client\n, alternative to providing the \nurl\n,\n    \nbinddn\n and \npasswd\n connection properties.   \n\n\nunbind\n \n\n    Close the ldap connection, default to false if connection is an\n    \nldapjs client\n instance.   \n\n\nname\n \n\n    Distinguish name storing the \"olcAccess\" property, using the database adress\n    (eg: \"olcDatabase={2}bdb,cn=config\").   \n\n\noverwrite\n \n\n    Overwrite existing \"olcAccess\", default is to merge.   \n\n\nlog\n \n\n    Function called with a log related messages.   \n\n\nacl\n \n\n    In case of multiple acls, regroup \"before\", \"to\" and \"by\" as an array.   \n\n\n\n\nExample\n\n\nrequire('nikita/alt/ldap.acl')({\n  url: 'ldap://openldap.server/',\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  name: 'olcDatabase={2}bdb,cn=config',\n  acls: [{\n    before: 'dn.subtree=\"dc=domain,dc=com\"',\n    to: 'dn.subtree=\"ou=users,dc=domain,dc=com\"',\n    by: [\n      'dn.exact=\"ou=users,dc=domain,dc=com\" write',\n      \"dn.base='gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth' read\",\n      \"* none\"\n    ]\n  },{\n    to: 'dn.subtree=\"dc=domain,dc=com\"',\n    by: [\n      'dn.exact=\"ou=kerberos,dc=domain,dc=com\" write'\n    ]\n  }]\n}, function(err, modified){\n  console.log(err ? err.message : \"ACL modified: \" + !!modified);\n});\n\n\n\n\nmodule.exports = (goptions, options, callback) ->\n  options.acls ?= [{}]\n  updated = false\n  each(options.acls)\n  .call (acl, next) ->\n    acl.before ?= options.before\n    acl.to ?= options.to\n    acl.by ?= options.by\n    client = null\n    acl.to = acl.to.trim()\n    for b, i in acl.by\n      acl.by[i] = b.trim()\n    connect = ->\n      # if options.ldap instanceof ldap.client\n      if options.ldap?.url?.protocol?.indexOf('ldap') is 0\n        client = options.ldap\n        return search()\n      options.log? 'Open and bind connection'\n      client = ldap.createClient url: options.url\n      client.bind options.binddn, options.passwd, (err) ->\n        return end err if err\n        search()\n    search = ->\n        options.log? 'Search attribute olcAccess'\n        client.search options.name,\n          scope: 'base'\n          attributes: ['olcAccess']\n        , (err, search) ->\n          return unbind err if err\n          olcAccess = null\n          search.on 'searchEntry', (entry) ->\n            options.log? \"Found #{JSON.stringify entry.object}\"\n            # typeof olcAccess may be undefined, array or string\n            olcAccess = entry.object.olcAccess or []\n            olcAccess = [olcAccess] unless Array.isArray olcAccess\n          search.on 'end', ->\n            options.log? \"Attribute olcAccess was #{JSON.stringify olcAccess}\"\n            parse olcAccess\n    parse = (_olcAccess) ->\n      olcAccess = []\n      for access, i in _olcAccess\n        to = ''\n        bys = []\n        buftype = 0 # 0: start, 1: to, 2:by\n        buf = ''\n        for c, i in access\n          buf += c\n          if buftype is 0\n            if /to$/.test buf\n              buf = ''\n              buftype = 1\n          if buftype is 1\n            if matches = /^(.*)by$/.exec buf\n              to = matches[1].trim()\n              buf = ''\n              buftype = 2\n          if buftype is 2\n            if matches = /^(.*)by$/.exec buf\n              bys.push matches[1].trim()\n              buf = ''\n            else if i+1 is access.length\n              bys.push buf.trim()\n        olcAccess.push\n          to: to\n          by: bys\n      do_diff olcAccess\n    do_diff = (olcAccess) ->\n      toAlreadyExist = false\n      for access, i in olcAccess\n        continue unless acl.to is access.to\n        toAlreadyExist = true\n        fby = unless options.overwrite then access.by else []\n        for oby in acl.by\n          found = false\n          for aby in access.by\n            if oby is aby\n              found = true\n              break\n          unless found\n            updated = true\n            fby.push oby\n        olcAccess[i].by = fby\n      unless toAlreadyExist\n        updated = true\n        # place before\n        if acl.before\n          found = null\n          for access, i in olcAccess\n            found = i if access.to is acl.before\n          # throw Error 'Before does not match any \"to\" rule' unless found?\n          olcAccess.splice found-1, 0, to: acl.to, by: acl.by\n        # place after\n        else if acl.after\n          found = false\n          for access, i in olcAccess\n            found = i if access.to is options.after\n          # throw Error 'After does not match any \"to\" rule'\n          olcAccess.splice found, 0, to: acl.to, by: acl.by\n        # append\n        else\n          olcAccess.push to: acl.to, by: acl.by\n      if updated then stringify(olcAccess) else unbind()\n    stringify = (olcAccess) ->\n      for access, i in olcAccess\n        value = \"{#{i}}to #{access.to}\"\n        for bie in access.by\n          value += \" by #{bie}\"\n        olcAccess[i] = value\n      save olcAccess\n    save = (olcAccess) ->\n      change = new ldap.Change\n        operation: 'replace'\n        modification: olcAccess: olcAccess\n      client.modify options.name, change, (err) ->\n        unbind err\n    unbind = (err) ->\n      options.log? 'Unbind connection'\n      # return end err if options.ldap instanceof ldap.client and not options.unbind\n      return end err if options.ldap?.url?.protocol?.indexOf('ldap') is 0 and not options.unbind\n      client.unbind (e) ->\n        return next e if e\n        end err\n    end = (err) ->\n      next err\n    connect()\n  .next (err) ->\n    next err, updated\n\n\n\nDependencies\n\n\neach = require 'each'\nwrap = require '../misc/wrap'",
            "title": "Ldap acl.coffee"
        },
        {
            "location": "/alt/ldap_acl.coffee/#nikitaldapacloptions-goptions-callback",
            "text": "Create new  ACLs  for the OpenLDAP server.     This implementation currently doesn't execute remote SSH commands. Instead, it\nconnects directly to the LDAP database and thus requires a specific port to be\naccessible.",
            "title": "nikita.ldap.acl(options, [goptions], callback)"
        },
        {
            "location": "/alt/ldap_acl.coffee/#options",
            "text": "to   \n    What to control access to as a string.     by   \n    Who to grant access to and the access to grant as an array\n    (eg:  {..., by:[\"ssf=64 anonymous auth\"]} ).     url   \n    Specify URI referring to the ldap server, alternative to providing an\n    [ldapjs client] instance.     binddn   \n    Distinguished Name to bind to the LDAP directory, alternative to providing\n    an [ldapjs client] instance.     passwd   \n    Password for simple authentication, alternative to providing an\n    [ldapjs client] instance.     ldap   \n    Instance of an  ldapjs client , alternative to providing the  url ,\n     binddn  and  passwd  connection properties.     unbind   \n    Close the ldap connection, default to false if connection is an\n     ldapjs client  instance.     name   \n    Distinguish name storing the \"olcAccess\" property, using the database adress\n    (eg: \"olcDatabase={2}bdb,cn=config\").     overwrite   \n    Overwrite existing \"olcAccess\", default is to merge.     log   \n    Function called with a log related messages.     acl   \n    In case of multiple acls, regroup \"before\", \"to\" and \"by\" as an array.",
            "title": "Options"
        },
        {
            "location": "/alt/ldap_acl.coffee/#example",
            "text": "require('nikita/alt/ldap.acl')({\n  url: 'ldap://openldap.server/',\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  name: 'olcDatabase={2}bdb,cn=config',\n  acls: [{\n    before: 'dn.subtree=\"dc=domain,dc=com\"',\n    to: 'dn.subtree=\"ou=users,dc=domain,dc=com\"',\n    by: [\n      'dn.exact=\"ou=users,dc=domain,dc=com\" write',\n      \"dn.base='gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth' read\",\n      \"* none\"\n    ]\n  },{\n    to: 'dn.subtree=\"dc=domain,dc=com\"',\n    by: [\n      'dn.exact=\"ou=kerberos,dc=domain,dc=com\" write'\n    ]\n  }]\n}, function(err, modified){\n  console.log(err ? err.message : \"ACL modified: \" + !!modified);\n});  module.exports = (goptions, options, callback) ->\n  options.acls ?= [{}]\n  updated = false\n  each(options.acls)\n  .call (acl, next) ->\n    acl.before ?= options.before\n    acl.to ?= options.to\n    acl.by ?= options.by\n    client = null\n    acl.to = acl.to.trim()\n    for b, i in acl.by\n      acl.by[i] = b.trim()\n    connect = ->\n      # if options.ldap instanceof ldap.client\n      if options.ldap?.url?.protocol?.indexOf('ldap') is 0\n        client = options.ldap\n        return search()\n      options.log? 'Open and bind connection'\n      client = ldap.createClient url: options.url\n      client.bind options.binddn, options.passwd, (err) ->\n        return end err if err\n        search()\n    search = ->\n        options.log? 'Search attribute olcAccess'\n        client.search options.name,\n          scope: 'base'\n          attributes: ['olcAccess']\n        , (err, search) ->\n          return unbind err if err\n          olcAccess = null\n          search.on 'searchEntry', (entry) ->\n            options.log? \"Found #{JSON.stringify entry.object}\"\n            # typeof olcAccess may be undefined, array or string\n            olcAccess = entry.object.olcAccess or []\n            olcAccess = [olcAccess] unless Array.isArray olcAccess\n          search.on 'end', ->\n            options.log? \"Attribute olcAccess was #{JSON.stringify olcAccess}\"\n            parse olcAccess\n    parse = (_olcAccess) ->\n      olcAccess = []\n      for access, i in _olcAccess\n        to = ''\n        bys = []\n        buftype = 0 # 0: start, 1: to, 2:by\n        buf = ''\n        for c, i in access\n          buf += c\n          if buftype is 0\n            if /to$/.test buf\n              buf = ''\n              buftype = 1\n          if buftype is 1\n            if matches = /^(.*)by$/.exec buf\n              to = matches[1].trim()\n              buf = ''\n              buftype = 2\n          if buftype is 2\n            if matches = /^(.*)by$/.exec buf\n              bys.push matches[1].trim()\n              buf = ''\n            else if i+1 is access.length\n              bys.push buf.trim()\n        olcAccess.push\n          to: to\n          by: bys\n      do_diff olcAccess\n    do_diff = (olcAccess) ->\n      toAlreadyExist = false\n      for access, i in olcAccess\n        continue unless acl.to is access.to\n        toAlreadyExist = true\n        fby = unless options.overwrite then access.by else []\n        for oby in acl.by\n          found = false\n          for aby in access.by\n            if oby is aby\n              found = true\n              break\n          unless found\n            updated = true\n            fby.push oby\n        olcAccess[i].by = fby\n      unless toAlreadyExist\n        updated = true\n        # place before\n        if acl.before\n          found = null\n          for access, i in olcAccess\n            found = i if access.to is acl.before\n          # throw Error 'Before does not match any \"to\" rule' unless found?\n          olcAccess.splice found-1, 0, to: acl.to, by: acl.by\n        # place after\n        else if acl.after\n          found = false\n          for access, i in olcAccess\n            found = i if access.to is options.after\n          # throw Error 'After does not match any \"to\" rule'\n          olcAccess.splice found, 0, to: acl.to, by: acl.by\n        # append\n        else\n          olcAccess.push to: acl.to, by: acl.by\n      if updated then stringify(olcAccess) else unbind()\n    stringify = (olcAccess) ->\n      for access, i in olcAccess\n        value = \"{#{i}}to #{access.to}\"\n        for bie in access.by\n          value += \" by #{bie}\"\n        olcAccess[i] = value\n      save olcAccess\n    save = (olcAccess) ->\n      change = new ldap.Change\n        operation: 'replace'\n        modification: olcAccess: olcAccess\n      client.modify options.name, change, (err) ->\n        unbind err\n    unbind = (err) ->\n      options.log? 'Unbind connection'\n      # return end err if options.ldap instanceof ldap.client and not options.unbind\n      return end err if options.ldap?.url?.protocol?.indexOf('ldap') is 0 and not options.unbind\n      client.unbind (e) ->\n        return next e if e\n        end err\n    end = (err) ->\n      next err\n    connect()\n  .next (err) ->\n    next err, updated",
            "title": "Example"
        },
        {
            "location": "/alt/ldap_acl.coffee/#dependencies",
            "text": "each = require 'each'\nwrap = require '../misc/wrap'",
            "title": "Dependencies"
        },
        {
            "location": "/alt/ldap_index.coffee/",
            "text": "nikita.ldap.index(options, [goptions], callback)\n\n\nCreate new \nindex\n for the OpenLDAP server.   \n\n\nThis implementation currently doesn't execute remote SSH commands. Instead, it\nconnects directly to the LDAP database and thus requires a specific port to be\naccessible.   \n\n\nOptions\n\n\n\n\nindexes\n \n\n    Object with keys mapping to indexed attributes and values mapping to indices\n    (\"pres\", \"approx\", \"eq\", \"sub\" and 'special').   \n\n\nurl\n \n\n    Specify URI referring to the ldap server, alternative to providing an\n    [ldapjs client] instance.   \n\n\nbinddn\n \n\n    Distinguished Name to bind to the LDAP directory, alternative to providing\n    an [ldapjs client] instance.   \n\n\npasswd\n \n\n    Password for simple authentication, alternative to providing an\n    [ldapjs client] instance.   \n\n\nldap\n \n\n    Instance of an pldapjs client][ldapclt], alternative to providing the \nurl\n,\n    \nbinddn\n and \npasswd\n connection properties.   \n\n\nunbind\n \n\n    Close the ldap connection, default to false if connection is an\n    [ldapjs client][ldapclt] instance.   \n\n\nname\n \n\n    Distinguish name storing the \"olcAccess\" property, using the database adress\n    (eg: \"olcDatabase={2}bdb,cn=config\").   \n\n\noverwrite\n \n\n    Overwrite existing \"olcAccess\", default is to merge.   \n\n\n\n\nExample\n\n\nrequire('nikita/alt/ldap.index')({\n  url: 'ldap://openldap.server/',\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  name: 'olcDatabase={2}bdb,cn=config',\n  indexes: {\n    krbPrincipalName: 'sub,eq'\n  }\n}, function(err, modified){\n  console.log(err ? err.message : \"Index modified: \" + !!modified);\n});\n\n\n\n\nmodule.exports = (goptions, options, callback) ->\n  wrap arguments, (options, next) ->\n    client = null\n    updated = false\n    connect = ->\n      # if options.ldap instanceof ldap.client\n      if options.ldap?.url?.protocol?.indexOf('ldap') is 0\n        client = options.ldap\n        return get()\n      # Open and bind connection\n      client = ldap.createClient url: options.url\n      client.bind options.binddn, options.passwd, (err) ->\n        return end err if err\n        get()\n    get = ->\n      client.search 'olcDatabase={2}bdb,cn=config',\n          scope: 'base'\n          attributes: ['olcDbIndex']\n      , (err, search) ->\n        olcDbIndex = null\n        search.on 'searchEntry', (entry) ->\n          olcDbIndex = entry.object.olcDbIndex\n        search.on 'end', ->\n          parse olcDbIndex\n    parse = (arIndex) ->\n      indexes = {}\n      for index in arIndex\n        [k,v] = index.split ' '\n        indexes[k] = v\n      do_diff indexes\n    do_diff = (orgp) ->\n      unless options.overwrite\n        newp = misc.merge {}, orgp, options.indexes\n      else\n        newp = options.indexes\n      okl = Object.keys(orgp).sort()\n      nkl = Object.keys(newp).sort()\n      for i in [0...Math.min(okl.length, nkl.length)]\n        if i is okl.length or i is nkl.length or okl[i] isnt nkl[i] or orgp[okl[i]] isnt newp[nkl[i]]\n          updated = true\n          break\n      if updated then stringifiy newp else unbind()\n    stringifiy = (perms) ->\n      indexes = []\n      for k, v of perms\n        indexes.push \"#{k} #{v}\"\n      replace indexes\n    replace = (indexes) ->\n      change = new ldap.Change\n        operation: 'replace'\n        modification:\n          olcDbIndex: indexes\n      client.modify options.name, change, (err) ->\n        unbind err\n    unbind = (err) ->\n      # return end err if options.ldap instanceof ldap.client and not options.unbind\n      return end err if options.ldap?.url?.protocol?.indexOf('ldap') is 0 and not options.unbind\n      client.unbind (e) ->\n        return next e if e\n        end err\n    end = (err) ->\n      next err, updated\n    connect()\n\n\n\nDependencies\n\n\nldap = require 'ldapjs'\nmisc = require '../misc'\nwrap = require '../misc/wrap'",
            "title": "Ldap index.coffee"
        },
        {
            "location": "/alt/ldap_index.coffee/#nikitaldapindexoptions-goptions-callback",
            "text": "Create new  index  for the OpenLDAP server.     This implementation currently doesn't execute remote SSH commands. Instead, it\nconnects directly to the LDAP database and thus requires a specific port to be\naccessible.",
            "title": "nikita.ldap.index(options, [goptions], callback)"
        },
        {
            "location": "/alt/ldap_index.coffee/#options",
            "text": "indexes   \n    Object with keys mapping to indexed attributes and values mapping to indices\n    (\"pres\", \"approx\", \"eq\", \"sub\" and 'special').     url   \n    Specify URI referring to the ldap server, alternative to providing an\n    [ldapjs client] instance.     binddn   \n    Distinguished Name to bind to the LDAP directory, alternative to providing\n    an [ldapjs client] instance.     passwd   \n    Password for simple authentication, alternative to providing an\n    [ldapjs client] instance.     ldap   \n    Instance of an pldapjs client][ldapclt], alternative to providing the  url ,\n     binddn  and  passwd  connection properties.     unbind   \n    Close the ldap connection, default to false if connection is an\n    [ldapjs client][ldapclt] instance.     name   \n    Distinguish name storing the \"olcAccess\" property, using the database adress\n    (eg: \"olcDatabase={2}bdb,cn=config\").     overwrite   \n    Overwrite existing \"olcAccess\", default is to merge.",
            "title": "Options"
        },
        {
            "location": "/alt/ldap_index.coffee/#example",
            "text": "require('nikita/alt/ldap.index')({\n  url: 'ldap://openldap.server/',\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  name: 'olcDatabase={2}bdb,cn=config',\n  indexes: {\n    krbPrincipalName: 'sub,eq'\n  }\n}, function(err, modified){\n  console.log(err ? err.message : \"Index modified: \" + !!modified);\n});  module.exports = (goptions, options, callback) ->\n  wrap arguments, (options, next) ->\n    client = null\n    updated = false\n    connect = ->\n      # if options.ldap instanceof ldap.client\n      if options.ldap?.url?.protocol?.indexOf('ldap') is 0\n        client = options.ldap\n        return get()\n      # Open and bind connection\n      client = ldap.createClient url: options.url\n      client.bind options.binddn, options.passwd, (err) ->\n        return end err if err\n        get()\n    get = ->\n      client.search 'olcDatabase={2}bdb,cn=config',\n          scope: 'base'\n          attributes: ['olcDbIndex']\n      , (err, search) ->\n        olcDbIndex = null\n        search.on 'searchEntry', (entry) ->\n          olcDbIndex = entry.object.olcDbIndex\n        search.on 'end', ->\n          parse olcDbIndex\n    parse = (arIndex) ->\n      indexes = {}\n      for index in arIndex\n        [k,v] = index.split ' '\n        indexes[k] = v\n      do_diff indexes\n    do_diff = (orgp) ->\n      unless options.overwrite\n        newp = misc.merge {}, orgp, options.indexes\n      else\n        newp = options.indexes\n      okl = Object.keys(orgp).sort()\n      nkl = Object.keys(newp).sort()\n      for i in [0...Math.min(okl.length, nkl.length)]\n        if i is okl.length or i is nkl.length or okl[i] isnt nkl[i] or orgp[okl[i]] isnt newp[nkl[i]]\n          updated = true\n          break\n      if updated then stringifiy newp else unbind()\n    stringifiy = (perms) ->\n      indexes = []\n      for k, v of perms\n        indexes.push \"#{k} #{v}\"\n      replace indexes\n    replace = (indexes) ->\n      change = new ldap.Change\n        operation: 'replace'\n        modification:\n          olcDbIndex: indexes\n      client.modify options.name, change, (err) ->\n        unbind err\n    unbind = (err) ->\n      # return end err if options.ldap instanceof ldap.client and not options.unbind\n      return end err if options.ldap?.url?.protocol?.indexOf('ldap') is 0 and not options.unbind\n      client.unbind (e) ->\n        return next e if e\n        end err\n    end = (err) ->\n      next err, updated\n    connect()",
            "title": "Example"
        },
        {
            "location": "/alt/ldap_index.coffee/#dependencies",
            "text": "ldap = require 'ldapjs'\nmisc = require '../misc'\nwrap = require '../misc/wrap'",
            "title": "Dependencies"
        },
        {
            "location": "/connection/assert.coffee/",
            "text": "nikita.connection.assert(options, [callback])\n\n\nAssert a TCP or HTTP server is listening. \n\n\nOptions\n\n\n\n\nhost\n (string)\n\n  Host of the targeted server, could be a FQDN, a hostname or an IP.\n\n\nport\n (number)\n\n  Port of the targeted server.\n\n\nserver\n, \nservers\n (array|object|string)\n\n  One or multiple servers, string must be in the form of \"{host}:{port}\",\n  object must have the properties \"host\" and \"port\".\n\n\n\n\nSource code\n\n\nmodule.exports = shy: true, handler: (options) ->\n  options.log message: \"Entering connection.assert\", level: 'DEBUG', module: 'nikita/lib/connection/assert'\n  options.servers ?= []\n  options.servers.push options.server if options.server\n  throw Error \"Required Option: host is required if port is provided\" if options.port and not options.host\n  throw Error \"Required Option: port is required if host is provided\" if options.host and not options.port\n  options.servers.push host: options.host, port: options.port if options.host\n  for server in options.servers\n    @system.execute\n      cmd: \"bash -c 'echo > /dev/tcp/#{server.host}/#{server.port}'\"\n    , (err) ->\n      throw Error \"Address not listening: \\\"#{server.host}:#{server.port}\\\"\" if err",
            "title": "Assert.coffee"
        },
        {
            "location": "/connection/assert.coffee/#nikitaconnectionassertoptions-callback",
            "text": "Assert a TCP or HTTP server is listening.",
            "title": "nikita.connection.assert(options, [callback])"
        },
        {
            "location": "/connection/assert.coffee/#options",
            "text": "host  (string) \n  Host of the targeted server, could be a FQDN, a hostname or an IP.  port  (number) \n  Port of the targeted server.  server ,  servers  (array|object|string) \n  One or multiple servers, string must be in the form of \"{host}:{port}\",\n  object must have the properties \"host\" and \"port\".",
            "title": "Options"
        },
        {
            "location": "/connection/assert.coffee/#source-code",
            "text": "module.exports = shy: true, handler: (options) ->\n  options.log message: \"Entering connection.assert\", level: 'DEBUG', module: 'nikita/lib/connection/assert'\n  options.servers ?= []\n  options.servers.push options.server if options.server\n  throw Error \"Required Option: host is required if port is provided\" if options.port and not options.host\n  throw Error \"Required Option: port is required if host is provided\" if options.host and not options.port\n  options.servers.push host: options.host, port: options.port if options.host\n  for server in options.servers\n    @system.execute\n      cmd: \"bash -c 'echo > /dev/tcp/#{server.host}/#{server.port}'\"\n    , (err) ->\n      throw Error \"Address not listening: \\\"#{server.host}:#{server.port}\\\"\" if err",
            "title": "Source code"
        },
        {
            "location": "/connection/wait.coffee/",
            "text": "nikita.connection.wait(options, [callback])\n\n\nCheck if one or multiple hosts listen one or multiple ports periodically and\ncontinue once all the connections succeed. Status will be set to \"false\" if the\nuser connections succeed right away, considering that no change had occured.\nOtherwise it will be set to \"true\".   \n\n\nOptions\n\n\n\n\nhost\n, \nhosts\n (array|string)\n\n  One or multiple hosts, used to build or enrich the 'servers' option.\n\n\ninterval\n (number)\n\n  Time in millisecond between each connection attempt.\n\n\nquorum\n (number|boolean)\n\n  Number of minimal successful connection, 50%+1 if \"true\".    \n\n\nport\n, \nports\n (array|string)\n\n  One or multiple ports, used to build or enrich the 'servers' option.\n\n\nranddir\n \n\n  Directory where to write temporary file used internally to triger a \n\n\nserver\n, \nservers\n (array|object|string)\n\n  One or multiple servers, string must be in the form of \"{host}:{port}\",\n  object must have the properties \"host\" and \"port\".\n\n\ntimeout\n \n\n  Maximum time to wait until this function is considered to have failed.\n\n\n\n\nStatus is set to \"true\" if the first connection attempt was a failure and the \nconnection finaly succeeded.\n\n\nExamples\n\n\nWait for two domains on the same port.\n\n\nrequire('nikita')\n.wait_connect({\n  hosts: [ '1.domain.com', '2.domain.com' ],\n  port: 80\n}, function(err, status){\n  // Servers listening on port 80\n})\n\n\n\n\nWait for one domain on two diffents ports.\n\n\nrequire('nikita')\n.wait_connect({\n  host: 'my.domain.com',\n  ports: [80, 443]\n}, function(err, status){\n  // Server listening on ports 80 and 443\n})\n\n\n\n\nWait for two domains on diffents ports.\n\n\nrequire('nikita')\n.wait_connect({\n  servers: [\n    {host: '1.domain.com', port: 80},\n    {host: '2.domain.com', port: 443}\n  ]\n}, function(err, status){\n  // Servers listening\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering wait for connection\", level: 'DEBUG', module: 'nikita/connection/wait'\n  extract_servers = (options) ->\n    throw Error \"Invalid host: #{server.host}\" if (options.port or options.ports) and not options.host\n    throw Error \"Invalid port: #{server.port}\" if (options.host or options.hosts) and not options.port\n    for k in ['host', 'hosts']\n      options[k] ?= []\n      throw Error \"Invalid option '#{options[k]}'\" if typeof options[k] not in ['string', 'object']\n      options[k] = [options[k]] unless Array.isArray options[k]\n    hosts = [options.host..., options.hosts...]\n    for k in ['port', 'ports']\n      options[k] ?= []\n      throw Error \"Invalid option '#{options[k]}'\" if typeof options[k] not in ['string', 'number', 'object']\n      options[k] = [options[k]] unless Array.isArray options[k]\n    ports = [options.port..., options.ports...]\n    servers = []\n    for host in hosts\n      for port in ports\n        servers.push host: host, port: port\n    servers\n  servers = extract_servers options\n  for k in ['server', 'servers']\n    options[k] ?= []\n    throw Error \"Invalid option '#{options[k]}'\" if typeof options[k] not in ['string', 'object']\n    if typeof options[k] is 'string'\n      [host, port] = options[k].split ':'\n      options[k] = host: host, port: port\n    options[k] = [options[k]] unless Array.isArray options[k]\n    options[k] = array.flatten options[k]\n    for server in options[k]\n      servers.push extract_servers(server)...\n  unless servers.length\n    options.log message: \"No connection to wait for\", level: 'WARN', module: 'nikita/connection/wait'\n    return \n  # Validate servers\n  options.interval ?= 2000 # 2s\n  options.interval = Math.round options.interval / 1000\n  quorum_target = options.quorum\n  if quorum_target and quorum_target is true  \n    quorum_target = Math.ceil servers.length / 2\n  else unless quorum_target?\n    quorum_target = servers.length\n  options.timeout = '' unless options.timeout > 0\n  @system.execute\n    bash: true\n    cmd: \"\"\"\n    function compute_md5 {\n      echo $1 | openssl md5 | sed 's/^.* \\\\([a-z0-9]*\\\\)$/\\\\1/g'\n    }\n    addresses=( #{servers.map((server) -> \"'#{server.host}:#{server.port}'\").join(' ')} )\n    timeout=#{options.timeout or ''}\n    md5=`compute_md5 ${addresses[@]}`\n    randdir=\"#{options.randdir or ''}\"\n    if [ -z $randir ]; then\n      if [ -w /dev/shm ]; then\n        randdir=\"/dev/shm/$md5\"\n      else\n        randdir=\"/tmp/$md5\"\n      fi\n    fi\n    quorum_target=#{quorum_target}\n    echo \"[INFO] randdir is: $randdir\"\n    mkdir -p $randdir\n    echo 3 > $randdir/signal\n    echo 0 > $randdir/quorum\n    function remove_randdir {\n      for address in \"${addresses[@]}\" ; do\n        host=\"${address%%:*}\"\n        port=\"${address##*:}\"\n        rm -f $randdir/`compute_md5 $host:$port`\n      done\n    }\n    function check_quorum {\n      quorum_current=`cat $randdir/quorum`\n      if [ $quorum_current -ge $quorum_target ]; then\n        echo '[INFO] Quorum is reached'\n        remove_randdir\n      fi\n    }\n    function check_timeout {\n      local timeout=$1\n      local randfile=$2\n      wait $timeout\n      rm -f $randfile\n    }\n    function wait_connection {\n      local host=$1\n      local port=$2\n      local randfile=$3\n      local count=0\n      echo \"[DEBUG] Start wait for $host:$port\"\n      isopen=\"echo > '/dev/tcp/$host/$port'\"\n      touch \"$randfile\"\n      while [[ -f \"$randfile\" ]] && ! `bash -c \"$isopen\" 2>/dev/null`; do\n        ((count++))\n        echo \"[DEBUG] Connection failed to $host:$port on attempt $count\" >&2\n        sleep #{options.interval}\n      done\n      if [[ -f \"$randfile\" ]]; then\n        echo \"[DEBUG] Connection ready to $host:$port\"\n      fi\n      echo $(( $(cat $randdir/quorum) + 1 )) > $randdir/quorum\n      check_quorum\n      if [ \"$count\" -gt \"0\" ]; then\n        echo \"[WARN] Status is now active, count is $count\"\n        echo 0 > $randdir/signal\n      fi\n    }\n    if [ ! -z \"$timeout\" ]; then\n      host=\"${address%%:*}\"\n      port=\"${address##*:}\"\n      check_timeout $timeout `compute_md5 $host:$port` &\n    fi\n    for address in \"${addresses[@]}\" ; do\n      host=\"${address%%:*}\"\n      port=\"${address##*:}\"\n      randfile=$randdir/`compute_md5 $host:$port`\n      wait_connection $host $port $randfile &\n    done\n    wait\n    # Clean up\n    signal=`cat $randdir/signal`\n    remove_randdir\n    echo \"[INFO] Exit code is $signal\"\n    exit $signal\n    \"\"\"\n    code_skipped: 3\n    stdin_log: false\n\n\n\nDependencies\n\n\narray = require '../misc/array'",
            "title": "Wait.coffee"
        },
        {
            "location": "/connection/wait.coffee/#nikitaconnectionwaitoptions-callback",
            "text": "Check if one or multiple hosts listen one or multiple ports periodically and\ncontinue once all the connections succeed. Status will be set to \"false\" if the\nuser connections succeed right away, considering that no change had occured.\nOtherwise it will be set to \"true\".",
            "title": "nikita.connection.wait(options, [callback])"
        },
        {
            "location": "/connection/wait.coffee/#options",
            "text": "host ,  hosts  (array|string) \n  One or multiple hosts, used to build or enrich the 'servers' option.  interval  (number) \n  Time in millisecond between each connection attempt.  quorum  (number|boolean) \n  Number of minimal successful connection, 50%+1 if \"true\".      port ,  ports  (array|string) \n  One or multiple ports, used to build or enrich the 'servers' option.  randdir   \n  Directory where to write temporary file used internally to triger a   server ,  servers  (array|object|string) \n  One or multiple servers, string must be in the form of \"{host}:{port}\",\n  object must have the properties \"host\" and \"port\".  timeout   \n  Maximum time to wait until this function is considered to have failed.   Status is set to \"true\" if the first connection attempt was a failure and the \nconnection finaly succeeded.",
            "title": "Options"
        },
        {
            "location": "/connection/wait.coffee/#examples",
            "text": "Wait for two domains on the same port.  require('nikita')\n.wait_connect({\n  hosts: [ '1.domain.com', '2.domain.com' ],\n  port: 80\n}, function(err, status){\n  // Servers listening on port 80\n})  Wait for one domain on two diffents ports.  require('nikita')\n.wait_connect({\n  host: 'my.domain.com',\n  ports: [80, 443]\n}, function(err, status){\n  // Server listening on ports 80 and 443\n})  Wait for two domains on diffents ports.  require('nikita')\n.wait_connect({\n  servers: [\n    {host: '1.domain.com', port: 80},\n    {host: '2.domain.com', port: 443}\n  ]\n}, function(err, status){\n  // Servers listening\n})",
            "title": "Examples"
        },
        {
            "location": "/connection/wait.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering wait for connection\", level: 'DEBUG', module: 'nikita/connection/wait'\n  extract_servers = (options) ->\n    throw Error \"Invalid host: #{server.host}\" if (options.port or options.ports) and not options.host\n    throw Error \"Invalid port: #{server.port}\" if (options.host or options.hosts) and not options.port\n    for k in ['host', 'hosts']\n      options[k] ?= []\n      throw Error \"Invalid option '#{options[k]}'\" if typeof options[k] not in ['string', 'object']\n      options[k] = [options[k]] unless Array.isArray options[k]\n    hosts = [options.host..., options.hosts...]\n    for k in ['port', 'ports']\n      options[k] ?= []\n      throw Error \"Invalid option '#{options[k]}'\" if typeof options[k] not in ['string', 'number', 'object']\n      options[k] = [options[k]] unless Array.isArray options[k]\n    ports = [options.port..., options.ports...]\n    servers = []\n    for host in hosts\n      for port in ports\n        servers.push host: host, port: port\n    servers\n  servers = extract_servers options\n  for k in ['server', 'servers']\n    options[k] ?= []\n    throw Error \"Invalid option '#{options[k]}'\" if typeof options[k] not in ['string', 'object']\n    if typeof options[k] is 'string'\n      [host, port] = options[k].split ':'\n      options[k] = host: host, port: port\n    options[k] = [options[k]] unless Array.isArray options[k]\n    options[k] = array.flatten options[k]\n    for server in options[k]\n      servers.push extract_servers(server)...\n  unless servers.length\n    options.log message: \"No connection to wait for\", level: 'WARN', module: 'nikita/connection/wait'\n    return \n  # Validate servers\n  options.interval ?= 2000 # 2s\n  options.interval = Math.round options.interval / 1000\n  quorum_target = options.quorum\n  if quorum_target and quorum_target is true  \n    quorum_target = Math.ceil servers.length / 2\n  else unless quorum_target?\n    quorum_target = servers.length\n  options.timeout = '' unless options.timeout > 0\n  @system.execute\n    bash: true\n    cmd: \"\"\"\n    function compute_md5 {\n      echo $1 | openssl md5 | sed 's/^.* \\\\([a-z0-9]*\\\\)$/\\\\1/g'\n    }\n    addresses=( #{servers.map((server) -> \"'#{server.host}:#{server.port}'\").join(' ')} )\n    timeout=#{options.timeout or ''}\n    md5=`compute_md5 ${addresses[@]}`\n    randdir=\"#{options.randdir or ''}\"\n    if [ -z $randir ]; then\n      if [ -w /dev/shm ]; then\n        randdir=\"/dev/shm/$md5\"\n      else\n        randdir=\"/tmp/$md5\"\n      fi\n    fi\n    quorum_target=#{quorum_target}\n    echo \"[INFO] randdir is: $randdir\"\n    mkdir -p $randdir\n    echo 3 > $randdir/signal\n    echo 0 > $randdir/quorum\n    function remove_randdir {\n      for address in \"${addresses[@]}\" ; do\n        host=\"${address%%:*}\"\n        port=\"${address##*:}\"\n        rm -f $randdir/`compute_md5 $host:$port`\n      done\n    }\n    function check_quorum {\n      quorum_current=`cat $randdir/quorum`\n      if [ $quorum_current -ge $quorum_target ]; then\n        echo '[INFO] Quorum is reached'\n        remove_randdir\n      fi\n    }\n    function check_timeout {\n      local timeout=$1\n      local randfile=$2\n      wait $timeout\n      rm -f $randfile\n    }\n    function wait_connection {\n      local host=$1\n      local port=$2\n      local randfile=$3\n      local count=0\n      echo \"[DEBUG] Start wait for $host:$port\"\n      isopen=\"echo > '/dev/tcp/$host/$port'\"\n      touch \"$randfile\"\n      while [[ -f \"$randfile\" ]] && ! `bash -c \"$isopen\" 2>/dev/null`; do\n        ((count++))\n        echo \"[DEBUG] Connection failed to $host:$port on attempt $count\" >&2\n        sleep #{options.interval}\n      done\n      if [[ -f \"$randfile\" ]]; then\n        echo \"[DEBUG] Connection ready to $host:$port\"\n      fi\n      echo $(( $(cat $randdir/quorum) + 1 )) > $randdir/quorum\n      check_quorum\n      if [ \"$count\" -gt \"0\" ]; then\n        echo \"[WARN] Status is now active, count is $count\"\n        echo 0 > $randdir/signal\n      fi\n    }\n    if [ ! -z \"$timeout\" ]; then\n      host=\"${address%%:*}\"\n      port=\"${address##*:}\"\n      check_timeout $timeout `compute_md5 $host:$port` &\n    fi\n    for address in \"${addresses[@]}\" ; do\n      host=\"${address%%:*}\"\n      port=\"${address##*:}\"\n      randfile=$randdir/`compute_md5 $host:$port`\n      wait_connection $host $port $randfile &\n    done\n    wait\n    # Clean up\n    signal=`cat $randdir/signal`\n    remove_randdir\n    echo \"[INFO] Exit code is $signal\"\n    exit $signal\n    \"\"\"\n    code_skipped: 3\n    stdin_log: false",
            "title": "Source Code"
        },
        {
            "location": "/connection/wait.coffee/#dependencies",
            "text": "array = require '../misc/array'",
            "title": "Dependencies"
        },
        {
            "location": "/core/assert.coffee/",
            "text": "nikita.assert(options, [callback])\n\n\nA set of assertion tools.\n\n\nOptions\n\n\n\n\nstatus\n (boolean) \n\n  Ensure the current status match the provided value.   \n\n\n\n\nCallback Parameters\n\n\n\n\nerr\n \n\n  Error object if assertion failed.   \n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering assert\", level: 'DEBUG', module: 'nikita/lib/assert'\n\n\n\nCheck current status\n\n\nnikita.assert({\n  ssh: connection   \n  status: true\n}, function(err){\n  console.log(err ? err.message : 'Assertion is ok');\n});\n\n\n\n\n  status = @status()\n  @call\n    if: options.status? and status isnt options.status\n    handler: ->\n      message = \"Invalid status: expected #{JSON.stringify options.status}, got #{JSON.stringify status}\"\n      throw Error message",
            "title": "Assert.coffee"
        },
        {
            "location": "/core/assert.coffee/#nikitaassertoptions-callback",
            "text": "A set of assertion tools.",
            "title": "nikita.assert(options, [callback])"
        },
        {
            "location": "/core/assert.coffee/#options",
            "text": "status  (boolean)  \n  Ensure the current status match the provided value.",
            "title": "Options"
        },
        {
            "location": "/core/assert.coffee/#callback-parameters",
            "text": "err   \n  Error object if assertion failed.",
            "title": "Callback Parameters"
        },
        {
            "location": "/core/assert.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering assert\", level: 'DEBUG', module: 'nikita/lib/assert'",
            "title": "Source Code"
        },
        {
            "location": "/core/assert.coffee/#check-current-status",
            "text": "nikita.assert({\n  ssh: connection   \n  status: true\n}, function(err){\n  console.log(err ? err.message : 'Assertion is ok');\n});    status = @status()\n  @call\n    if: options.status? and status isnt options.status\n    handler: ->\n      message = \"Invalid status: expected #{JSON.stringify options.status}, got #{JSON.stringify status}\"\n      throw Error message",
            "title": "Check current status"
        },
        {
            "location": "/core/ping.coffee/",
            "text": "nikita.ping(options, [callback])\n\n\nCall ping, receive pong.\n\n\nThis constitutes a dummy action created for demonstration purposes.\n\n\nOptions\n\n\n\n\ncontent\n (string) \n\n  Message to broadcast, default to \"pong\".   \n\n\n\n\nCallback Parameters\n\n\n\n\nerr\n (error) \n\n    Error object if assertion failed.   \n\n\nstatus\n (boolean) \n\n    Always \"true\".   \n\n\nmessage\n (string) \n\n    The content options.   \n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering ping\", level: 'DEBUG', module: 'nikita/lib/assert'\n  options.content ?= 'pong'\n  setImmediate ->\n    options.log message: \"Sending #{options.content}\", level: 'DEBUG', module: 'nikita/lib/assert'\n    callback null, true, options.content",
            "title": "Ping.coffee"
        },
        {
            "location": "/core/ping.coffee/#nikitapingoptions-callback",
            "text": "Call ping, receive pong.  This constitutes a dummy action created for demonstration purposes.",
            "title": "nikita.ping(options, [callback])"
        },
        {
            "location": "/core/ping.coffee/#options",
            "text": "content  (string)  \n  Message to broadcast, default to \"pong\".",
            "title": "Options"
        },
        {
            "location": "/core/ping.coffee/#callback-parameters",
            "text": "err  (error)  \n    Error object if assertion failed.     status  (boolean)  \n    Always \"true\".     message  (string)  \n    The content options.",
            "title": "Callback Parameters"
        },
        {
            "location": "/core/ping.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering ping\", level: 'DEBUG', module: 'nikita/lib/assert'\n  options.content ?= 'pong'\n  setImmediate ->\n    options.log message: \"Sending #{options.content}\", level: 'DEBUG', module: 'nikita/lib/assert'\n    callback null, true, options.content",
            "title": "Source Code"
        },
        {
            "location": "/core/kv/engine.coffee/",
            "text": "nikita.kv.memory(options, [callback])\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  @options.kv = options.engine",
            "title": "Engine.coffee"
        },
        {
            "location": "/core/kv/engine.coffee/#nikitakvmemoryoptions-callback",
            "text": "",
            "title": "nikita.kv.memory(options, [callback])"
        },
        {
            "location": "/core/kv/engine.coffee/#source-code",
            "text": "module.exports = (options) ->\n  @options.kv = options.engine",
            "title": "Source Code"
        },
        {
            "location": "/core/kv/get.coffee/",
            "text": "nikita.kv.get(options, [callback])\n\n\nSource Code\n\n\nmodule.exports = shy: true, handler: (options, callback) ->\n  options.log message: \"Entering kv get\", level: 'DEBUG', module: 'nikita/lib/core/kv/get'\n  throw Error \"Engine already defined\" if options.engine and @options.kv\n  throw Error \"No engine defined\" if not options.engine and not @options.kv\n  # @options.kv ?= options.engine\n  @options.kv.get options.key, (err, value) ->\n    callback err, true, options.key, value",
            "title": "Get.coffee"
        },
        {
            "location": "/core/kv/get.coffee/#nikitakvgetoptions-callback",
            "text": "",
            "title": "nikita.kv.get(options, [callback])"
        },
        {
            "location": "/core/kv/get.coffee/#source-code",
            "text": "module.exports = shy: true, handler: (options, callback) ->\n  options.log message: \"Entering kv get\", level: 'DEBUG', module: 'nikita/lib/core/kv/get'\n  throw Error \"Engine already defined\" if options.engine and @options.kv\n  throw Error \"No engine defined\" if not options.engine and not @options.kv\n  # @options.kv ?= options.engine\n  @options.kv.get options.key, (err, value) ->\n    callback err, true, options.key, value",
            "title": "Source Code"
        },
        {
            "location": "/core/kv/set.coffee/",
            "text": "nikita.kv.set(options, [callback])\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering kv set\", level: 'DEBUG', module: 'nikita/lib/core/kv/set'\n  throw Error \"Engine already defined\" if options.engine and @options.kv\n  throw Error \"No engine defined\" if not options.engine and not @options.kv\n  # @options.kv ?= options.engine\n  @options.kv.set options.key, options.value",
            "title": "Set.coffee"
        },
        {
            "location": "/core/kv/set.coffee/#nikitakvsetoptions-callback",
            "text": "",
            "title": "nikita.kv.set(options, [callback])"
        },
        {
            "location": "/core/kv/set.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering kv set\", level: 'DEBUG', module: 'nikita/lib/core/kv/set'\n  throw Error \"Engine already defined\" if options.engine and @options.kv\n  throw Error \"No engine defined\" if not options.engine and not @options.kv\n  # @options.kv ?= options.engine\n  @options.kv.set options.key, options.value",
            "title": "Source Code"
        },
        {
            "location": "/core/kv/engines/memory.coffee/",
            "text": "nikita.kv.memory(options, [callback])\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  db: {}\n  set: (key, value) ->\n    @db[key] ?= {}\n    @db[key].value = value\n    @db[key].listeners ?= []\n    while listener = @db[key].listeners.shift()\n      listener.call null, null, @db[key].value\n  get: (key, callback) ->\n    return callback null, @db[key].value if @db[key]?.value\n    @db[key] ?= {}\n    @db[key].listeners ?= []\n    @db[key].listeners.push callback",
            "title": "Memory.coffee"
        },
        {
            "location": "/core/kv/engines/memory.coffee/#nikitakvmemoryoptions-callback",
            "text": "",
            "title": "nikita.kv.memory(options, [callback])"
        },
        {
            "location": "/core/kv/engines/memory.coffee/#source-code",
            "text": "module.exports = (options) ->\n  db: {}\n  set: (key, value) ->\n    @db[key] ?= {}\n    @db[key].value = value\n    @db[key].listeners ?= []\n    while listener = @db[key].listeners.shift()\n      listener.call null, null, @db[key].value\n  get: (key, callback) ->\n    return callback null, @db[key].value if @db[key]?.value\n    @db[key] ?= {}\n    @db[key].listeners ?= []\n    @db[key].listeners.push callback",
            "title": "Source Code"
        },
        {
            "location": "/cron/add.coffee/",
            "text": "nikita.cron.add(options, [callback])\n\n\nCreate a new Kerberos principal with a password or an optional keytab.\n\n\nOptions\n\n\n\n\nuser\n (name | uid) \n\n  the user of the crontab. the SSH user by default   \n\n\nmatch\n (null | string | regexp). \n\n  The cron entry to match, a string will be converted to a regexp and an\n  undefined or null value will match the exact command.   \n\n\nwhen\n (string) \n\n  cron-styled time string. Defines the frequency of the cron job.   \n\n\ncmd\n \n\n  the shell command of the job   \n\n\nexec\n \n\n  if true, then cmd will be executed just after if added to crontab   \n\n\nlog\n \n\n  Function called with a log related messages.   \n\n\nssh\n (object|ssh2) \n\n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.   \n\n\nstdout\n (stream.Writable) \n\n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.   \n\n\nstderr\n (stream.Writable) \n\n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.   \n\n\n\n\nExample\n\n\nrequire('nikita').cron.add({\n  cmd: 'kinit service/my.fqdn@MY.REALM -kt /etc/security/service.keytab',\n  when: '0 */9 * * *'\n  user: 'service'\n}, function(err, status){\n  console.log(err ? err.message : 'Cron entry created or modified: ' + !!status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  return callback Error 'valid when is required' unless options.when and typeof options.when is 'string'\n  return callback Error 'valid cmd is required' unless options.cmd\n  if options.user?\n    options.log message: \"Using user #{options.user}\", level: 'DEBUG', module: 'nikita/cron/add'\n    crontab = \"crontab -u #{options.user}\"\n  else\n    options.log message: \"Using default user\", level: 'DEBUG', module: 'nikita/cron/add'\n    crontab = \"crontab\"\n  jobs = null\n  @system.execute\n    cmd: \"#{crontab} -l\"\n    code: [0, 1]\n  , (err, _, stdout, stderr) ->\n    throw err if err and not /^no crontab for/.test stderr\n    # throw Error 'User crontab not found' if /^no crontab for/.test stderr\n    new_job = \"#{options.when} #{options.cmd}\"\n    # remove useless last element\n    regex =\n      unless options.match then new RegExp \".* #{regexp.escape options.cmd}\"\n      else if typeof options.match is 'string' then new RegExp options.match\n      else if util.isRegExp options.match then options.match\n      else throw Error \"Invalid option 'match'\"\n    added = true\n    jobs = for job, i in string.lines stdout.trim()\n      # console.log job, regex.test job\n      if regex.test job\n        added = false\n        break if job is new_job # Found job, stop here\n        options.log message: \"Entry has changed\", level: 'WARN', module: 'nikita/cron/add'\n        diff job, new_job, options\n        job = new_job\n        modified = true\n      job\n    if added\n      jobs.push new_job\n      options.log message: \"Job not found in crontab, adding\", level: 'WARN', module: 'nikita/cron/add'\n    jobs = null unless added or modified\n  .next (err) ->\n    return callback err if err\n    return callback() unless jobs\n    @system.execute\n      cmd: if options.user? then \"su -l #{options.user} -c '#{options.cmd}'\" else options.cmd\n      if: options.exec\n    @system.execute\n      cmd: \"\"\"\n      #{crontab} - <<EOF\n      #{jobs.join '\\n'}\n      EOF\n      \"\"\"\n    .next callback\n\n\n\nDependencies\n\n\nutil = require 'util'\n{regexp} = require '../misc'\ndiff = require '../misc/diff'\nstring = require '../misc/string'\nwrap = require '../misc/wrap'",
            "title": "Add.coffee"
        },
        {
            "location": "/cron/add.coffee/#nikitacronaddoptions-callback",
            "text": "Create a new Kerberos principal with a password or an optional keytab.",
            "title": "nikita.cron.add(options, [callback])"
        },
        {
            "location": "/cron/add.coffee/#options",
            "text": "user  (name | uid)  \n  the user of the crontab. the SSH user by default     match  (null | string | regexp).  \n  The cron entry to match, a string will be converted to a regexp and an\n  undefined or null value will match the exact command.     when  (string)  \n  cron-styled time string. Defines the frequency of the cron job.     cmd   \n  the shell command of the job     exec   \n  if true, then cmd will be executed just after if added to crontab     log   \n  Function called with a log related messages.     ssh  (object|ssh2)  \n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.     stdout  (stream.Writable)  \n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.     stderr  (stream.Writable)  \n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.",
            "title": "Options"
        },
        {
            "location": "/cron/add.coffee/#example",
            "text": "require('nikita').cron.add({\n  cmd: 'kinit service/my.fqdn@MY.REALM -kt /etc/security/service.keytab',\n  when: '0 */9 * * *'\n  user: 'service'\n}, function(err, status){\n  console.log(err ? err.message : 'Cron entry created or modified: ' + !!status);\n});",
            "title": "Example"
        },
        {
            "location": "/cron/add.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  return callback Error 'valid when is required' unless options.when and typeof options.when is 'string'\n  return callback Error 'valid cmd is required' unless options.cmd\n  if options.user?\n    options.log message: \"Using user #{options.user}\", level: 'DEBUG', module: 'nikita/cron/add'\n    crontab = \"crontab -u #{options.user}\"\n  else\n    options.log message: \"Using default user\", level: 'DEBUG', module: 'nikita/cron/add'\n    crontab = \"crontab\"\n  jobs = null\n  @system.execute\n    cmd: \"#{crontab} -l\"\n    code: [0, 1]\n  , (err, _, stdout, stderr) ->\n    throw err if err and not /^no crontab for/.test stderr\n    # throw Error 'User crontab not found' if /^no crontab for/.test stderr\n    new_job = \"#{options.when} #{options.cmd}\"\n    # remove useless last element\n    regex =\n      unless options.match then new RegExp \".* #{regexp.escape options.cmd}\"\n      else if typeof options.match is 'string' then new RegExp options.match\n      else if util.isRegExp options.match then options.match\n      else throw Error \"Invalid option 'match'\"\n    added = true\n    jobs = for job, i in string.lines stdout.trim()\n      # console.log job, regex.test job\n      if regex.test job\n        added = false\n        break if job is new_job # Found job, stop here\n        options.log message: \"Entry has changed\", level: 'WARN', module: 'nikita/cron/add'\n        diff job, new_job, options\n        job = new_job\n        modified = true\n      job\n    if added\n      jobs.push new_job\n      options.log message: \"Job not found in crontab, adding\", level: 'WARN', module: 'nikita/cron/add'\n    jobs = null unless added or modified\n  .next (err) ->\n    return callback err if err\n    return callback() unless jobs\n    @system.execute\n      cmd: if options.user? then \"su -l #{options.user} -c '#{options.cmd}'\" else options.cmd\n      if: options.exec\n    @system.execute\n      cmd: \"\"\"\n      #{crontab} - <<EOF\n      #{jobs.join '\\n'}\n      EOF\n      \"\"\"\n    .next callback",
            "title": "Source Code"
        },
        {
            "location": "/cron/add.coffee/#dependencies",
            "text": "util = require 'util'\n{regexp} = require '../misc'\ndiff = require '../misc/diff'\nstring = require '../misc/string'\nwrap = require '../misc/wrap'",
            "title": "Dependencies"
        },
        {
            "location": "/cron/remove.coffee/",
            "text": "nikita.cron.remove(options, [callback])\n\n\nRemove job(s) on crontab.\n\n\nOptions\n\n\n\n\nuser\n (name | uid) \n\n  the user of the crontab. the SSH user by default   \n\n\nwhen\n (string) \n\n  cron-styled time string. Defines the frequency of the cron job. By default all\n  frequency will match.   \n\n\ncmd\n \n\n  the shell command of the job. By default all jobs will match.   \n\n\nlog\n \n\n  Function called with a log related messages.   \n\n\nssh\n (object|ssh2) \n\n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.   \n\n\nstdout\n (stream.Writable) \n\n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.   \n\n\nstderr\n (stream.Writable) \n\n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.   \n\n\n\n\nExample\n\n\nrequire('nikita').cron.remove({\n  cmd: 'kinit service/my.fqdn@MY.REALM -kt /etc/security/service.keytab',\n  when: '0 */9 * * *'\n  user: 'service'\n}, function(err, status){\n  console.log(err ? err.message : 'Cron entry created or modified: ' + !!status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  return callback Error 'valid cmd is required' unless options.cmd?.length > 0\n  if options.user?\n    options.log message: \"Using user #{options.user}\", level: 'INFO', module: 'nikita/cron/remove'\n    crontab = \"crontab -u #{options.user}\"\n  else\n    options.log message: \"Using default user\", level: 'INFO', module: 'nikita/cron/remove'\n    crontab = \"crontab\"\n  status = false\n  jobs = []\n  @system.execute\n    cmd: \"#{crontab} -l\"\n    shy: true\n  , (err, _, stdout, stderr) ->\n    throw err if err\n    throw Error 'User crontab not found' if /^no crontab for/.test stderr\n    myjob = if options.when then regexp.escape options.when else '.*'\n    myjob += regexp.escape \" #{options.cmd}\"\n    regex = new RegExp myjob\n    jobs = stdout.trim().split '\\n'\n    for job, i in jobs\n      continue unless regex.test job\n      options.log message: \"Job '#{job}' matches. Removing from list\", level: 'WARN', module: 'nikita/cron/remove'\n      status = true\n      jobs.splice i, 1\n    options.log message: \"No Job matches. Skipping\", level: 'INFO', module: 'nikita/cron/remove'\n  .system.execute\n    cmd: \"\"\"\n    #{crontab} - <<EOF\n    #{jobs.join '\\n'}\n    EOF\n    \"\"\"\n    if: -> status\n  .next callback\n\n\n\nDependencies\n\n\n{regexp} = require '../misc'\nwrap = require '../misc/wrap'",
            "title": "Remove.coffee"
        },
        {
            "location": "/cron/remove.coffee/#nikitacronremoveoptions-callback",
            "text": "Remove job(s) on crontab.",
            "title": "nikita.cron.remove(options, [callback])"
        },
        {
            "location": "/cron/remove.coffee/#options",
            "text": "user  (name | uid)  \n  the user of the crontab. the SSH user by default     when  (string)  \n  cron-styled time string. Defines the frequency of the cron job. By default all\n  frequency will match.     cmd   \n  the shell command of the job. By default all jobs will match.     log   \n  Function called with a log related messages.     ssh  (object|ssh2)  \n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.     stdout  (stream.Writable)  \n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.     stderr  (stream.Writable)  \n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.",
            "title": "Options"
        },
        {
            "location": "/cron/remove.coffee/#example",
            "text": "require('nikita').cron.remove({\n  cmd: 'kinit service/my.fqdn@MY.REALM -kt /etc/security/service.keytab',\n  when: '0 */9 * * *'\n  user: 'service'\n}, function(err, status){\n  console.log(err ? err.message : 'Cron entry created or modified: ' + !!status);\n});",
            "title": "Example"
        },
        {
            "location": "/cron/remove.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  return callback Error 'valid cmd is required' unless options.cmd?.length > 0\n  if options.user?\n    options.log message: \"Using user #{options.user}\", level: 'INFO', module: 'nikita/cron/remove'\n    crontab = \"crontab -u #{options.user}\"\n  else\n    options.log message: \"Using default user\", level: 'INFO', module: 'nikita/cron/remove'\n    crontab = \"crontab\"\n  status = false\n  jobs = []\n  @system.execute\n    cmd: \"#{crontab} -l\"\n    shy: true\n  , (err, _, stdout, stderr) ->\n    throw err if err\n    throw Error 'User crontab not found' if /^no crontab for/.test stderr\n    myjob = if options.when then regexp.escape options.when else '.*'\n    myjob += regexp.escape \" #{options.cmd}\"\n    regex = new RegExp myjob\n    jobs = stdout.trim().split '\\n'\n    for job, i in jobs\n      continue unless regex.test job\n      options.log message: \"Job '#{job}' matches. Removing from list\", level: 'WARN', module: 'nikita/cron/remove'\n      status = true\n      jobs.splice i, 1\n    options.log message: \"No Job matches. Skipping\", level: 'INFO', module: 'nikita/cron/remove'\n  .system.execute\n    cmd: \"\"\"\n    #{crontab} - <<EOF\n    #{jobs.join '\\n'}\n    EOF\n    \"\"\"\n    if: -> status\n  .next callback",
            "title": "Source Code"
        },
        {
            "location": "/cron/remove.coffee/#dependencies",
            "text": "{regexp} = require '../misc'\nwrap = require '../misc/wrap'",
            "title": "Dependencies"
        },
        {
            "location": "/db/database/exists.coffee/",
            "text": "nikita.db.database.exists(options, callback)\n\n\nCheck if a database exists.\n\n\nOptions\n\n\n\n\nadmin_username\n \n\n  The login of the database administrator.   \n\n\nadmin_password\n \n\n  The password of the database administrator.   \n\n\ndatabase\n (String) \n\n  The database name to check for existance.   \n\n\nengine\n \n\n  The engine type, can be MySQL or PostgreSQL, default to MySQL.   \n\n\nhost\n \n\n  The hostname of the database.   \n\n\nport\n \n\n  Port to the associated database.   \n\n\nusername\n \n\n  The username of a user with privileges on the database, used unless admin_username is provided.   \n\n\npassword\n \n\n  The password of a user with privileges on the database, used unless admin_password is provided.   \n\n\n\n\nSource Code\n\n\nmodule.exports = shy: true, handler: (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  options.database ?= options.argument\n  # Check main options\n  throw Error 'Missing option: \"host\"' unless options.host\n  throw Error 'Missing option: \"username\" or \"admin_username\"' unless options.admin_username or options.username\n  throw Error 'Missing option: \"admin_password\"' if options.admin_username and not options.admin_password\n  throw Error 'Missing option: \"password\"' if options.username and not options.password\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  # Defines and check the engine type\n  options.engine = options.engine.toLowerCase()\n  throw Error \"Unsupport engine: #{JSON.stringify options.engine}\" unless options.engine in ['mariadb', 'mysql', 'postgresql']\n  # Defines port\n  options.port ?= 5432\n  cmd = switch options.engine\n    when 'mariadb', 'mysql'\n      db.cmd(options, database: 'mysql', \"SHOW DATABASES\") + \" | grep -w '#{options.database}'\"\n    when 'postgresql'\n      # Not sure why we're not using \\l\n      db.cmd(options, \"SELECT datname FROM pg_database WHERE datname = '#{options.database}'\") + \" | grep -w '#{options.database}'\"\n  @system.execute\n    cmd: cmd\n    code_skipped: 1\n\n\n\nDependencies\n\n\ndb = require '../../misc/db'",
            "title": "Exists.coffee"
        },
        {
            "location": "/db/database/exists.coffee/#nikitadbdatabaseexistsoptions-callback",
            "text": "Check if a database exists.",
            "title": "nikita.db.database.exists(options, callback)"
        },
        {
            "location": "/db/database/exists.coffee/#options",
            "text": "admin_username   \n  The login of the database administrator.     admin_password   \n  The password of the database administrator.     database  (String)  \n  The database name to check for existance.     engine   \n  The engine type, can be MySQL or PostgreSQL, default to MySQL.     host   \n  The hostname of the database.     port   \n  Port to the associated database.     username   \n  The username of a user with privileges on the database, used unless admin_username is provided.     password   \n  The password of a user with privileges on the database, used unless admin_password is provided.",
            "title": "Options"
        },
        {
            "location": "/db/database/exists.coffee/#source-code",
            "text": "module.exports = shy: true, handler: (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  options.database ?= options.argument\n  # Check main options\n  throw Error 'Missing option: \"host\"' unless options.host\n  throw Error 'Missing option: \"username\" or \"admin_username\"' unless options.admin_username or options.username\n  throw Error 'Missing option: \"admin_password\"' if options.admin_username and not options.admin_password\n  throw Error 'Missing option: \"password\"' if options.username and not options.password\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  # Defines and check the engine type\n  options.engine = options.engine.toLowerCase()\n  throw Error \"Unsupport engine: #{JSON.stringify options.engine}\" unless options.engine in ['mariadb', 'mysql', 'postgresql']\n  # Defines port\n  options.port ?= 5432\n  cmd = switch options.engine\n    when 'mariadb', 'mysql'\n      db.cmd(options, database: 'mysql', \"SHOW DATABASES\") + \" | grep -w '#{options.database}'\"\n    when 'postgresql'\n      # Not sure why we're not using \\l\n      db.cmd(options, \"SELECT datname FROM pg_database WHERE datname = '#{options.database}'\") + \" | grep -w '#{options.database}'\"\n  @system.execute\n    cmd: cmd\n    code_skipped: 1",
            "title": "Source Code"
        },
        {
            "location": "/db/database/exists.coffee/#dependencies",
            "text": "db = require '../../misc/db'",
            "title": "Dependencies"
        },
        {
            "location": "/db/database/index.coffee/",
            "text": "nikita.db.database(options, callback)\n\n\nCreate a database for the destination database.\n\n\nOptions\n\n\n\n\nadmin_username\n \n\n  The login of the database administrator.   \n\n\nadmin_password\n \n\n  The password of the database administrator.   \n\n\ndatabase\n (Array or String) \n\n  The database name(s) to which the user should be added.   \n\n\nengine\n \n\n  The engine type, can be MySQL or PostgreSQL, required.   \n\n\nhost\n \n\n  The hostname of the database.   \n\n\nport\n \n\n  Port to the associated database.   \n\n\nuser\n (Array or String) \n\n  Contains  user(s) to add to the database, optional.   \n\n\n\n\nThis user will be granted superuser permissions (see above) for the database specified\n\n\nCreate Database example\n\n\nrequire('nikita').database.db({\n  admin_username: 'test',\n  admin_password: 'test',\n  database: 'my_db',\n}, function(err, status){\n  console.log(err ? err.message : 'Database created or modified: ' + status);\n});\n\n\n\n\nRun the tests\n\n\ncd docker/centos6\n# then\ndocker-compose run --rm nodejs test/db/database.coffee\n# or\ndocker-compose run --rm nodejs\nnpm test test/db/database.coffee\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  options.database ?= options.argument\n  # Validate options\n  throw Error 'Missing option: \"host\"' unless options.host\n  throw Error 'Missing option: \"admin_username\"' unless options.admin_username\n  throw Error 'Missing option: \"admin_password\"' unless options.admin_password\n  throw Error 'Missing option: \"database\"' unless options.database\n  throw Error 'Missing option: \"engine\"' unless options.engine\n  options.user ?= []\n  options.user = [options.user] if typeof options.user is 'string'\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  # Defines and check the engine type\n  options.engine = options.engine.toLowerCase()\n  throw Error \"Unsupport engine: #{JSON.stringify options.engine}\" unless options.engine in ['mariadb', 'mysql', 'postgresql']\n  options.log message: \"Database engine set to #{options.engine}\", level: 'INFO', module: 'nikita/db/database'\n  # Default values\n  options.port ?= 5432\n  # Create database unless exist\n  options.log message: \"Check if database #{options.database} exists\", level: 'DEBUG', module: 'nikita/db/database'\n  switch options.engine\n    when 'mariadb', 'mysql'\n      cmd_database_create = db.cmd options, database: null, \"CREATE DATABASE #{options.database} DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;\"\n      cmd_database_exists = db.cmd options, database: options.database, \"USE #{options.database};\"\n    when 'postgresql'\n      cmd_database_create = db.cmd options, database: null, \"CREATE DATABASE #{options.database};\"\n      cmd_database_exists = db.cmd options, database: options.database, \"\\\\dt\"\n  @system.execute\n    cmd: cmd_database_create\n    unless_exec: cmd_database_exists\n  , (err, status) ->\n    options.log message: \"Database created: #{JSON.stringify options.database}\", level: 'WARN', module: 'nikita/db/database' if status\n  for user in options.user then do =>\n    @call -> options.log message: \"Check if user #{user} has PRIVILEGES on #{options.database} \", level: 'DEBUG', module: 'nikita/db/database'     \n    @db.user.exists\n      engine: options.engine\n      username: user\n      admin_username: options.admin_username\n      admin_password: options.admin_password\n      port: options.port\n      host: options.host\n    , (err, exists) ->\n      throw Error \"DB user does not exists: #{user}\" if not err and not exists\n    switch options.engine\n      when 'mariadb', 'mysql'\n        # cmd_has_privileges = db.cmd options, admin_username: null, username: user.username, password: user.password, database: options.database, \"SHOW TABLES FROM pg_database\"\n        cmd_has_privileges = db.cmd(options, database: 'mysql', \"SELECT user FROM db WHERE db='#{options.database}';\") + \" | grep '#{user}'\"\n        cmd_grant_privileges = db.cmd options, database: null, \"GRANT ALL PRIVILEGES ON #{options.database}.* TO '#{user}' WITH GRANT OPTION;\" # FLUSH PRIVILEGES;\n      when 'postgresql'\n        cmd_has_privileges = db.cmd(options, database: options.database, \"\\\\l\") + \" | egrep '^#{user}='\"\n        cmd_grant_privileges = db.cmd options, database: null, \"GRANT ALL PRIVILEGES ON DATABASE #{options.database} TO #{user}\"\n    @system.execute\n      cmd: \"\"\"\n      if #{cmd_has_privileges}; then\n        echo '[INFO] User already with privileges'\n        exit 3\n      fi\n      echo '[WARN] User privileges granted'\n      #{cmd_grant_privileges}\n      \"\"\"\n      code_skipped: 3\n    , (err, status, stdout, stderr) ->\n      options.log message: \"Privileges granted: to #{JSON.stringify user} on #{JSON.stringify options.database}\", level: 'WARN', module: 'nikita/db/database' if status\n\n\n\nDependencies\n\n\ndb = require '../../misc/db'",
            "title": "Index.coffee"
        },
        {
            "location": "/db/database/index.coffee/#nikitadbdatabaseoptions-callback",
            "text": "Create a database for the destination database.",
            "title": "nikita.db.database(options, callback)"
        },
        {
            "location": "/db/database/index.coffee/#options",
            "text": "admin_username   \n  The login of the database administrator.     admin_password   \n  The password of the database administrator.     database  (Array or String)  \n  The database name(s) to which the user should be added.     engine   \n  The engine type, can be MySQL or PostgreSQL, required.     host   \n  The hostname of the database.     port   \n  Port to the associated database.     user  (Array or String)  \n  Contains  user(s) to add to the database, optional.      This user will be granted superuser permissions (see above) for the database specified",
            "title": "Options"
        },
        {
            "location": "/db/database/index.coffee/#create-database-example",
            "text": "require('nikita').database.db({\n  admin_username: 'test',\n  admin_password: 'test',\n  database: 'my_db',\n}, function(err, status){\n  console.log(err ? err.message : 'Database created or modified: ' + status);\n});",
            "title": "Create Database example"
        },
        {
            "location": "/db/database/index.coffee/#run-the-tests",
            "text": "cd docker/centos6\n# then\ndocker-compose run --rm nodejs test/db/database.coffee\n# or\ndocker-compose run --rm nodejs\nnpm test test/db/database.coffee",
            "title": "Run the tests"
        },
        {
            "location": "/db/database/index.coffee/#source-code",
            "text": "module.exports = (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  options.database ?= options.argument\n  # Validate options\n  throw Error 'Missing option: \"host\"' unless options.host\n  throw Error 'Missing option: \"admin_username\"' unless options.admin_username\n  throw Error 'Missing option: \"admin_password\"' unless options.admin_password\n  throw Error 'Missing option: \"database\"' unless options.database\n  throw Error 'Missing option: \"engine\"' unless options.engine\n  options.user ?= []\n  options.user = [options.user] if typeof options.user is 'string'\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  # Defines and check the engine type\n  options.engine = options.engine.toLowerCase()\n  throw Error \"Unsupport engine: #{JSON.stringify options.engine}\" unless options.engine in ['mariadb', 'mysql', 'postgresql']\n  options.log message: \"Database engine set to #{options.engine}\", level: 'INFO', module: 'nikita/db/database'\n  # Default values\n  options.port ?= 5432\n  # Create database unless exist\n  options.log message: \"Check if database #{options.database} exists\", level: 'DEBUG', module: 'nikita/db/database'\n  switch options.engine\n    when 'mariadb', 'mysql'\n      cmd_database_create = db.cmd options, database: null, \"CREATE DATABASE #{options.database} DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;\"\n      cmd_database_exists = db.cmd options, database: options.database, \"USE #{options.database};\"\n    when 'postgresql'\n      cmd_database_create = db.cmd options, database: null, \"CREATE DATABASE #{options.database};\"\n      cmd_database_exists = db.cmd options, database: options.database, \"\\\\dt\"\n  @system.execute\n    cmd: cmd_database_create\n    unless_exec: cmd_database_exists\n  , (err, status) ->\n    options.log message: \"Database created: #{JSON.stringify options.database}\", level: 'WARN', module: 'nikita/db/database' if status\n  for user in options.user then do =>\n    @call -> options.log message: \"Check if user #{user} has PRIVILEGES on #{options.database} \", level: 'DEBUG', module: 'nikita/db/database'     \n    @db.user.exists\n      engine: options.engine\n      username: user\n      admin_username: options.admin_username\n      admin_password: options.admin_password\n      port: options.port\n      host: options.host\n    , (err, exists) ->\n      throw Error \"DB user does not exists: #{user}\" if not err and not exists\n    switch options.engine\n      when 'mariadb', 'mysql'\n        # cmd_has_privileges = db.cmd options, admin_username: null, username: user.username, password: user.password, database: options.database, \"SHOW TABLES FROM pg_database\"\n        cmd_has_privileges = db.cmd(options, database: 'mysql', \"SELECT user FROM db WHERE db='#{options.database}';\") + \" | grep '#{user}'\"\n        cmd_grant_privileges = db.cmd options, database: null, \"GRANT ALL PRIVILEGES ON #{options.database}.* TO '#{user}' WITH GRANT OPTION;\" # FLUSH PRIVILEGES;\n      when 'postgresql'\n        cmd_has_privileges = db.cmd(options, database: options.database, \"\\\\l\") + \" | egrep '^#{user}='\"\n        cmd_grant_privileges = db.cmd options, database: null, \"GRANT ALL PRIVILEGES ON DATABASE #{options.database} TO #{user}\"\n    @system.execute\n      cmd: \"\"\"\n      if #{cmd_has_privileges}; then\n        echo '[INFO] User already with privileges'\n        exit 3\n      fi\n      echo '[WARN] User privileges granted'\n      #{cmd_grant_privileges}\n      \"\"\"\n      code_skipped: 3\n    , (err, status, stdout, stderr) ->\n      options.log message: \"Privileges granted: to #{JSON.stringify user} on #{JSON.stringify options.database}\", level: 'WARN', module: 'nikita/db/database' if status",
            "title": "Source Code"
        },
        {
            "location": "/db/database/index.coffee/#dependencies",
            "text": "db = require '../../misc/db'",
            "title": "Dependencies"
        },
        {
            "location": "/db/database/remove.coffee/",
            "text": "nikita.db.database.remove(options, callback)\n\n\nCreate a user for the destination database.\n\n\nOptions\n\n\n\n\nadmin_username\n \n\n  The login of the database administrator.   \n\n\nadmin_password\n \n\n  The password of the database administrator.   \n\n\nengine\n \n\n  The engine type, can be MySQL or PostgreSQL. Default to MySQL   \n\n\nhost\n \n\n  The hostname of the database   \n\n\ndatabase\n \n\n  The database to be removed.   \n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  options.database ?= options.argument\n  throw Error 'Missing option: \"admin_username\"' unless options.admin_username\n  throw Error 'Missing option: \"admin_password\"' unless options.admin_password\n  # Avoid Postgres error \"ERROR:  cannot drop the currently open database\"\n  database = options.database\n  delete options.database\n  @system.execute\n    cmd: db.cmd options, \"DROP DATABASE IF EXISTS #{database};\"\n    code_skipped: 2\n\n\n\nDependencies\n\n\ndb = require '../../misc/db'",
            "title": "Remove.coffee"
        },
        {
            "location": "/db/database/remove.coffee/#nikitadbdatabaseremoveoptions-callback",
            "text": "Create a user for the destination database.",
            "title": "nikita.db.database.remove(options, callback)"
        },
        {
            "location": "/db/database/remove.coffee/#options",
            "text": "admin_username   \n  The login of the database administrator.     admin_password   \n  The password of the database administrator.     engine   \n  The engine type, can be MySQL or PostgreSQL. Default to MySQL     host   \n  The hostname of the database     database   \n  The database to be removed.",
            "title": "Options"
        },
        {
            "location": "/db/database/remove.coffee/#source-code",
            "text": "module.exports = (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  options.database ?= options.argument\n  throw Error 'Missing option: \"admin_username\"' unless options.admin_username\n  throw Error 'Missing option: \"admin_password\"' unless options.admin_password\n  # Avoid Postgres error \"ERROR:  cannot drop the currently open database\"\n  database = options.database\n  delete options.database\n  @system.execute\n    cmd: db.cmd options, \"DROP DATABASE IF EXISTS #{database};\"\n    code_skipped: 2",
            "title": "Source Code"
        },
        {
            "location": "/db/database/remove.coffee/#dependencies",
            "text": "db = require '../../misc/db'",
            "title": "Dependencies"
        },
        {
            "location": "/db/database/wait.coffee/",
            "text": "nikita.db.database.wait(options, callback)\n\n\nWait for the creation of a database.\n\n\nOptions\n\n\n\n\nadmin_username\n \n\n  The login of the database administrator.   \n\n\nadmin_password\n \n\n  The password of the database administrator.   \n\n\ndatabase\n (Array or String) \n\n  The database name to check for existance.   \n\n\nengine\n \n\n  The engine type, can be MySQL or PostgreSQL, required.   \n\n\nhost\n \n\n  The hostname of the database.   \n\n\nport\n \n\n  Port to the associated database.   \n\n\nuser\n Array or String \n\n  Contains  user(s) to add to the database, optional.   \n\n\n\n\nCreate Database example\n\n\nrequire('nikita').database.db.wait({\n  admin_username: 'test',\n  admin_password: 'test',\n  database: 'my_db',\n}, function(err, status){\n  console.log(err ? err.message : 'Did database existed initially: ' + status);\n});\n\n\n\n\nRun the tests\n\n\ncd docker/centos6\n# then\ndocker-compose run --rm nodejs test/db/database.coffee\n# or\ndocker-compose run --rm nodejs\nnpm test test/db/database.coffee\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  options.database ?= options.argument\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  # Defines and check the engine type\n  options.engine = options.engine.toLowerCase()\n  throw Error \"Unsupport engine: #{JSON.stringify options.engine}\" unless options.engine in ['mariadb', 'mysql', 'postgresql']\n  # Command\n  @wait.execute\n    cmd: switch options.engine\n      when 'mariadb', 'mysql'\n        db.cmd(options, database: null, \"show databases\") + \" | grep '#{options.database}'\"\n      when 'postgresql'\n        db.cmd(options, database: null, null) + \" -l | cut -d \\\\| -f 1 | grep -qw '#{options.database}'\"\n\n\n\nDependencies\n\n\ndb = require '../../misc/db'",
            "title": "Wait.coffee"
        },
        {
            "location": "/db/database/wait.coffee/#nikitadbdatabasewaitoptions-callback",
            "text": "Wait for the creation of a database.",
            "title": "nikita.db.database.wait(options, callback)"
        },
        {
            "location": "/db/database/wait.coffee/#options",
            "text": "admin_username   \n  The login of the database administrator.     admin_password   \n  The password of the database administrator.     database  (Array or String)  \n  The database name to check for existance.     engine   \n  The engine type, can be MySQL or PostgreSQL, required.     host   \n  The hostname of the database.     port   \n  Port to the associated database.     user  Array or String  \n  Contains  user(s) to add to the database, optional.",
            "title": "Options"
        },
        {
            "location": "/db/database/wait.coffee/#create-database-example",
            "text": "require('nikita').database.db.wait({\n  admin_username: 'test',\n  admin_password: 'test',\n  database: 'my_db',\n}, function(err, status){\n  console.log(err ? err.message : 'Did database existed initially: ' + status);\n});",
            "title": "Create Database example"
        },
        {
            "location": "/db/database/wait.coffee/#run-the-tests",
            "text": "cd docker/centos6\n# then\ndocker-compose run --rm nodejs test/db/database.coffee\n# or\ndocker-compose run --rm nodejs\nnpm test test/db/database.coffee",
            "title": "Run the tests"
        },
        {
            "location": "/db/database/wait.coffee/#source-code",
            "text": "module.exports = (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  options.database ?= options.argument\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  # Defines and check the engine type\n  options.engine = options.engine.toLowerCase()\n  throw Error \"Unsupport engine: #{JSON.stringify options.engine}\" unless options.engine in ['mariadb', 'mysql', 'postgresql']\n  # Command\n  @wait.execute\n    cmd: switch options.engine\n      when 'mariadb', 'mysql'\n        db.cmd(options, database: null, \"show databases\") + \" | grep '#{options.database}'\"\n      when 'postgresql'\n        db.cmd(options, database: null, null) + \" -l | cut -d \\\\| -f 1 | grep -qw '#{options.database}'\"",
            "title": "Source Code"
        },
        {
            "location": "/db/database/wait.coffee/#dependencies",
            "text": "db = require '../../misc/db'",
            "title": "Dependencies"
        },
        {
            "location": "/db/schema/index.coffee/",
            "text": "nikita.db.schema(options, callback)\n\n\nCreate a database for the destination database.\n\n\nOptions\n\n\n\n\nadmin_username\n \n\n  The login of the database administrator.   \n\n\nadmin_password\n \n\n  The password of the database administrator.   \n\n\ndatabase\n (String) \n\n  The database name where the schema is created.\n\n\nengine\n \n\n  The engine type, can be MySQL or PostgreSQL. Default to MySQL   \n\n\nhost\n \n\n  The hostname of the database   \n\n\nport\n \n\n  Port to the associated database   \n\n\nschema\n \n\n  New schema name.   \n\n\nowner\n Array or String \n\n  The Schema owner. Alter Schema if schema already exists.   \n\n\n\n\nCreate Schema example\n\n\nrequire('nikita').database.schema({\n  admin_username: 'test',\n  admin_password: 'test',\n  database: 'my_db',\n}, function(err, modified){\n  console.log(err ? err.message : 'Principal created or modified: ' + !!modified);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  # Check main options\n  throw Error 'Missing option: \"host\"' unless options.host\n  throw Error 'Missing option: \"admin_username\"' unless options.admin_username\n  throw Error 'Missing option: \"admin_password\"' unless options.admin_password\n  throw Error 'Missing option: \"database\"' unless options.database\n  throw Error 'Missing option: \"engine\"' unless options.engine\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  # Defines and check the engine type \n  options.engine = options.engine.toLowerCase()\n  throw Error \"Unsupport engine: #{JSON.stringify options.engine}\" unless options.engine in ['postgresql']\n  # Options\n  options.port ?= 5432\n  @system.execute\n    code_skipped: 2\n    cmd: db.cmd options, '\\\\dt'\n  , (err, status, stdout, stderr) ->\n    throw err if err\n    throw Error \"Database does not exist #{options.database}\" if !err and !status\n  @system.execute\n    cmd: db.cmd options, \"CREATE SCHEMA #{options.schema};\"\n    unless_exec: db.cmd(options, \"SELECT 1 FROM pg_namespace WHERE nspname = '#{options.schema}';\") + \" | grep 1\"\n  # Check if owner is the good one\n  @system.execute\n    if: -> options.owner?\n    unless_exec: db.cmd(options, '\\\\dn') + \" | grep '#{options.schema}|#{options.owner}'\"\n    cmd: db.cmd options, \"ALTER SCHEMA #{options.schema} OWNER TO #{options.owner};\"\n    code_skipped: 1\n  , (err, status , stdout, stderr) ->\n    throw Error \"Owner #{options.owner} does not exists\" if /^ERROR:\\s\\srole.*does\\snot\\sexist/.test stderr\n\n\n\nDependencies\n\n\ndb = require '../../misc/db'",
            "title": "Index.coffee"
        },
        {
            "location": "/db/schema/index.coffee/#nikitadbschemaoptions-callback",
            "text": "Create a database for the destination database.",
            "title": "nikita.db.schema(options, callback)"
        },
        {
            "location": "/db/schema/index.coffee/#options",
            "text": "admin_username   \n  The login of the database administrator.     admin_password   \n  The password of the database administrator.     database  (String)  \n  The database name where the schema is created.  engine   \n  The engine type, can be MySQL or PostgreSQL. Default to MySQL     host   \n  The hostname of the database     port   \n  Port to the associated database     schema   \n  New schema name.     owner  Array or String  \n  The Schema owner. Alter Schema if schema already exists.",
            "title": "Options"
        },
        {
            "location": "/db/schema/index.coffee/#create-schema-example",
            "text": "require('nikita').database.schema({\n  admin_username: 'test',\n  admin_password: 'test',\n  database: 'my_db',\n}, function(err, modified){\n  console.log(err ? err.message : 'Principal created or modified: ' + !!modified);\n});",
            "title": "Create Schema example"
        },
        {
            "location": "/db/schema/index.coffee/#source-code",
            "text": "module.exports = (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  # Check main options\n  throw Error 'Missing option: \"host\"' unless options.host\n  throw Error 'Missing option: \"admin_username\"' unless options.admin_username\n  throw Error 'Missing option: \"admin_password\"' unless options.admin_password\n  throw Error 'Missing option: \"database\"' unless options.database\n  throw Error 'Missing option: \"engine\"' unless options.engine\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  # Defines and check the engine type \n  options.engine = options.engine.toLowerCase()\n  throw Error \"Unsupport engine: #{JSON.stringify options.engine}\" unless options.engine in ['postgresql']\n  # Options\n  options.port ?= 5432\n  @system.execute\n    code_skipped: 2\n    cmd: db.cmd options, '\\\\dt'\n  , (err, status, stdout, stderr) ->\n    throw err if err\n    throw Error \"Database does not exist #{options.database}\" if !err and !status\n  @system.execute\n    cmd: db.cmd options, \"CREATE SCHEMA #{options.schema};\"\n    unless_exec: db.cmd(options, \"SELECT 1 FROM pg_namespace WHERE nspname = '#{options.schema}';\") + \" | grep 1\"\n  # Check if owner is the good one\n  @system.execute\n    if: -> options.owner?\n    unless_exec: db.cmd(options, '\\\\dn') + \" | grep '#{options.schema}|#{options.owner}'\"\n    cmd: db.cmd options, \"ALTER SCHEMA #{options.schema} OWNER TO #{options.owner};\"\n    code_skipped: 1\n  , (err, status , stdout, stderr) ->\n    throw Error \"Owner #{options.owner} does not exists\" if /^ERROR:\\s\\srole.*does\\snot\\sexist/.test stderr",
            "title": "Source Code"
        },
        {
            "location": "/db/schema/index.coffee/#dependencies",
            "text": "db = require '../../misc/db'",
            "title": "Dependencies"
        },
        {
            "location": "/db/schema/remove.coffee/",
            "text": "nikita.db.schema.remove\n\n\nCreate a user for the destination database.\n\n\nOptions\n\n\n\n\nadmin_username\n \n\n  The login of the database administrator. It should have credentials to \n  create accounts.   \n\n\nadmin_password\n \n\n  The password of the database administrator.   \n\n\nengine\n \n\n  The engine type, can be MySQL or PostgreSQL, default to MySQL.   \n\n\nhost\n \n\n  The hostname of the database.   \n\n\nschema\n \n\n  New schema name.   \n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  # Options\n  options.schema ?= options.argument\n  throw Error 'Missing option: \"engine\"' unless options.engine\n  throw Error 'Missing option: \"schema\"' unless options.schema\n  throw Error 'Missing option: \"admin_username\"' unless options.admin_username\n  throw Error 'Missing option: \"admin_password\"' unless options.admin_password\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  # Defines and check the engine type \n  options.engine = options.engine.toLowerCase()\n  throw Error \"Unsupport engine: #{JSON.stringify options.engine}\" unless options.engine in ['postgresql']\n  @system.execute\n    cmd: db.cmd options, \"DROP SCHEMA IF EXISTS #{options.schema};\"\n\n\n\nDependencies\n\n\ndb = require '../../misc/db'",
            "title": "Remove.coffee"
        },
        {
            "location": "/db/schema/remove.coffee/#nikitadbschemaremove",
            "text": "Create a user for the destination database.",
            "title": "nikita.db.schema.remove"
        },
        {
            "location": "/db/schema/remove.coffee/#options",
            "text": "admin_username   \n  The login of the database administrator. It should have credentials to \n  create accounts.     admin_password   \n  The password of the database administrator.     engine   \n  The engine type, can be MySQL or PostgreSQL, default to MySQL.     host   \n  The hostname of the database.     schema   \n  New schema name.",
            "title": "Options"
        },
        {
            "location": "/db/schema/remove.coffee/#source-code",
            "text": "module.exports = (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  # Options\n  options.schema ?= options.argument\n  throw Error 'Missing option: \"engine\"' unless options.engine\n  throw Error 'Missing option: \"schema\"' unless options.schema\n  throw Error 'Missing option: \"admin_username\"' unless options.admin_username\n  throw Error 'Missing option: \"admin_password\"' unless options.admin_password\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  # Defines and check the engine type \n  options.engine = options.engine.toLowerCase()\n  throw Error \"Unsupport engine: #{JSON.stringify options.engine}\" unless options.engine in ['postgresql']\n  @system.execute\n    cmd: db.cmd options, \"DROP SCHEMA IF EXISTS #{options.schema};\"",
            "title": "Source Code"
        },
        {
            "location": "/db/schema/remove.coffee/#dependencies",
            "text": "db = require '../../misc/db'",
            "title": "Dependencies"
        },
        {
            "location": "/db/user/exists.coffee/",
            "text": "nikita.db.user.exists(options, callback)\n\n\nCheck if a user exists in the database.\n\n\nOptions\n\n\n\n\nadmin_username\n \n\n  The login of the database administrator. It should have credentials to \n  create accounts.   \n\n\nadmin_password\n \n\n  The password of the database administrator.   \n\n\ndatabase\n (String) \n\n  The database name to which the user should be added.   \n\n\nengine\n \n\n  The engine type, can be MySQL or PostgreSQL, default to MySQL.   \n\n\nhost\n \n\n  The hostname of the database.   \n\n\nusername\n \n\n  The new user name.   \n\n\npassword\n \n\n  The new user password.   \n\n\nport\n \n\n  Port to the associated database.   \n\n\nuser\n (String) \n\n  User name.   \n\n\n\n\nSource Code\n\n\nmodule.exports = shy: true, handler: (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  # Check main options\n  throw Error 'Missing option: \"hostname\"' unless options.host\n  throw Error 'Missing option: \"admin_username\"' unless options.admin_username\n  throw Error 'Missing option: \"admin_password\"' unless options.admin_password\n  throw Error 'Missing option: \"username\"' unless options.username\n  throw Error 'Missing option: \"engine\"' unless options.engine\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  # Defines and check the engine type\n  options.engine = options.engine.toLowerCase()\n  throw Error \"Unsupport engine: #{JSON.stringify options.engine}\" unless options.engine in ['mariadb', 'mysql', 'postgresql']\n  # Defines port\n  options.port ?= 5432\n  cmd = switch options.engine\n    when 'mariadb', 'mysql'\n      db.cmd(options, database: 'mysql', \"select User from user where User = '#{options.username}'\") + \" | grep '#{options.username}'\"\n    when 'postgresql'\n      # Not sure why we're not using du\n      db.cmd(options, \"SELECT 1 FROM pg_roles WHERE rolname='#{options.username}'\") + \" | grep 1\"\n  @system.execute\n    cmd: cmd\n    code_skipped: 1\n\n\n\nDependencies\n\n\ndb = require '../../misc/db'",
            "title": "Exists.coffee"
        },
        {
            "location": "/db/user/exists.coffee/#nikitadbuserexistsoptions-callback",
            "text": "Check if a user exists in the database.",
            "title": "nikita.db.user.exists(options, callback)"
        },
        {
            "location": "/db/user/exists.coffee/#options",
            "text": "admin_username   \n  The login of the database administrator. It should have credentials to \n  create accounts.     admin_password   \n  The password of the database administrator.     database  (String)  \n  The database name to which the user should be added.     engine   \n  The engine type, can be MySQL or PostgreSQL, default to MySQL.     host   \n  The hostname of the database.     username   \n  The new user name.     password   \n  The new user password.     port   \n  Port to the associated database.     user  (String)  \n  User name.",
            "title": "Options"
        },
        {
            "location": "/db/user/exists.coffee/#source-code",
            "text": "module.exports = shy: true, handler: (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  # Check main options\n  throw Error 'Missing option: \"hostname\"' unless options.host\n  throw Error 'Missing option: \"admin_username\"' unless options.admin_username\n  throw Error 'Missing option: \"admin_password\"' unless options.admin_password\n  throw Error 'Missing option: \"username\"' unless options.username\n  throw Error 'Missing option: \"engine\"' unless options.engine\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  # Defines and check the engine type\n  options.engine = options.engine.toLowerCase()\n  throw Error \"Unsupport engine: #{JSON.stringify options.engine}\" unless options.engine in ['mariadb', 'mysql', 'postgresql']\n  # Defines port\n  options.port ?= 5432\n  cmd = switch options.engine\n    when 'mariadb', 'mysql'\n      db.cmd(options, database: 'mysql', \"select User from user where User = '#{options.username}'\") + \" | grep '#{options.username}'\"\n    when 'postgresql'\n      # Not sure why we're not using du\n      db.cmd(options, \"SELECT 1 FROM pg_roles WHERE rolname='#{options.username}'\") + \" | grep 1\"\n  @system.execute\n    cmd: cmd\n    code_skipped: 1",
            "title": "Source Code"
        },
        {
            "location": "/db/user/exists.coffee/#dependencies",
            "text": "db = require '../../misc/db'",
            "title": "Dependencies"
        },
        {
            "location": "/db/user/index.coffee/",
            "text": "nikita.db.user(options, callback)\n\n\nCreate a user for the destination database.\n\n\nOptions\n\n\n\n\nadmin_username\n \n\n  The login of the database administrator. It should have credentials to \n  create accounts.   \n\n\nadmin_password\n \n\n  The password of the database administrator.   \n\n\ndb\n (Array or String) \n\n  The database name(s) to which the user should be added.   \n\n\nengine\n \n\n  The engine type, can be MySQL or PostgreSQL, default to MySQL.   \n\n\nhost\n \n\n  The hostname of the database.   \n\n\nusername\n \n\n  The new user name.   \n\n\npassword\n \n\n  The new user password.   \n\n\nport\n \n\n  Port to the associated database.   \n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  # Validate options\n  throw Error 'Missing option: \"host\"' unless options.host\n  throw Error 'Missing option: \"admin_username\"' unless options.admin_username\n  throw Error 'Missing option: \"admin_password\"' unless options.admin_password\n  throw Error 'Missing option: \"username\"' unless options.username\n  throw Error 'Missing option: \"password\"' unless options.password\n  throw Error 'Missing option: \"engine\"' unless options.engine\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  # Defines and check the engine type\n  options.engine = options.engine.toLowerCase()\n  throw Error \"Unsupport engine: #{JSON.stringify options.engine}\" unless options.engine in ['mariadb', 'mysql', 'postgresql']\n  # Default values\n  options.port ?= 5432\n  # Commands\n  switch options.engine\n    when 'mariadb', 'mysql'\n      cmd_user_exists = db.cmd(options, \"SELECT User FROM mysql.user WHERE User='#{options.username}'\") + \" | grep #{options.username}\"\n      cmd_user_create = db.cmd options, \"CREATE USER #{options.username} IDENTIFIED BY '#{options.password}';\"\n      cmd_password_is_invalid = db.cmd(options, admin_username: null, admin_password: null, '\\\\dt') + \" 2>&1 >/dev/null | grep -e '^ERROR 1045.*'\"\n      cmd_password_change = db.cmd options, \"SET PASSWORD FOR #{options.username} = PASSWORD ('#{options.password}');\"\n    when 'postgresql'\n      cmd_user_exists = db.cmd(options, \"SELECT 1 FROM pg_roles WHERE rolname='#{options.username}'\") + \" | grep 1\"\n      cmd_user_create = db.cmd options, \"CREATE USER #{options.username} WITH PASSWORD '#{options.password}';\"\n      cmd_password_is_invalid = db.cmd(options, admin_username: null, admin_password: null, '\\\\dt') + \" 2>&1 >/dev/null | grep -e '^psql:\\\\sFATAL.*password\\\\sauthentication\\\\sfailed\\\\sfor\\\\suser.*'\"\n      cmd_password_change = db.cmd options, \"ALTER USER #{options.username} WITH PASSWORD '#{options.password}';\"\n  @system.execute\n    cmd: \"\"\"\n    signal=3\n    if #{cmd_user_exists}; then\n      echo '[INFO] User already exists'\n    else\n      #{cmd_user_create}\n      echo '[WARN] User created'\n      signal=0\n    fi\n    if [ $signal -eq 3 ]; then\n      if ! #{cmd_password_is_invalid}; then\n        echo '[INFO] Password not modified'\n      else\n        #{cmd_password_change}\n        echo '[WARN] Password modified'\n        signal=0\n      fi\n    fi\n    exit $signal\n    \"\"\"\n    code_skipped: 3\n    trap: true\n\n\n\nDependencies\n\n\ndb = require '../../misc/db'",
            "title": "Index.coffee"
        },
        {
            "location": "/db/user/index.coffee/#nikitadbuseroptions-callback",
            "text": "Create a user for the destination database.",
            "title": "nikita.db.user(options, callback)"
        },
        {
            "location": "/db/user/index.coffee/#options",
            "text": "admin_username   \n  The login of the database administrator. It should have credentials to \n  create accounts.     admin_password   \n  The password of the database administrator.     db  (Array or String)  \n  The database name(s) to which the user should be added.     engine   \n  The engine type, can be MySQL or PostgreSQL, default to MySQL.     host   \n  The hostname of the database.     username   \n  The new user name.     password   \n  The new user password.     port   \n  Port to the associated database.",
            "title": "Options"
        },
        {
            "location": "/db/user/index.coffee/#source-code",
            "text": "module.exports = (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  # Validate options\n  throw Error 'Missing option: \"host\"' unless options.host\n  throw Error 'Missing option: \"admin_username\"' unless options.admin_username\n  throw Error 'Missing option: \"admin_password\"' unless options.admin_password\n  throw Error 'Missing option: \"username\"' unless options.username\n  throw Error 'Missing option: \"password\"' unless options.password\n  throw Error 'Missing option: \"engine\"' unless options.engine\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  # Defines and check the engine type\n  options.engine = options.engine.toLowerCase()\n  throw Error \"Unsupport engine: #{JSON.stringify options.engine}\" unless options.engine in ['mariadb', 'mysql', 'postgresql']\n  # Default values\n  options.port ?= 5432\n  # Commands\n  switch options.engine\n    when 'mariadb', 'mysql'\n      cmd_user_exists = db.cmd(options, \"SELECT User FROM mysql.user WHERE User='#{options.username}'\") + \" | grep #{options.username}\"\n      cmd_user_create = db.cmd options, \"CREATE USER #{options.username} IDENTIFIED BY '#{options.password}';\"\n      cmd_password_is_invalid = db.cmd(options, admin_username: null, admin_password: null, '\\\\dt') + \" 2>&1 >/dev/null | grep -e '^ERROR 1045.*'\"\n      cmd_password_change = db.cmd options, \"SET PASSWORD FOR #{options.username} = PASSWORD ('#{options.password}');\"\n    when 'postgresql'\n      cmd_user_exists = db.cmd(options, \"SELECT 1 FROM pg_roles WHERE rolname='#{options.username}'\") + \" | grep 1\"\n      cmd_user_create = db.cmd options, \"CREATE USER #{options.username} WITH PASSWORD '#{options.password}';\"\n      cmd_password_is_invalid = db.cmd(options, admin_username: null, admin_password: null, '\\\\dt') + \" 2>&1 >/dev/null | grep -e '^psql:\\\\sFATAL.*password\\\\sauthentication\\\\sfailed\\\\sfor\\\\suser.*'\"\n      cmd_password_change = db.cmd options, \"ALTER USER #{options.username} WITH PASSWORD '#{options.password}';\"\n  @system.execute\n    cmd: \"\"\"\n    signal=3\n    if #{cmd_user_exists}; then\n      echo '[INFO] User already exists'\n    else\n      #{cmd_user_create}\n      echo '[WARN] User created'\n      signal=0\n    fi\n    if [ $signal -eq 3 ]; then\n      if ! #{cmd_password_is_invalid}; then\n        echo '[INFO] Password not modified'\n      else\n        #{cmd_password_change}\n        echo '[WARN] Password modified'\n        signal=0\n      fi\n    fi\n    exit $signal\n    \"\"\"\n    code_skipped: 3\n    trap: true",
            "title": "Source Code"
        },
        {
            "location": "/db/user/index.coffee/#dependencies",
            "text": "db = require '../../misc/db'",
            "title": "Dependencies"
        },
        {
            "location": "/db/user/remove.coffee/",
            "text": "nikita.db.user.remove(options, callback)\n\n\nCreate a user for the destination database.\n\n\nOptions\n\n\n\n\nadmin_username\n \n\n  The login of the database administrator.   \n\n\nadmin_password\n \n\n  The password of the database administrator.   \n\n\nengine\n \n\n  The engine type, can be MySQL or PostgreSQL, default to MySQL.   \n\n\nhost\n \n\n  The hostname of the database.   \n\n\nusername\n \n\n  The new user name.   \n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  options.username ?= options.argument\n  @system.execute\n    cmd: db.cmd options, \"DROP USER IF EXISTS #{options.username};\"\n\n\n\nDependencies\n\n\ndb = require '../../misc/db'",
            "title": "Remove.coffee"
        },
        {
            "location": "/db/user/remove.coffee/#nikitadbuserremoveoptions-callback",
            "text": "Create a user for the destination database.",
            "title": "nikita.db.user.remove(options, callback)"
        },
        {
            "location": "/db/user/remove.coffee/#options",
            "text": "admin_username   \n  The login of the database administrator.     admin_password   \n  The password of the database administrator.     engine   \n  The engine type, can be MySQL or PostgreSQL, default to MySQL.     host   \n  The hostname of the database.     username   \n  The new user name.",
            "title": "Options"
        },
        {
            "location": "/db/user/remove.coffee/#source-code",
            "text": "module.exports = (options) ->\n  # Import options from `options.db`\n  options.db ?= {}\n  options[k] ?= v for k, v of options.db\n  options.username ?= options.argument\n  @system.execute\n    cmd: db.cmd options, \"DROP USER IF EXISTS #{options.username};\"",
            "title": "Source Code"
        },
        {
            "location": "/db/user/remove.coffee/#dependencies",
            "text": "db = require '../../misc/db'",
            "title": "Dependencies"
        },
        {
            "location": "/docker/build.coffee/",
            "text": "nikita.docker.build(options, [callback])\n\n\nBuild docker repository from Dockerfile, from content or from current working\ndirectory (exclusive options).\n\n\nThe user can choose whether the build is local or on the remote.\nOptions are the same than docker build command with nikita's one.\nBe aware than you can not use ADD with content option because docker build\nfrom STDIN does not support a context.\n\n\nBy default docker always run the build and overwrite existing repositories.\nStatus unmodified if the repository is identical to a previous one\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\nimage\n (string) \n\n  Name of the image, required.\n\n\ntag\n (string) \n\n  Tag of the image.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine.\n\n\nfile\n \n\n  Path to Dockerfile.\n\n\ncontent\n (string | [string]) \n\n  Use this text to build the repository.\n\n\nquiet\n (boolean) \n\n  Suppress the verbose output generated by the containers. Default to false\n\n\nrm\n (boolean) \n\n  Remove intermediate containers after build, default to true.\n\n\nforce_rm\n (boolean) \n\n  Always remove intermediate containers during build, default to false.\n\n\nno_cache\n (boolean) \n\n  Do not use cache when building the repository, default to false.\n\n\nbuild_arg\n (\"k=v\" | []) \n\n  Send arguments to the build (Must match an ARG command).\n\n\ncwd\n (string) \n\n  change the working directory for the build.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  True if image was successfully built.   \n\n\nchecksum\n \n\n  Image cheksum if built.   \n\n\nstdout\n \n\n  Stdout value(s) unless \nstdout\n option is provided.   \n\n\nstderr\n \n\n  Stderr value(s) unless \nstderr\n option is provided.   \n\n\n\n\nExample\n\n\nBuilds a repository from dockerfile without any resourcess\n\n\nnikita.docker.build({\n  image: 'ryba/targe-build',\n  source: '/home/ryba/Dockerfile'\n}, function(err, status, stdout, stderr){\n  console.log( err ? err.message : 'Container built: ' + status);\n});\n\n\n\n\nBuilds an repository from dockerfile with external resources\n\n\nIn this case nikita download all the external files into a resources directory in the same location\nthan the Dockerfile. The Dockerfile content:\n\n\nFROM centos7\nADD resources/package.tar.gz /tmp/\nADD resources/configuration.sh /tmp/\n\n\n\n\nBuild directory tree :\n\n\n\u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 resources\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 package.tar.gz\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 configuration.sh\n\n\n\n\nnikita.docker.build({\n  ssh: ssh\n  tag: 'ryba/target-build'\n  source: '/home/ryba/Dockerfile'\n  resources: ['http://url.com/package.tar.gz/','/home/configuration.sh']\n}, function(err, status, stdout, stderr){\n  console.log( err ? err.message : 'Container built: ' + status);\n});\n\n\n\n\nBuilds an repository from stdin\n\n\nnikita.docker.build({\n  ssh: ssh,\n  tag: 'ryba/target-build'\n  content: \"FROM ubuntu\\nRUN echo 'helloworld'\"\n}, function(err, is_built, stdout, stderr){\n  console.log( err ? err.message : 'Container built: ' + status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering Docker build\", level: 'DEBUG', module: 'nikita/lib/docker/build'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validation\n  return callback Error 'Required option \"image\"' unless options.image?\n  return callback Error 'Can not build from Dockerfile and content' if options.content? and options.file?\n  options.rm ?= true\n  cmd = 'build'\n  number_of_step = 0\n  userargs = []\n  # status unmodified if final tag already exists\n  dockerfile_cmds = ['CMD','LABEL','EXPOSE','ENV','ADD','COPY','ENTRYPOINT',\n   'VOLUME','USER','WORKDIR','ARG','ONBUILD','RUN','STOPSIGNAL','MAINTAINER']\n  source = null\n  if options.file\n    source = options.file\n  else if options.cwd\n    source = \"#{options.cwd}/Dockerfile\"\n  options.cwd ?= path.dirname options.file if options.file\n  # Apply search and replace to content\n  # options.write ?= []\n  # if options.from? or options.to? or options.match? or options.replace? or options.before?\n  #   options.write.push\n  #     from: options.from\n  #     to: options.to\n  #     match: options.match\n  #     replace: options.replace\n  #     append: options.append\n  #     before: options.before\n  #   options.append = false\n  # Build cmd\n  for opt in ['force_rm', 'quiet', 'no_cache']\n    cmd += \" --#{opt.replace '_', '-'}\" if options[opt]\n  for opt in ['build_arg'] then if options[opt]?\n    if Array.isArray options[opt]\n      cmd += \" --#{opt.replace '_', '-'} #{k}\" for k in options[opt]\n    else\n      cmd += \" --#{opt.replace '_', '-'} #{options[opt]}\"\n  cmd += \" --rm=#{if options.rm then 'true' else 'false'}\"\n  cmd += \" -t \\\"#{options.image}#{if options.tag then \":#{options.tag}\" else ''}\\\"\"\n  # custom command for content option0\n  options.file ?= path.resolve options.cwd, 'Dockerfile' if options.cwd\n  if options.content?\n    options.log message: \"Building from text: Docker won't have a context. ADD/COPY not working\", level: 'WARN', module: 'nikita/docker/build'\n    cmd += \" - <<DOCKERFILE\\n#{options.content}\\nDOCKERFILE\" if options.content?\n  else if options.file?\n    options.log message: \"Building from Dockerfile: \\\"#{options.file}\\\"\", level: 'INFO', module: 'nikita/docker/build'\n    cmd += \" -f #{options.file} #{options.cwd}\"\n  else\n    options.log message: \"Building from CWD\", level: 'INFO', module: 'nikita/docker/build'\n    cmd += ' .'\n  @file\n    if: options.content\n    content: options.content\n    source: source\n    target: (content) ->\n      options.content = content\n    from: options.from\n    to: options.to\n    match: options.match\n    replace: options.replace\n    append: options.append\n    before: options.before\n    write: options.write\n  @call # Read Dockerfile if necessary to count steps\n    unless: options.content\n    handler: (_, callback) ->\n      options.log message: \"Reading Dockerfile from : #{options.file}\", level: 'INFO', module: 'nikita/lib/build'\n      @fs.readFile ssh: options.ssh, target: options.file, encoding: 'utf8', (err, content) ->\n        return callback err if err\n        options.content = content\n        callback()\n  @call -> # Count steps\n    for line in string.lines options.content\n      number_of_step++ if /^(.*?)\\s/.exec(line)?[1] in dockerfile_cmds\n  @system.execute\n    cmd: docker.wrap options, cmd\n    cwd: options.cwd\n  , (err, executed, stdout, stderr) ->\n    throw err if err\n    container_id_hash = null\n    lines = string.lines stderr\n    lines = string.lines stdout\n    number_of_cache = 0\n    for k,  line of lines\n      if (line.indexOf('Using cache') isnt  -1 )\n        number_of_cache = number_of_cache + 1\n      if (line.indexOf('Successfully built') isnt  -1 )\n        container_id_hash = line.split(' ').pop().toString()\n    userargs = [number_of_step isnt number_of_cache, container_id_hash, stdout, stderr]\n  @next (err, status) ->\n    return callback err if err\n    options.log if userargs[0]\n    then message: \"New image id #{userargs[1]}\", level: 'INFO', module: 'nikita/lib/docker/build' \n    else message: \"Identical image id #{userargs[1]}\", level: 'INFO', module: 'nikita/lib/docker/build'\n    callback null, userargs...\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'\nstring = require '../misc/string'\npath = require 'path'\nutil = require 'util'\n{merge} = require '../misc'",
            "title": "Build.coffee"
        },
        {
            "location": "/docker/build.coffee/#nikitadockerbuildoptions-callback",
            "text": "Build docker repository from Dockerfile, from content or from current working\ndirectory (exclusive options).  The user can choose whether the build is local or on the remote.\nOptions are the same than docker build command with nikita's one.\nBe aware than you can not use ADD with content option because docker build\nfrom STDIN does not support a context.  By default docker always run the build and overwrite existing repositories.\nStatus unmodified if the repository is identical to a previous one",
            "title": "nikita.docker.build(options, [callback])"
        },
        {
            "location": "/docker/build.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  image  (string)  \n  Name of the image, required.  tag  (string)  \n  Tag of the image.  machine  (string)  \n  Name of the docker-machine, required if using docker-machine.  file   \n  Path to Dockerfile.  content  (string | [string])  \n  Use this text to build the repository.  quiet  (boolean)  \n  Suppress the verbose output generated by the containers. Default to false  rm  (boolean)  \n  Remove intermediate containers after build, default to true.  force_rm  (boolean)  \n  Always remove intermediate containers during build, default to false.  no_cache  (boolean)  \n  Do not use cache when building the repository, default to false.  build_arg  (\"k=v\" | [])  \n  Send arguments to the build (Must match an ARG command).  cwd  (string)  \n  change the working directory for the build.",
            "title": "Options"
        },
        {
            "location": "/docker/build.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  True if image was successfully built.     checksum   \n  Image cheksum if built.     stdout   \n  Stdout value(s) unless  stdout  option is provided.     stderr   \n  Stderr value(s) unless  stderr  option is provided.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/build.coffee/#example",
            "text": "",
            "title": "Example"
        },
        {
            "location": "/docker/build.coffee/#builds-a-repository-from-dockerfile-without-any-resourcess",
            "text": "nikita.docker.build({\n  image: 'ryba/targe-build',\n  source: '/home/ryba/Dockerfile'\n}, function(err, status, stdout, stderr){\n  console.log( err ? err.message : 'Container built: ' + status);\n});",
            "title": "Builds a repository from dockerfile without any resourcess"
        },
        {
            "location": "/docker/build.coffee/#builds-an-repository-from-dockerfile-with-external-resources",
            "text": "In this case nikita download all the external files into a resources directory in the same location\nthan the Dockerfile. The Dockerfile content:  FROM centos7\nADD resources/package.tar.gz /tmp/\nADD resources/configuration.sh /tmp/  Build directory tree :  \u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 resources\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 package.tar.gz\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 configuration.sh  nikita.docker.build({\n  ssh: ssh\n  tag: 'ryba/target-build'\n  source: '/home/ryba/Dockerfile'\n  resources: ['http://url.com/package.tar.gz/','/home/configuration.sh']\n}, function(err, status, stdout, stderr){\n  console.log( err ? err.message : 'Container built: ' + status);\n});",
            "title": "Builds an repository from dockerfile with external resources"
        },
        {
            "location": "/docker/build.coffee/#builds-an-repository-from-stdin",
            "text": "nikita.docker.build({\n  ssh: ssh,\n  tag: 'ryba/target-build'\n  content: \"FROM ubuntu\\nRUN echo 'helloworld'\"\n}, function(err, is_built, stdout, stderr){\n  console.log( err ? err.message : 'Container built: ' + status);\n});",
            "title": "Builds an repository from stdin"
        },
        {
            "location": "/docker/build.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering Docker build\", level: 'DEBUG', module: 'nikita/lib/docker/build'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validation\n  return callback Error 'Required option \"image\"' unless options.image?\n  return callback Error 'Can not build from Dockerfile and content' if options.content? and options.file?\n  options.rm ?= true\n  cmd = 'build'\n  number_of_step = 0\n  userargs = []\n  # status unmodified if final tag already exists\n  dockerfile_cmds = ['CMD','LABEL','EXPOSE','ENV','ADD','COPY','ENTRYPOINT',\n   'VOLUME','USER','WORKDIR','ARG','ONBUILD','RUN','STOPSIGNAL','MAINTAINER']\n  source = null\n  if options.file\n    source = options.file\n  else if options.cwd\n    source = \"#{options.cwd}/Dockerfile\"\n  options.cwd ?= path.dirname options.file if options.file\n  # Apply search and replace to content\n  # options.write ?= []\n  # if options.from? or options.to? or options.match? or options.replace? or options.before?\n  #   options.write.push\n  #     from: options.from\n  #     to: options.to\n  #     match: options.match\n  #     replace: options.replace\n  #     append: options.append\n  #     before: options.before\n  #   options.append = false\n  # Build cmd\n  for opt in ['force_rm', 'quiet', 'no_cache']\n    cmd += \" --#{opt.replace '_', '-'}\" if options[opt]\n  for opt in ['build_arg'] then if options[opt]?\n    if Array.isArray options[opt]\n      cmd += \" --#{opt.replace '_', '-'} #{k}\" for k in options[opt]\n    else\n      cmd += \" --#{opt.replace '_', '-'} #{options[opt]}\"\n  cmd += \" --rm=#{if options.rm then 'true' else 'false'}\"\n  cmd += \" -t \\\"#{options.image}#{if options.tag then \":#{options.tag}\" else ''}\\\"\"\n  # custom command for content option0\n  options.file ?= path.resolve options.cwd, 'Dockerfile' if options.cwd\n  if options.content?\n    options.log message: \"Building from text: Docker won't have a context. ADD/COPY not working\", level: 'WARN', module: 'nikita/docker/build'\n    cmd += \" - <<DOCKERFILE\\n#{options.content}\\nDOCKERFILE\" if options.content?\n  else if options.file?\n    options.log message: \"Building from Dockerfile: \\\"#{options.file}\\\"\", level: 'INFO', module: 'nikita/docker/build'\n    cmd += \" -f #{options.file} #{options.cwd}\"\n  else\n    options.log message: \"Building from CWD\", level: 'INFO', module: 'nikita/docker/build'\n    cmd += ' .'\n  @file\n    if: options.content\n    content: options.content\n    source: source\n    target: (content) ->\n      options.content = content\n    from: options.from\n    to: options.to\n    match: options.match\n    replace: options.replace\n    append: options.append\n    before: options.before\n    write: options.write\n  @call # Read Dockerfile if necessary to count steps\n    unless: options.content\n    handler: (_, callback) ->\n      options.log message: \"Reading Dockerfile from : #{options.file}\", level: 'INFO', module: 'nikita/lib/build'\n      @fs.readFile ssh: options.ssh, target: options.file, encoding: 'utf8', (err, content) ->\n        return callback err if err\n        options.content = content\n        callback()\n  @call -> # Count steps\n    for line in string.lines options.content\n      number_of_step++ if /^(.*?)\\s/.exec(line)?[1] in dockerfile_cmds\n  @system.execute\n    cmd: docker.wrap options, cmd\n    cwd: options.cwd\n  , (err, executed, stdout, stderr) ->\n    throw err if err\n    container_id_hash = null\n    lines = string.lines stderr\n    lines = string.lines stdout\n    number_of_cache = 0\n    for k,  line of lines\n      if (line.indexOf('Using cache') isnt  -1 )\n        number_of_cache = number_of_cache + 1\n      if (line.indexOf('Successfully built') isnt  -1 )\n        container_id_hash = line.split(' ').pop().toString()\n    userargs = [number_of_step isnt number_of_cache, container_id_hash, stdout, stderr]\n  @next (err, status) ->\n    return callback err if err\n    options.log if userargs[0]\n    then message: \"New image id #{userargs[1]}\", level: 'INFO', module: 'nikita/lib/docker/build' \n    else message: \"Identical image id #{userargs[1]}\", level: 'INFO', module: 'nikita/lib/docker/build'\n    callback null, userargs...",
            "title": "Source Code"
        },
        {
            "location": "/docker/build.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'\nstring = require '../misc/string'\npath = require 'path'\nutil = require 'util'\n{merge} = require '../misc'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/checksum.coffee/",
            "text": "nikita.docker.build(options, [callback])\n\n\nReturn the checksum of repository:tag, if it exists. Function not native to docker.\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\ncwd\n (string) \n\n  change the working directory for the build.\n\n\nimage\n (string) \n\n  Name of the image, required.\n\n\nrepository\n (string) \n\n  Alias of image.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine.\n\n\ntag\n (string) \n\n  Tag of the image, default to latest.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  True if command was executed.\n\n\nchecksum\n \n\n  Image cheksum if it exist, false otherwise.\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering Docker checksum\", level: 'DEBUG', module: 'nikita/lib/docker/checksum'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validation\n  options.image ?= options.repository\n  return callback Error 'Missing repository parameter' unless options.image?\n  options.tag ?= 'latest'\n  cmd = \"images --no-trunc | grep '#{options.image}' | grep '#{options.tag}' | awk '{ print $3 }'\"\n  options.log message: \"Getting image checksum :#{options.image}\", level: 'INFO', module: 'nikita/lib/docker/checksum'\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , (err, executed, stdout, stderr) ->\n    checksum = if stdout is '' then false else stdout.toString().trim()\n    options.log message: \"Image checksum for #{options.image}: #{checksum}\", level: 'INFO', module: 'nikita/lib/docker/checksum' if executed\n    return callback err, executed, checksum\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'",
            "title": "Checksum.coffee"
        },
        {
            "location": "/docker/checksum.coffee/#nikitadockerbuildoptions-callback",
            "text": "Return the checksum of repository:tag, if it exists. Function not native to docker.",
            "title": "nikita.docker.build(options, [callback])"
        },
        {
            "location": "/docker/checksum.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  cwd  (string)  \n  change the working directory for the build.  image  (string)  \n  Name of the image, required.  repository  (string)  \n  Alias of image.  machine  (string)  \n  Name of the docker-machine, required if using docker-machine.  tag  (string)  \n  Tag of the image, default to latest.",
            "title": "Options"
        },
        {
            "location": "/docker/checksum.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  True if command was executed.  checksum   \n  Image cheksum if it exist, false otherwise.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/checksum.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering Docker checksum\", level: 'DEBUG', module: 'nikita/lib/docker/checksum'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validation\n  options.image ?= options.repository\n  return callback Error 'Missing repository parameter' unless options.image?\n  options.tag ?= 'latest'\n  cmd = \"images --no-trunc | grep '#{options.image}' | grep '#{options.tag}' | awk '{ print $3 }'\"\n  options.log message: \"Getting image checksum :#{options.image}\", level: 'INFO', module: 'nikita/lib/docker/checksum'\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , (err, executed, stdout, stderr) ->\n    checksum = if stdout is '' then false else stdout.toString().trim()\n    options.log message: \"Image checksum for #{options.image}: #{checksum}\", level: 'INFO', module: 'nikita/lib/docker/checksum' if executed\n    return callback err, executed, checksum",
            "title": "Source Code"
        },
        {
            "location": "/docker/checksum.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/cp.coffee/",
            "text": "nikita.docker.cp(options, [callback])\n\n\nCopy files/folders between a container and the local filesystem.\n\n\nReflecting the original docker ps command usage, source and target may take\nthe following forms:\n\n\n\n\nCONTAINER:PATH \n\n\nLOCALPATH\n\n\nprocess.readableStream as the source or process.writableStream as the\n  target (equivalent of \"-\")\n\n\n\n\nNote, stream are not yet supported.\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine or boot2docker.\n\n\nsource\n (string) \n\n  The path to upload or the container followed by the path to download.\n\n\ntarget\n (string) \n\n  The path to download or the container followed by the path to upload.\n\n\n\n\nUploading a file\n\n\nnikita.docker({\n  source: readable_stream or '/path/to/source'\n  target: 'my_container:/path/to/target'\n}, function(err, status){})\n\n\n\n\nDownloading a file\n\n\nnikita.docker({\n  source: 'my_container:/path/to/source',\n  target: writable_stream or '/path/to/target'\n}, function(err, status){\n  console.log( err ? err.message : 'Container copied: ' + status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering Docker cp\", level: 'DEBUG', module: 'nikita/lib/docker/cp'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  throw Error 'Missing option \"source\"' unless options.source\n  throw Error 'Missing option \"target\"' unless options.target\n  [_, source_container, source_path] = /(.*:)?(.*)/.exec options.source\n  [_, target_container, target_path] = /(.*:)?(.*)/.exec options.target\n  throw Error 'Incompatible source and target options' if source_container and target_container\n  throw Error 'Incompatible source and target options' if not source_container and not target_container\n  source_mkdir = false\n  target_mkdir = false\n  # Source is on the host, normalize path\n  @call (_, next) ->\n    return next() if source_container\n    if /\\/$/.test source_path\n      source_path = \"#{source_path}/#{path.basename target_path}\"\n      return next()\n    @fs.stat ssh: options.ssh, target: source_path, (err, stat) ->\n      return next err if err and err.code isnt 'ENOENT'\n      # TODO wdavidw: seems like a mistake to me, we shall have source_mkdir instead\n      return target_mkdir = true and next() if err?.code is 'ENOENT'\n      source_path = \"#{source_path}/#{path.basename target_path}\" if stat.isDirectory()\n      next()\n  @system.mkdir\n    target: source_path\n    if: -> source_mkdir\n  # Destination is on the host\n  @call (_, next)  ->\n    return next() if target_container\n    if /\\/$/.test target_path\n      target_path = \"#{target_path}/#{path.basename target_path}\"\n      return next()\n    @fs.stat ssh: options.ssh, target: target_path, (err, stat) ->\n      return next err if err and err.code isnt 'ENOENT'\n      return target_mkdir = true and next() if err?.code is 'ENOENT'\n      target_path = \"#{target_path}/#{path.basename target_path}\" if stat.isDirectory()\n      next()\n  @system.mkdir\n    target: target_path\n    if: -> target_mkdir\n  @system.execute\n    cmd: docker.wrap options, \"cp #{options.source} #{options.target}\"\n  , docker.callback\n\n\n\nModules Dependencies\n\n\npath = require 'path'\ndocker = require '../misc/docker'",
            "title": "Cp.coffee"
        },
        {
            "location": "/docker/cp.coffee/#nikitadockercpoptions-callback",
            "text": "Copy files/folders between a container and the local filesystem.  Reflecting the original docker ps command usage, source and target may take\nthe following forms:   CONTAINER:PATH   LOCALPATH  process.readableStream as the source or process.writableStream as the\n  target (equivalent of \"-\")   Note, stream are not yet supported.",
            "title": "nikita.docker.cp(options, [callback])"
        },
        {
            "location": "/docker/cp.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  machine  (string)  \n  Name of the docker-machine, required if using docker-machine or boot2docker.  source  (string)  \n  The path to upload or the container followed by the path to download.  target  (string)  \n  The path to download or the container followed by the path to upload.",
            "title": "Options"
        },
        {
            "location": "/docker/cp.coffee/#uploading-a-file",
            "text": "nikita.docker({\n  source: readable_stream or '/path/to/source'\n  target: 'my_container:/path/to/target'\n}, function(err, status){})",
            "title": "Uploading a file"
        },
        {
            "location": "/docker/cp.coffee/#downloading-a-file",
            "text": "nikita.docker({\n  source: 'my_container:/path/to/source',\n  target: writable_stream or '/path/to/target'\n}, function(err, status){\n  console.log( err ? err.message : 'Container copied: ' + status);\n});",
            "title": "Downloading a file"
        },
        {
            "location": "/docker/cp.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering Docker cp\", level: 'DEBUG', module: 'nikita/lib/docker/cp'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  throw Error 'Missing option \"source\"' unless options.source\n  throw Error 'Missing option \"target\"' unless options.target\n  [_, source_container, source_path] = /(.*:)?(.*)/.exec options.source\n  [_, target_container, target_path] = /(.*:)?(.*)/.exec options.target\n  throw Error 'Incompatible source and target options' if source_container and target_container\n  throw Error 'Incompatible source and target options' if not source_container and not target_container\n  source_mkdir = false\n  target_mkdir = false\n  # Source is on the host, normalize path\n  @call (_, next) ->\n    return next() if source_container\n    if /\\/$/.test source_path\n      source_path = \"#{source_path}/#{path.basename target_path}\"\n      return next()\n    @fs.stat ssh: options.ssh, target: source_path, (err, stat) ->\n      return next err if err and err.code isnt 'ENOENT'\n      # TODO wdavidw: seems like a mistake to me, we shall have source_mkdir instead\n      return target_mkdir = true and next() if err?.code is 'ENOENT'\n      source_path = \"#{source_path}/#{path.basename target_path}\" if stat.isDirectory()\n      next()\n  @system.mkdir\n    target: source_path\n    if: -> source_mkdir\n  # Destination is on the host\n  @call (_, next)  ->\n    return next() if target_container\n    if /\\/$/.test target_path\n      target_path = \"#{target_path}/#{path.basename target_path}\"\n      return next()\n    @fs.stat ssh: options.ssh, target: target_path, (err, stat) ->\n      return next err if err and err.code isnt 'ENOENT'\n      return target_mkdir = true and next() if err?.code is 'ENOENT'\n      target_path = \"#{target_path}/#{path.basename target_path}\" if stat.isDirectory()\n      next()\n  @system.mkdir\n    target: target_path\n    if: -> target_mkdir\n  @system.execute\n    cmd: docker.wrap options, \"cp #{options.source} #{options.target}\"\n  , docker.callback",
            "title": "Source Code"
        },
        {
            "location": "/docker/cp.coffee/#modules-dependencies",
            "text": "path = require 'path'\ndocker = require '../misc/docker'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/exec.coffee/",
            "text": "nikita.docker.exec(options, [callback])\n\n\nRun a command in a running container\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\ncontainer\n (string) \n\n  Name/ID of the container, required.\n\n\ncode_skipped\n (int | array) \n\n  The exit code(s) to skip.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required using docker-machine.\n\n\nservice\n (boolean) \n\n  if true, run container as a service, else run as a command, true by default.\n\n\nuid\n (name | uid) \n\n  Username or uid.\n\n\ngid\n (name | gid) \n\n  Groupname or gid.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  True if command was executed in container.\n\n\nstdout\n \n\n  Stdout value(s) unless \nstdout\n option is provided.   \n\n\nstderr\n \n\n  Stderr value(s) unless \nstderr\n option is provided.   \n\n\n\n\nExample\n\n\nnikita.docker({\n  ssh: ssh,\n  container: 'myContainer',\n  cmd: '/bin/bash -c \"echo toto\"'\n}, function(err, status, stdout, stderr){\n  console.log( err ? err.message : 'Command executed: ' + status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering Docker exec\", level: 'DEBUG', module: 'nikita/lib/docker/exec'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  throw Error 'Missing container' unless options.container?\n  throw Error 'Missing cmd' unless options.cmd?\n  options.service ?= false\n  # Construct exec command\n  cmd = 'exec'\n  if options.uid?\n    cmd += \" -u #{options.uid}\"\n    cmd += \":#{options.gid}\" if options.gid?\n  else if options.gid?\n    options.log message: 'options.gid ignored unless options.uid is provided', level: 'WARN', module: 'nikita/lib/docker/exec'\n  cmd += \" #{options.container} #{options.cmd}\"\n  delete options.cmd\n  @system.execute\n    cmd: docker.wrap options, cmd\n    code_skipped: options.code_skipped\n  # Note: There is no way to pass additionnal arguments in sync mode without\n  # a callback, or we would have ', docker.callback' as next line\n  , ->\n    try\n      docker.callback.call null, arguments...\n    catch e then arguments[0] = e\n    callback arguments...\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'",
            "title": "Exec.coffee"
        },
        {
            "location": "/docker/exec.coffee/#nikitadockerexecoptions-callback",
            "text": "Run a command in a running container",
            "title": "nikita.docker.exec(options, [callback])"
        },
        {
            "location": "/docker/exec.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  container  (string)  \n  Name/ID of the container, required.  code_skipped  (int | array)  \n  The exit code(s) to skip.  machine  (string)  \n  Name of the docker-machine, required using docker-machine.  service  (boolean)  \n  if true, run container as a service, else run as a command, true by default.  uid  (name | uid)  \n  Username or uid.  gid  (name | gid)  \n  Groupname or gid.",
            "title": "Options"
        },
        {
            "location": "/docker/exec.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  True if command was executed in container.  stdout   \n  Stdout value(s) unless  stdout  option is provided.     stderr   \n  Stderr value(s) unless  stderr  option is provided.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/exec.coffee/#example",
            "text": "nikita.docker({\n  ssh: ssh,\n  container: 'myContainer',\n  cmd: '/bin/bash -c \"echo toto\"'\n}, function(err, status, stdout, stderr){\n  console.log( err ? err.message : 'Command executed: ' + status);\n});",
            "title": "Example"
        },
        {
            "location": "/docker/exec.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering Docker exec\", level: 'DEBUG', module: 'nikita/lib/docker/exec'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  throw Error 'Missing container' unless options.container?\n  throw Error 'Missing cmd' unless options.cmd?\n  options.service ?= false\n  # Construct exec command\n  cmd = 'exec'\n  if options.uid?\n    cmd += \" -u #{options.uid}\"\n    cmd += \":#{options.gid}\" if options.gid?\n  else if options.gid?\n    options.log message: 'options.gid ignored unless options.uid is provided', level: 'WARN', module: 'nikita/lib/docker/exec'\n  cmd += \" #{options.container} #{options.cmd}\"\n  delete options.cmd\n  @system.execute\n    cmd: docker.wrap options, cmd\n    code_skipped: options.code_skipped\n  # Note: There is no way to pass additionnal arguments in sync mode without\n  # a callback, or we would have ', docker.callback' as next line\n  , ->\n    try\n      docker.callback.call null, arguments...\n    catch e then arguments[0] = e\n    callback arguments...",
            "title": "Source Code"
        },
        {
            "location": "/docker/exec.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/kill.coffee/",
            "text": "nikita.docker.kill(options, [callback])\n\n\nSend signal to containers using SIGKILL or a specified signal.\nNote if container is not running , SIGKILL is not executed and\nreturn status is UNMODIFIED. If container does not exist nor is running\nSIGNAL is not sent.\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\ncontainer\n (string) \n\n  Name/ID of the container, required.   \n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine.\n\n\nsignal\n (int|string) \n\n  Use a specified signal. SIGKILL by default.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  True if container was killed.\n\n\n\n\nExample\n\n\nnikita.docker.kill({\n  container: 'toto',\n  signal: 9\n}, function(err, status){  \n  console.log( err ? err.message : 'Container killed: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering Docker kill\", level: 'DEBUG', module: 'nikita/lib/docker/kill'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  return callback Error 'Missing container parameter' unless options.container?\n  cmd = 'kill'\n  cmd += \" -s #{options.signal}\" if options.signal?\n  cmd += \" #{options.container}\"\n  @system.execute\n    cmd: docker.wrap options, \"ps | grep '#{options.container}' | grep 'Up'\"\n    code_skipped: 1\n  , docker.callback\n  @system.execute\n    if: -> @status -1\n    cmd: docker.wrap options, cmd\n  , docker.callback\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'\nutil = require 'util'",
            "title": "Kill.coffee"
        },
        {
            "location": "/docker/kill.coffee/#nikitadockerkilloptions-callback",
            "text": "Send signal to containers using SIGKILL or a specified signal.\nNote if container is not running , SIGKILL is not executed and\nreturn status is UNMODIFIED. If container does not exist nor is running\nSIGNAL is not sent.",
            "title": "nikita.docker.kill(options, [callback])"
        },
        {
            "location": "/docker/kill.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  container  (string)  \n  Name/ID of the container, required.     machine  (string)  \n  Name of the docker-machine, required if using docker-machine.  signal  (int|string)  \n  Use a specified signal. SIGKILL by default.",
            "title": "Options"
        },
        {
            "location": "/docker/kill.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  True if container was killed.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/kill.coffee/#example",
            "text": "nikita.docker.kill({\n  container: 'toto',\n  signal: 9\n}, function(err, status){  \n  console.log( err ? err.message : 'Container killed: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/kill.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering Docker kill\", level: 'DEBUG', module: 'nikita/lib/docker/kill'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  return callback Error 'Missing container parameter' unless options.container?\n  cmd = 'kill'\n  cmd += \" -s #{options.signal}\" if options.signal?\n  cmd += \" #{options.container}\"\n  @system.execute\n    cmd: docker.wrap options, \"ps | grep '#{options.container}' | grep 'Up'\"\n    code_skipped: 1\n  , docker.callback\n  @system.execute\n    if: -> @status -1\n    cmd: docker.wrap options, cmd\n  , docker.callback",
            "title": "Source Code"
        },
        {
            "location": "/docker/kill.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'\nutil = require 'util'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/load.coffee/",
            "text": "nikita.docker.load(options, [callback])\n\n\nLoad Docker images.\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine.\n\n\ninput\n (string) \n\n  TAR archive file to read from.\n\n\nsource\n (string) \n\n  Alias for the \"input\" option.\n\n\nchecksum\n (string) \n\n  If provided, will check if attached input archive to checksum already exist,\n  not native to docker but implemented to get better performance.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  True if container was loaded.\n\n\nstdout\n \n\n  Stdout value(s) unless \nstdout\n option is provided.\n\n\nstderr\n \n\n  Stderr value(s) unless \nstderr\n option is provided.\n\n\n\n\nExample\n\n\nnikita.docker.load({\n  image: 'nikita/load_test:latest',\n  machine: machine,\n  source: source + \"/nikita_load.tar\"\n}, function(err, status, stdout, stderr) {\n  console.log( err ? err.message : 'Container loaded: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering Docker load\", level: 'DEBUG', module: 'nikita/lib/docker/load'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  options.input ?= options.source\n  return callback Error 'Missing input parameter' unless options.input?\n  cmd = \"load -i #{options.input}\"\n  # need to records the list of image to see if status is modified or not after load\n  # for this we print the existing images as REPOSITORY:TAG:IMAGE\n  # parse the result to record images as an array of   {'REPOSITORY:TAG:'= 'IMAGE'}\n  images = {}\n  delete options.cmd\n  options.log message: 'Storing previous state of image', level: 'INFO', module: 'nikita/lib/docker/load'\n  options.log message: 'No checksum provided', level: 'INFO', module: 'nikita/lib/docker/load' if !options.checksum?\n  options.log message: \"Checksum provided :#{options.checksum}\", level: 'INFO', module: 'nikita/lib/docker/load' if options.checksum\n  options.checksum ?= ''\n  @system.execute\n    cmd: docker.wrap options, \" images | grep -v '<none>' | awk '{ print $1\\\":\\\"$2\\\":\\\"$3 }'\"\n  , (err, executed, stdout, stderr) =>\n    return callback err if err\n    # skip header line, wi skip it here instead of in the grep  to have\n    # an array with at least one not empty line\n    if string.lines(stdout).length > 1\n      for image in string.lines stdout\n        image = image.trim()\n        if image != ''\n          infos = image.split(':')\n          # if image is here we skip\n          options.log message: \"Image already exist checksum :#{options.checksum}, repo:tag #{\"#{infos[0]}:#{infos[1]}\"}\", level: 'INFO', module: 'nikita/lib/docker/load' if infos[2] == options.checksum\n          return callback null, false if infos[2] == options.checksum\n          images[\"#{infos[0]}:#{infos[1]}\"] = \"#{infos[2]}\"\n    options.log message: \"Start Loading #{options.input} \", level: 'INFO', module: 'nikita/lib/docker/load'\n    @system.execute\n      cmd: docker.wrap options, cmd\n    @system.execute\n      cmd: docker.wrap options, 'images | grep -v \\'<none>\\' | awk \\'{ print $1\":\"$2\":\"$3 }\\''\n    , (err, executed, out, stderr) ->\n      return callback err, executed, out, stderr if err\n      new_images = {}\n      diff = false\n      options.log message: 'Comparing new images', level: 'INFO', module: 'nikita/lib/docker/load'\n      if string.lines(stdout).length > 1\n        for image in string.lines out.toString()\n          if image != ''\n            infos = image.split(':')\n            new_images[\"#{infos[0]}:#{infos[1]}\"] = \"#{infos[2]}\"\n      for new_k, new_image of new_images\n        if !images[new_k]?\n          diff = true\n          break;\n        else\n          for k, image of images\n            if image != new_image && new_k == k\n              diff = true\n              options.log message: 'Identical images', level: 'INFO', module: 'nikita/lib/docker/load'\n              break;\n      callback err, diff, stdout, stderr\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'\nstring = require '../misc/string'\nutil = require 'util'",
            "title": "Load.coffee"
        },
        {
            "location": "/docker/load.coffee/#nikitadockerloadoptions-callback",
            "text": "Load Docker images.",
            "title": "nikita.docker.load(options, [callback])"
        },
        {
            "location": "/docker/load.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  machine  (string)  \n  Name of the docker-machine, required if using docker-machine.  input  (string)  \n  TAR archive file to read from.  source  (string)  \n  Alias for the \"input\" option.  checksum  (string)  \n  If provided, will check if attached input archive to checksum already exist,\n  not native to docker but implemented to get better performance.",
            "title": "Options"
        },
        {
            "location": "/docker/load.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  True if container was loaded.  stdout   \n  Stdout value(s) unless  stdout  option is provided.  stderr   \n  Stderr value(s) unless  stderr  option is provided.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/load.coffee/#example",
            "text": "nikita.docker.load({\n  image: 'nikita/load_test:latest',\n  machine: machine,\n  source: source + \"/nikita_load.tar\"\n}, function(err, status, stdout, stderr) {\n  console.log( err ? err.message : 'Container loaded: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/load.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering Docker load\", level: 'DEBUG', module: 'nikita/lib/docker/load'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  options.input ?= options.source\n  return callback Error 'Missing input parameter' unless options.input?\n  cmd = \"load -i #{options.input}\"\n  # need to records the list of image to see if status is modified or not after load\n  # for this we print the existing images as REPOSITORY:TAG:IMAGE\n  # parse the result to record images as an array of   {'REPOSITORY:TAG:'= 'IMAGE'}\n  images = {}\n  delete options.cmd\n  options.log message: 'Storing previous state of image', level: 'INFO', module: 'nikita/lib/docker/load'\n  options.log message: 'No checksum provided', level: 'INFO', module: 'nikita/lib/docker/load' if !options.checksum?\n  options.log message: \"Checksum provided :#{options.checksum}\", level: 'INFO', module: 'nikita/lib/docker/load' if options.checksum\n  options.checksum ?= ''\n  @system.execute\n    cmd: docker.wrap options, \" images | grep -v '<none>' | awk '{ print $1\\\":\\\"$2\\\":\\\"$3 }'\"\n  , (err, executed, stdout, stderr) =>\n    return callback err if err\n    # skip header line, wi skip it here instead of in the grep  to have\n    # an array with at least one not empty line\n    if string.lines(stdout).length > 1\n      for image in string.lines stdout\n        image = image.trim()\n        if image != ''\n          infos = image.split(':')\n          # if image is here we skip\n          options.log message: \"Image already exist checksum :#{options.checksum}, repo:tag #{\"#{infos[0]}:#{infos[1]}\"}\", level: 'INFO', module: 'nikita/lib/docker/load' if infos[2] == options.checksum\n          return callback null, false if infos[2] == options.checksum\n          images[\"#{infos[0]}:#{infos[1]}\"] = \"#{infos[2]}\"\n    options.log message: \"Start Loading #{options.input} \", level: 'INFO', module: 'nikita/lib/docker/load'\n    @system.execute\n      cmd: docker.wrap options, cmd\n    @system.execute\n      cmd: docker.wrap options, 'images | grep -v \\'<none>\\' | awk \\'{ print $1\":\"$2\":\"$3 }\\''\n    , (err, executed, out, stderr) ->\n      return callback err, executed, out, stderr if err\n      new_images = {}\n      diff = false\n      options.log message: 'Comparing new images', level: 'INFO', module: 'nikita/lib/docker/load'\n      if string.lines(stdout).length > 1\n        for image in string.lines out.toString()\n          if image != ''\n            infos = image.split(':')\n            new_images[\"#{infos[0]}:#{infos[1]}\"] = \"#{infos[2]}\"\n      for new_k, new_image of new_images\n        if !images[new_k]?\n          diff = true\n          break;\n        else\n          for k, image of images\n            if image != new_image && new_k == k\n              diff = true\n              options.log message: 'Identical images', level: 'INFO', module: 'nikita/lib/docker/load'\n              break;\n      callback err, diff, stdout, stderr",
            "title": "Source Code"
        },
        {
            "location": "/docker/load.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'\nstring = require '../misc/string'\nutil = require 'util'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/login.coffee/",
            "text": "nikita.docker.login(options, [callback])\n\n\nRegister or log in to a Docker registry server.\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.   \n\n\nregistry\n (string) \n\n  Address of the registry server. \"https://index.docker.io/v1/\" by default   \n\n\nmachine\n (string) \n\n  Name of the docker-machine, require if using docker-machine   \n\n\nemail\n (string) \n\n  Email   \n\n\nuser\n (string) \n\n  Username   \n\n\npassword\n (string) \n\n  Remove intermediate containers after build. Default to false   \n\n\ncwd\n (string) \n\n  change the working directory for the build.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nexecuted\n \n\n  if command was executed   \n\n\nstdout\n \n\n  Stdout value(s) unless \nstdout\n option is provided.   \n\n\nstderr\n \n\n  Stderr value(s) unless \nstderr\n option is provided.   \n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering Docker login\", level: 'DEBUG', module: 'nikita/lib/docker/login'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters and madatory conditions\n  return callback  Error 'Missing image parameter' unless options.image?\n  return callback  Error 'Can not build from Dockerfile and content' if options.content? and options.dockerfile?\n  cmd = 'login'\n  for opt in ['email', 'user', 'password']\n    cmd += \" -#{opt.charAt 0} #{options[opt]}\" if options[opt]?\n  cmd += \" \\\"#{options.registry}\\\"\" if options.registry?\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'\npath = require 'path'\nutil = require 'util'",
            "title": "Login.coffee"
        },
        {
            "location": "/docker/login.coffee/#nikitadockerloginoptions-callback",
            "text": "Register or log in to a Docker registry server.",
            "title": "nikita.docker.login(options, [callback])"
        },
        {
            "location": "/docker/login.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.     registry  (string)  \n  Address of the registry server. \"https://index.docker.io/v1/\" by default     machine  (string)  \n  Name of the docker-machine, require if using docker-machine     email  (string)  \n  Email     user  (string)  \n  Username     password  (string)  \n  Remove intermediate containers after build. Default to false     cwd  (string)  \n  change the working directory for the build.",
            "title": "Options"
        },
        {
            "location": "/docker/login.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     executed   \n  if command was executed     stdout   \n  Stdout value(s) unless  stdout  option is provided.     stderr   \n  Stderr value(s) unless  stderr  option is provided.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/login.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering Docker login\", level: 'DEBUG', module: 'nikita/lib/docker/login'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters and madatory conditions\n  return callback  Error 'Missing image parameter' unless options.image?\n  return callback  Error 'Can not build from Dockerfile and content' if options.content? and options.dockerfile?\n  cmd = 'login'\n  for opt in ['email', 'user', 'password']\n    cmd += \" -#{opt.charAt 0} #{options[opt]}\" if options[opt]?\n  cmd += \" \\\"#{options.registry}\\\"\" if options.registry?\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback",
            "title": "Source Code"
        },
        {
            "location": "/docker/login.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'\npath = require 'path'\nutil = require 'util'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/logout.coffee/",
            "text": "nikita.docker.logout(options, [callback])\n\n\nLog out from a Docker registry, if no server is\nspecified  is the default.\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\nregistry\n (string) \n\n  Address of the registry server, default to \"https://index.docker.io/v1/\".\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine.\n\n\ncode\n (int|array) \n\n  Expected code(s) returned by the command, int or array of int, default to 0.\n\n\ncode_skipped\n \n\n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  True if logout.\n\n\n\n\nExample\n\n\nnikita.docker.pause({\n  container: 'toto'\n}, function(err, status){\n  console.log( err ? err.message : 'Logout: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering Docker logout\", level: 'DEBUG', module: 'nikita/lib/docker/logout'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  return callback Error 'Missing container parameter' unless options.container?\n  # rm is false by default only if options.service is true\n  cmd = 'logout'\n  cmd += \" \\\"#{options.registry}\\\"\" if options.registry?\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'\nutil = require 'util'",
            "title": "Logout.coffee"
        },
        {
            "location": "/docker/logout.coffee/#nikitadockerlogoutoptions-callback",
            "text": "Log out from a Docker registry, if no server is\nspecified  is the default.",
            "title": "nikita.docker.logout(options, [callback])"
        },
        {
            "location": "/docker/logout.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  registry  (string)  \n  Address of the registry server, default to \"https://index.docker.io/v1/\".  machine  (string)  \n  Name of the docker-machine, required if using docker-machine.  code  (int|array)  \n  Expected code(s) returned by the command, int or array of int, default to 0.  code_skipped   \n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.",
            "title": "Options"
        },
        {
            "location": "/docker/logout.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  True if logout.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/logout.coffee/#example",
            "text": "nikita.docker.pause({\n  container: 'toto'\n}, function(err, status){\n  console.log( err ? err.message : 'Logout: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/logout.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering Docker logout\", level: 'DEBUG', module: 'nikita/lib/docker/logout'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  return callback Error 'Missing container parameter' unless options.container?\n  # rm is false by default only if options.service is true\n  cmd = 'logout'\n  cmd += \" \\\"#{options.registry}\\\"\" if options.registry?\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback",
            "title": "Source Code"
        },
        {
            "location": "/docker/logout.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'\nutil = require 'util'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/pause.coffee/",
            "text": "nikita.docker.pause(options, [callback])\n\n\nPause all processes within a container\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.   \n\n\ncontainer\n (string) \n\n  Name/ID of the container, required.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required.\n\n\ncode\n (int|array) \n\n  Expected code(s) returned by the command, int or array of int, default to 0.\n\n\ncode_skipped\n \n\n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  True if container was pulled.\n\n\n\n\nExample\n\n\nnikita.docker.pause({\n  container: 'toto'\n}, function(err, status){\n  console.log( err ? err.message : 'Container paused: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering Docker pause\", level: 'DEBUG', module: 'nikita/lib/docker/pause'\n  # Global parameters\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  return callback Error 'Missing container parameter' unless options.container?\n  cmd = \"pause #{options.container}\"\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'\nutil = require 'util'",
            "title": "Pause.coffee"
        },
        {
            "location": "/docker/pause.coffee/#nikitadockerpauseoptions-callback",
            "text": "Pause all processes within a container",
            "title": "nikita.docker.pause(options, [callback])"
        },
        {
            "location": "/docker/pause.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.     container  (string)  \n  Name/ID of the container, required.  machine  (string)  \n  Name of the docker-machine, required.  code  (int|array)  \n  Expected code(s) returned by the command, int or array of int, default to 0.  code_skipped   \n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.",
            "title": "Options"
        },
        {
            "location": "/docker/pause.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  True if container was pulled.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/pause.coffee/#example",
            "text": "nikita.docker.pause({\n  container: 'toto'\n}, function(err, status){\n  console.log( err ? err.message : 'Container paused: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/pause.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering Docker pause\", level: 'DEBUG', module: 'nikita/lib/docker/pause'\n  # Global parameters\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  return callback Error 'Missing container parameter' unless options.container?\n  cmd = \"pause #{options.container}\"\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback",
            "title": "Source Code"
        },
        {
            "location": "/docker/pause.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'\nutil = require 'util'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/pull.coffee/",
            "text": "nikita.docker.pull(options, [callback])\n\n\nPull a container\n\n\nOptions\n\n\n\n\ntag\n (string) \n\n  Name of the tag to pull.   \n\n\nversion\n (string) \n\n  Version of the tag to control.  Default to \nlatest\n.   \n\n\ncode_skipped\n (string) \n\n  The exit code to skip if different from 0.   \n\n\nall\n (Boolean) \n\n  Download all tagged images in the repository.  Default to false.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  True if container was pulled.\n\n\nstdout\n \n\n  Stdout value(s) unless \nstdout\n option is provided.\n\n\nstderr\n \n\n  Stderr value(s) unless \nstderr\n option is provided.\n\n\n\n\nExample\n\n\n1- builds an image from dockerfile without any resourcess\n\n\nnikita.docker_pull({\n  tag: 'postgresql'\n}, function(err, status, stdout, stderr){\n  console.log( err ? err.message : 'Container pulled: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering Docker pull\", level: 'DEBUG', module: 'nikita/lib/docker/pull'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  version = options.version or options.tag.split(':')[1] or 'latest'\n  delete options.version # present in misc.docker.options, will probably disappear at some point\n  options.all ?= false\n  cmd_images = 'images'\n  cmd_images += \" | grep '#{options.tag}'\"\n  cmd_images += \" | grep '#{version}'\" unless options.all\n  throw Error 'Missing Tag Name' unless options.tag?\n  # rm is false by default only if options.service is true\n  cmd = 'pull'\n  cmd += if options.all then  \" -a #{options.tag}\" else \" #{options.tag}:#{version}\"\n  @system.execute\n    cmd: docker.wrap options, cmd_images\n    code_skipped: 1\n  @system.execute\n    unless: -> @status -1\n    cmd: docker.wrap options, cmd\n    code_skipped: options.code_skipped\n  , (err, status) -> callback err, status\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'\nutil = require 'util'",
            "title": "Pull.coffee"
        },
        {
            "location": "/docker/pull.coffee/#nikitadockerpulloptions-callback",
            "text": "Pull a container",
            "title": "nikita.docker.pull(options, [callback])"
        },
        {
            "location": "/docker/pull.coffee/#options",
            "text": "tag  (string)  \n  Name of the tag to pull.     version  (string)  \n  Version of the tag to control.  Default to  latest .     code_skipped  (string)  \n  The exit code to skip if different from 0.     all  (Boolean)  \n  Download all tagged images in the repository.  Default to false.",
            "title": "Options"
        },
        {
            "location": "/docker/pull.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  True if container was pulled.  stdout   \n  Stdout value(s) unless  stdout  option is provided.  stderr   \n  Stderr value(s) unless  stderr  option is provided.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/pull.coffee/#example",
            "text": "1- builds an image from dockerfile without any resourcess  nikita.docker_pull({\n  tag: 'postgresql'\n}, function(err, status, stdout, stderr){\n  console.log( err ? err.message : 'Container pulled: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/pull.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering Docker pull\", level: 'DEBUG', module: 'nikita/lib/docker/pull'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  version = options.version or options.tag.split(':')[1] or 'latest'\n  delete options.version # present in misc.docker.options, will probably disappear at some point\n  options.all ?= false\n  cmd_images = 'images'\n  cmd_images += \" | grep '#{options.tag}'\"\n  cmd_images += \" | grep '#{version}'\" unless options.all\n  throw Error 'Missing Tag Name' unless options.tag?\n  # rm is false by default only if options.service is true\n  cmd = 'pull'\n  cmd += if options.all then  \" -a #{options.tag}\" else \" #{options.tag}:#{version}\"\n  @system.execute\n    cmd: docker.wrap options, cmd_images\n    code_skipped: 1\n  @system.execute\n    unless: -> @status -1\n    cmd: docker.wrap options, cmd\n    code_skipped: options.code_skipped\n  , (err, status) -> callback err, status",
            "title": "Source Code"
        },
        {
            "location": "/docker/pull.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'\nutil = require 'util'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/restart.coffee/",
            "text": "nikita.docker.start(options, [callback])\n\n\nStart stopped containers or restart (stop + starts) a started container.\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.   \n\n\ncontainer\n (string) \n\n  Name/ID of the container, required.   \n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine   \n\n\ntimeout\n (int) \n\n  Seconds to wait for stop before killing it   \n\n\ncode\n (int|array) \n\n  Expected code(s) returned by the command, int or array of int, default to 0.   \n\n\ncode_skipped\n \n\n  Expected code(s) returned by the command if it has no effect, executed will \n\n  not be incremented, int or array of int.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  True if container was restarted.  \n\n\n\n\nExample\n\n\nnikita.docker.restart({\n  container: 'toto'\n}, function(err, status){\n  console.log( err ? err.message : 'Container restarted: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering Docker restart\", level: 'DEBUG', module: 'nikita/lib/docker/restart'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  return callback Error 'Missing container parameter' unless options.container?\n  cmd = 'restart'\n  cmd += \" -t #{options.timeout}\" if options.timeout?\n  cmd += \" #{options.container}\"\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'\nutil = require 'util'",
            "title": "Restart.coffee"
        },
        {
            "location": "/docker/restart.coffee/#nikitadockerstartoptions-callback",
            "text": "Start stopped containers or restart (stop + starts) a started container.",
            "title": "nikita.docker.start(options, [callback])"
        },
        {
            "location": "/docker/restart.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.     container  (string)  \n  Name/ID of the container, required.     machine  (string)  \n  Name of the docker-machine, required if using docker-machine     timeout  (int)  \n  Seconds to wait for stop before killing it     code  (int|array)  \n  Expected code(s) returned by the command, int or array of int, default to 0.     code_skipped   \n  Expected code(s) returned by the command if it has no effect, executed will  \n  not be incremented, int or array of int.",
            "title": "Options"
        },
        {
            "location": "/docker/restart.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  True if container was restarted.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/restart.coffee/#example",
            "text": "nikita.docker.restart({\n  container: 'toto'\n}, function(err, status){\n  console.log( err ? err.message : 'Container restarted: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/restart.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering Docker restart\", level: 'DEBUG', module: 'nikita/lib/docker/restart'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  return callback Error 'Missing container parameter' unless options.container?\n  cmd = 'restart'\n  cmd += \" -t #{options.timeout}\" if options.timeout?\n  cmd += \" #{options.container}\"\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback",
            "title": "Source Code"
        },
        {
            "location": "/docker/restart.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'\nutil = require 'util'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/rm.coffee/",
            "text": "nikita.docker.rm(options, [callback])\n\n\nRemove one or more containers. Containers need to be stopped to be deleted unless\nforce options is set.\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\ncontainer\n (string) \n\n  Name/ID of the container, required.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if docker-machine installed.\n\n\nlink\n (boolean) \n\n  Remove the specified link.\n\n\nvolumes\n (boolean) \n\n  Remove the volumes associated with the container.\n\n\nforce\n (boolean) \n\n  Force the removal of a running container (uses SIGKILL).\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  True if container was removed.\n\n\n\n\nExample Code\n\n\nnikita.docker.rm({\n  container: 'toto'\n}, function(err, status){\n  console.log( err ? err.message : 'Container removed: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering Docker rm\", level: 'DEBUG', module: 'nikita/lib/docker/rm'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters and madatory conditions\n  return callback Error 'Missing container parameter' unless options.container?\n  cmd = for opt in ['link', 'volumes', 'force']\n    \"-#{opt.charAt 0}\" if options[opt]\n  cmd = \"rm #{cmd.join ' '} #{options.container}\"\n  @system.execute\n    cmd: docker.wrap options, \"ps | grep '#{options.container}'\"\n    code_skipped: 1\n  , (err, executed, stdout, stderr) =>\n    throw Error 'Container must be stopped to be removed without force', null if executed and not options.force\n  @system.execute\n    cmd: docker.wrap options, \"ps -a | grep '#{options.container}'\"\n    code_skipped: 1\n  , docker.callback\n  @system.execute\n    cmd: docker.wrap options, cmd\n    if: -> @status -1\n  , docker.callback\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'",
            "title": "Rm.coffee"
        },
        {
            "location": "/docker/rm.coffee/#nikitadockerrmoptions-callback",
            "text": "Remove one or more containers. Containers need to be stopped to be deleted unless\nforce options is set.",
            "title": "nikita.docker.rm(options, [callback])"
        },
        {
            "location": "/docker/rm.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  container  (string)  \n  Name/ID of the container, required.  machine  (string)  \n  Name of the docker-machine, required if docker-machine installed.  link  (boolean)  \n  Remove the specified link.  volumes  (boolean)  \n  Remove the volumes associated with the container.  force  (boolean)  \n  Force the removal of a running container (uses SIGKILL).",
            "title": "Options"
        },
        {
            "location": "/docker/rm.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  True if container was removed.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/rm.coffee/#example-code",
            "text": "nikita.docker.rm({\n  container: 'toto'\n}, function(err, status){\n  console.log( err ? err.message : 'Container removed: ' + status);\n})",
            "title": "Example Code"
        },
        {
            "location": "/docker/rm.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering Docker rm\", level: 'DEBUG', module: 'nikita/lib/docker/rm'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters and madatory conditions\n  return callback Error 'Missing container parameter' unless options.container?\n  cmd = for opt in ['link', 'volumes', 'force']\n    \"-#{opt.charAt 0}\" if options[opt]\n  cmd = \"rm #{cmd.join ' '} #{options.container}\"\n  @system.execute\n    cmd: docker.wrap options, \"ps | grep '#{options.container}'\"\n    code_skipped: 1\n  , (err, executed, stdout, stderr) =>\n    throw Error 'Container must be stopped to be removed without force', null if executed and not options.force\n  @system.execute\n    cmd: docker.wrap options, \"ps -a | grep '#{options.container}'\"\n    code_skipped: 1\n  , docker.callback\n  @system.execute\n    cmd: docker.wrap options, cmd\n    if: -> @status -1\n  , docker.callback",
            "title": "Source Code"
        },
        {
            "location": "/docker/rm.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/rmi.coffee/",
            "text": "nikita.docker_rmi(options, [callback])\n\n\nRemove images. All container using image should be stopped to delete it unless\nforce options is set.\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\nimage\n (string) \n\n  Name of the image, required.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if docker-machine installed.\n\n\nno_prune\n (boolean) \n\n  Do not delete untagged parents.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  True if image was removed.\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering Docker rmi\", level: 'DEBUG', module: 'nikita/lib/docker/rmi'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters and madatory conditions\n  throw Error 'Missing image parameter' unless options.image?\n  cmd_images = 'images'\n  cmd_images += \" | grep '#{options.image} '\"\n  cmd_images += \" | grep ' #{options.tag} '\" if options.tag?\n  cmd_rmi = 'rmi'\n  for opt in ['force', 'no_prune']\n    cmd_rmi += \" --#{opt.replace '_', '-'}\" if options[opt]?\n  cmd_rmi += \" #{options.image}\"\n  cmd_rmi += \":#{options.tag}\" if options.tag?\n  @system.execute\n    cmd: docker.wrap options, cmd_images\n    code_skipped: 1\n  , docker.callback\n  @system.execute\n    cmd: docker.wrap options, cmd_rmi\n    if: -> @status -1\n  , docker.callback\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'\nutil = require 'util'",
            "title": "Rmi.coffee"
        },
        {
            "location": "/docker/rmi.coffee/#nikitadocker_rmioptions-callback",
            "text": "Remove images. All container using image should be stopped to delete it unless\nforce options is set.",
            "title": "nikita.docker_rmi(options, [callback])"
        },
        {
            "location": "/docker/rmi.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  image  (string)  \n  Name of the image, required.  machine  (string)  \n  Name of the docker-machine, required if docker-machine installed.  no_prune  (boolean)  \n  Do not delete untagged parents.",
            "title": "Options"
        },
        {
            "location": "/docker/rmi.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  True if image was removed.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/rmi.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering Docker rmi\", level: 'DEBUG', module: 'nikita/lib/docker/rmi'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters and madatory conditions\n  throw Error 'Missing image parameter' unless options.image?\n  cmd_images = 'images'\n  cmd_images += \" | grep '#{options.image} '\"\n  cmd_images += \" | grep ' #{options.tag} '\" if options.tag?\n  cmd_rmi = 'rmi'\n  for opt in ['force', 'no_prune']\n    cmd_rmi += \" --#{opt.replace '_', '-'}\" if options[opt]?\n  cmd_rmi += \" #{options.image}\"\n  cmd_rmi += \":#{options.tag}\" if options.tag?\n  @system.execute\n    cmd: docker.wrap options, cmd_images\n    code_skipped: 1\n  , docker.callback\n  @system.execute\n    cmd: docker.wrap options, cmd_rmi\n    if: -> @status -1\n  , docker.callback",
            "title": "Source Code"
        },
        {
            "location": "/docker/rmi.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'\nutil = require 'util'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/run.coffee/",
            "text": "nikita.docker.run(options, [callback])\n\n\nRun Docker Containers\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\ncontainer\n (string) \n\n  Alias of name.\n\n\nname\n (string) \n\n   Assign a name to the container to run.\n\n\nimage\n (string) \n\n  Name/ID of base image, required.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine.\n\n\ncmd\n (string) \n\n  Overwrite the default ENTRYPOINT of the image, equivalent to \n  \n--entrypoint docker parameter\n\n\nhostname\n (string) \n\n  Hostname in the docker container.\n\n\nport\n ( 'int:int' | [] ) \n\n  Port mapping.\n\n\nvolume\n ( 'path:path' | [] ) \n\n  Path mapping.\n\n\ndevice\n ('path' | [] ) \n\n  Send host device(s) to container.\n\n\ndns\n (ip-address | [] ) \n\n  Set custom DNS server(s).\n\n\ndns_search\n (ip-address | [] ) \n\n  Set custom DNS search domain(s).\n\n\nexpose\n ( int | string | [] ) \n\n  Export port(s).\n\n\nlink\n ( containerName | containerID | [] ) \n\n  Link to other container(s).\n\n\nlabel\n (string | [] ) \n\n  Set meta data on a container.\n\n\nlabel_file\n (path) \n\n  Read in a line delimited file of labels.\n\n\nadd_host\n ('host:ip' | [] ) \n\n  Add a custom host-to-IP mapping (host:ip).\n\n\ncap_add\n ( | [] ) \n\n  Add Linux Capabilities.\n\n\ncap_drop\n ( | [] ) \n\n  Drop Linux Capabilities.\n\n\nblkio_weight\n (int) \n\n  Block IO (relative weight), between 10 and 1000.\n\n\ncgroup_parent\n \n\n  Optional parent cgroup for the container.\n\n\ncid_file\n ( path ) \n\n  Write the container ID to the file.\n\n\ncpuset_cpus\n (string) \n\n  CPUs in which to allow execution (ex: 0-3 0,1 ...).\n\n\nentrypoint\n () \n\n  Overwrite the default ENTRYPOINT of the image.\n\n\nipc\n () \n\n  IPC namespace to use.\n\n\nulimit\n  ( | [] ) \n\n  Ulimit options.\n\n\nvolumes_from\n (containerName | containerID | [] ) \n\n  Mount volumes from the specified container(s).\n\n\ndetach\n (boolean) \n\n  if true, run container in background.\n\n\nenv\n ('VAR=value' | [] ) \n\n  Environment variables for the container..\n\n\nenv_file\n ( path | [] ) \n\n  Read in a file of environment variables.\n\n\nrm\n (boolean) \n\n  Delete the container when it ends. True by default.\n\n\ncwd\n (path) \n\n  Working directory of container.\n\n\nnet\n (string) \n\n  Set the Network mode for the container.\n\n\npid\n (string) \n\n  PID namespace to use.\n\n\npublish_all\n (boolean) \n\n  Publish all exposed ports to random ports.\n\n\ncode\n   (int|array) \n\n  Expected code(s) returned by the command, int or array of int, default to 0..\n\n\ncode_skipped\n \n\n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  True unless contaianer was already running.\n\n\nstdout\n \n\n  Stdout value(s) unless \nstdout\n option is provided.\n\n\nstderr\n \n\n  Stderr value(s) unless \nstderr\n option is provided.\n\n\n\n\nExample\n\n\nnikita.docker({\n  ssh: ssh\n  name: 'myContainer'\n  image: 'test-image'\n  env: [\"FOO=bar\",]\n  entrypoint: '/bin/true'\n}, function(err, status, stdout, stderr){\n  console.log( err ? err.message : 'Container state changed to running: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering Docker run\", level: 'DEBUG', module: 'nikita/lib/docker/run'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  return callback Error 'Missing image' unless options.image?\n  options.rm ?= true\n  options.name ?= options.container\n  options.log message: \"Should specify a container name if rm is false\", level: 'WARN', module: 'nikita/docker/run' unless options.name? or options.rm\n  # Construct exec command\n  cmd = 'run'\n  # Classic options\n  for opt, flag of { name: '--name', hostname: '-h', cpu_shares: '-c',\n  cgroup_parent: '--cgroup-parent', cid_file: '--cidfile', blkio_weight: '--blkio-weight',\n  cpuset_cpus: '--cpuset-cpus', entrypoint: '--entrypoint', ipc: '--ipc',\n  log_driver: '--log-driver', memory: '-m', mac_address: '--mac-address',\n  memory_swap: '--memory-swap', net: '--net', pid: '--pid', cwd: '-w'}\n    cmd += \" #{flag} #{options[opt]}\" if options[opt]?\n  cmd += ' -d' if options.detach # else ' -t'\n  # Flag options\n  for opt, flag of { rm: '--rm', publish_all: '-P', privileged: '--privileged', read_only: '--read-only' }\n    cmd += \" #{flag}\" if options[opt]\n  # Arrays Options\n  for opt, flag of { port:'-p', volume: '-v', device: '--device', label: '-l',\n  label_file: '--label-file', expose: '--expose', env: '-e', env_file: '--env-file',\n  dns: '--dns', dns_search: '--dns-search', volumes_from: '--volumes-from',\n  cap_add: '--cap-add', cap_drop: '--cap-drop', ulimit: '--ulimit', add_host: '--add-host' }\n    if options[opt]?\n      if typeof options[opt] is 'string' or typeof options[opt] is 'number'\n        cmd += \" #{flag} #{options[opt]}\"\n      else if Array.isArray options[opt]\n        for p in options[opt]\n          if typeof p in ['string', 'number']\n            cmd += \" #{flag} #{p}\"\n          else callback Error \"Invalid parameter, '#{opt}' array should only contains string or number\"\n      else callback Error \"Invalid parameter, '#{opt}' should be string, number or array\"\n  cmd += \" #{options.image}\"\n  cmd += \" #{options.cmd}\" if options.cmd\n  # need to delete the cmd options or it will be used in docker.exec\n  delete options.cmd\n  @system.execute\n    if: options.name?\n    cmd: docker.wrap options, \"ps -a | grep '#{options.name}'\"\n    code_skipped: 1\n    shy: true\n  , (err, running) ->\n    docker.callback arguments...\n    options.log message: \"Container already running. Skipping\", level: 'INFO', module: 'nikita/docker/run' if running\n  @system.execute\n    cmd: docker.wrap options, cmd\n    if: ->\n      not options.name? or @status(-1) is false\n  , (err, running) ->\n    docker.callback arguments...\n    options.log message: \"Container now running\", level: 'WARN', module: 'nikita/docker/run' if running\n    callback arguments...\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'",
            "title": "Run.coffee"
        },
        {
            "location": "/docker/run.coffee/#nikitadockerrunoptions-callback",
            "text": "Run Docker Containers",
            "title": "nikita.docker.run(options, [callback])"
        },
        {
            "location": "/docker/run.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  container  (string)  \n  Alias of name.  name  (string)  \n   Assign a name to the container to run.  image  (string)  \n  Name/ID of base image, required.  machine  (string)  \n  Name of the docker-machine, required if using docker-machine.  cmd  (string)  \n  Overwrite the default ENTRYPOINT of the image, equivalent to \n   --entrypoint docker parameter  hostname  (string)  \n  Hostname in the docker container.  port  ( 'int:int' | [] )  \n  Port mapping.  volume  ( 'path:path' | [] )  \n  Path mapping.  device  ('path' | [] )  \n  Send host device(s) to container.  dns  (ip-address | [] )  \n  Set custom DNS server(s).  dns_search  (ip-address | [] )  \n  Set custom DNS search domain(s).  expose  ( int | string | [] )  \n  Export port(s).  link  ( containerName | containerID | [] )  \n  Link to other container(s).  label  (string | [] )  \n  Set meta data on a container.  label_file  (path)  \n  Read in a line delimited file of labels.  add_host  ('host:ip' | [] )  \n  Add a custom host-to-IP mapping (host:ip).  cap_add  ( | [] )  \n  Add Linux Capabilities.  cap_drop  ( | [] )  \n  Drop Linux Capabilities.  blkio_weight  (int)  \n  Block IO (relative weight), between 10 and 1000.  cgroup_parent   \n  Optional parent cgroup for the container.  cid_file  ( path )  \n  Write the container ID to the file.  cpuset_cpus  (string)  \n  CPUs in which to allow execution (ex: 0-3 0,1 ...).  entrypoint  ()  \n  Overwrite the default ENTRYPOINT of the image.  ipc  ()  \n  IPC namespace to use.  ulimit   ( | [] )  \n  Ulimit options.  volumes_from  (containerName | containerID | [] )  \n  Mount volumes from the specified container(s).  detach  (boolean)  \n  if true, run container in background.  env  ('VAR=value' | [] )  \n  Environment variables for the container..  env_file  ( path | [] )  \n  Read in a file of environment variables.  rm  (boolean)  \n  Delete the container when it ends. True by default.  cwd  (path)  \n  Working directory of container.  net  (string)  \n  Set the Network mode for the container.  pid  (string)  \n  PID namespace to use.  publish_all  (boolean)  \n  Publish all exposed ports to random ports.  code    (int|array)  \n  Expected code(s) returned by the command, int or array of int, default to 0..  code_skipped   \n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.",
            "title": "Options"
        },
        {
            "location": "/docker/run.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  True unless contaianer was already running.  stdout   \n  Stdout value(s) unless  stdout  option is provided.  stderr   \n  Stderr value(s) unless  stderr  option is provided.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/run.coffee/#example",
            "text": "nikita.docker({\n  ssh: ssh\n  name: 'myContainer'\n  image: 'test-image'\n  env: [\"FOO=bar\",]\n  entrypoint: '/bin/true'\n}, function(err, status, stdout, stderr){\n  console.log( err ? err.message : 'Container state changed to running: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/run.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering Docker run\", level: 'DEBUG', module: 'nikita/lib/docker/run'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  return callback Error 'Missing image' unless options.image?\n  options.rm ?= true\n  options.name ?= options.container\n  options.log message: \"Should specify a container name if rm is false\", level: 'WARN', module: 'nikita/docker/run' unless options.name? or options.rm\n  # Construct exec command\n  cmd = 'run'\n  # Classic options\n  for opt, flag of { name: '--name', hostname: '-h', cpu_shares: '-c',\n  cgroup_parent: '--cgroup-parent', cid_file: '--cidfile', blkio_weight: '--blkio-weight',\n  cpuset_cpus: '--cpuset-cpus', entrypoint: '--entrypoint', ipc: '--ipc',\n  log_driver: '--log-driver', memory: '-m', mac_address: '--mac-address',\n  memory_swap: '--memory-swap', net: '--net', pid: '--pid', cwd: '-w'}\n    cmd += \" #{flag} #{options[opt]}\" if options[opt]?\n  cmd += ' -d' if options.detach # else ' -t'\n  # Flag options\n  for opt, flag of { rm: '--rm', publish_all: '-P', privileged: '--privileged', read_only: '--read-only' }\n    cmd += \" #{flag}\" if options[opt]\n  # Arrays Options\n  for opt, flag of { port:'-p', volume: '-v', device: '--device', label: '-l',\n  label_file: '--label-file', expose: '--expose', env: '-e', env_file: '--env-file',\n  dns: '--dns', dns_search: '--dns-search', volumes_from: '--volumes-from',\n  cap_add: '--cap-add', cap_drop: '--cap-drop', ulimit: '--ulimit', add_host: '--add-host' }\n    if options[opt]?\n      if typeof options[opt] is 'string' or typeof options[opt] is 'number'\n        cmd += \" #{flag} #{options[opt]}\"\n      else if Array.isArray options[opt]\n        for p in options[opt]\n          if typeof p in ['string', 'number']\n            cmd += \" #{flag} #{p}\"\n          else callback Error \"Invalid parameter, '#{opt}' array should only contains string or number\"\n      else callback Error \"Invalid parameter, '#{opt}' should be string, number or array\"\n  cmd += \" #{options.image}\"\n  cmd += \" #{options.cmd}\" if options.cmd\n  # need to delete the cmd options or it will be used in docker.exec\n  delete options.cmd\n  @system.execute\n    if: options.name?\n    cmd: docker.wrap options, \"ps -a | grep '#{options.name}'\"\n    code_skipped: 1\n    shy: true\n  , (err, running) ->\n    docker.callback arguments...\n    options.log message: \"Container already running. Skipping\", level: 'INFO', module: 'nikita/docker/run' if running\n  @system.execute\n    cmd: docker.wrap options, cmd\n    if: ->\n      not options.name? or @status(-1) is false\n  , (err, running) ->\n    docker.callback arguments...\n    options.log message: \"Container now running\", level: 'WARN', module: 'nikita/docker/run' if running\n    callback arguments...",
            "title": "Source Code"
        },
        {
            "location": "/docker/run.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/save.coffee/",
            "text": "nikita.docker.save(options, [callback])\n\n\nSave Docker images.\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\nimage\n (string) \n\n  Name/ID of base image, required.\n\n\ntag\n (string) \n\n  Tag of the image.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine.\n\n\noutput\n (string). \n\n  TAR archive output path, required.\n\n\ntarget\n (string). \n\n  Shortcut for \"output\" option, required.\n\n\ncode\n (int | array) \n\n  Expected code(s) returned by the command, int or array of int, default to 0.\n\n\ncode_skipped\n \n\n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  True if container was saved.\n\n\nstdout\n \n\n  Stdout value(s) unless \nstdout\n option is provided.\n\n\nstderr\n \n\n  Stderr value(s) unless \nstderr\n option is provided.\n\n\n\n\nExample\n\n\nnikita.docker({\n  ssh: ssh\n  output: 'test-image.tar'\n  image: 'test-image'\n  compression: 'gzip'\n  entrypoint: '/bin/true'\n}, function(err, status, stdout, stderr){\n  console.log( err ? err.message : 'Container saved: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering Docker save\", level: 'DEBUG', module: 'nikita/lib/docker/save'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  throw Error 'Missing image parameter' unless options.image?\n  options.output ?= options.target\n  throw Error 'Missing output parameter' unless options.output?\n  # Saves image to local tmp path, than copy it\n  cmd = \"save -o #{options.output} #{options.image}\"\n  cmd += \":#{options.tag}\" if options.tag?\n  options.log message: \"Extracting image #{options.output} to file:#{options.image}\", level: 'INFO', module: 'nikita/lib/docker/save'\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback\n\n\n\nModules Dependencies\n\n\nutil = require 'util'  \ndocker = require '../misc/docker'",
            "title": "Save.coffee"
        },
        {
            "location": "/docker/save.coffee/#nikitadockersaveoptions-callback",
            "text": "Save Docker images.",
            "title": "nikita.docker.save(options, [callback])"
        },
        {
            "location": "/docker/save.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  image  (string)  \n  Name/ID of base image, required.  tag  (string)  \n  Tag of the image.  machine  (string)  \n  Name of the docker-machine, required if using docker-machine.  output  (string).  \n  TAR archive output path, required.  target  (string).  \n  Shortcut for \"output\" option, required.  code  (int | array)  \n  Expected code(s) returned by the command, int or array of int, default to 0.  code_skipped   \n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.",
            "title": "Options"
        },
        {
            "location": "/docker/save.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  True if container was saved.  stdout   \n  Stdout value(s) unless  stdout  option is provided.  stderr   \n  Stderr value(s) unless  stderr  option is provided.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/save.coffee/#example",
            "text": "nikita.docker({\n  ssh: ssh\n  output: 'test-image.tar'\n  image: 'test-image'\n  compression: 'gzip'\n  entrypoint: '/bin/true'\n}, function(err, status, stdout, stderr){\n  console.log( err ? err.message : 'Container saved: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/save.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering Docker save\", level: 'DEBUG', module: 'nikita/lib/docker/save'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  throw Error 'Missing image parameter' unless options.image?\n  options.output ?= options.target\n  throw Error 'Missing output parameter' unless options.output?\n  # Saves image to local tmp path, than copy it\n  cmd = \"save -o #{options.output} #{options.image}\"\n  cmd += \":#{options.tag}\" if options.tag?\n  options.log message: \"Extracting image #{options.output} to file:#{options.image}\", level: 'INFO', module: 'nikita/lib/docker/save'\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback",
            "title": "Source Code"
        },
        {
            "location": "/docker/save.coffee/#modules-dependencies",
            "text": "util = require 'util'  \ndocker = require '../misc/docker'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/service.coffee/",
            "text": "nikita.docker.service(options, [callback])\n\n\nRun a container in a service mode. This module is just a wrapper for docker.run\nwith correct options.\n\n\nIndeed, in a service mode, the container must be detached and NOT removed by default\nafter execution. \n\n\nOptions\n\n\nSee \ndocker.run\n for list of options.\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering Docker service\", level: 'DEBUG', module: 'nikita/lib/docker/service'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Normalization\n  options.detach ?= true\n  options.rm ?= false\n  # Validation\n  throw Error 'Missing container name' unless options.name? or options.container?\n  @docker.run options",
            "title": "Service.coffee"
        },
        {
            "location": "/docker/service.coffee/#nikitadockerserviceoptions-callback",
            "text": "Run a container in a service mode. This module is just a wrapper for docker.run\nwith correct options.  Indeed, in a service mode, the container must be detached and NOT removed by default\nafter execution.",
            "title": "nikita.docker.service(options, [callback])"
        },
        {
            "location": "/docker/service.coffee/#options",
            "text": "See  docker.run  for list of options.",
            "title": "Options"
        },
        {
            "location": "/docker/service.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering Docker service\", level: 'DEBUG', module: 'nikita/lib/docker/service'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Normalization\n  options.detach ?= true\n  options.rm ?= false\n  # Validation\n  throw Error 'Missing container name' unless options.name? or options.container?\n  @docker.run options",
            "title": "Source Code"
        },
        {
            "location": "/docker/start.coffee/",
            "text": "nikita.docker.restart(options, [callback])\n\n\nStart a container.\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\ncontainer\n (string) \n\n  Name/ID of the container, required.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine.\n\n\nattach\n (boolean) \n\n  attach STDOUT/STDERR, default to false.\n\n\ncode\n (int|array) \n\n  Expected code(s) returned by the command, int or array of int, default to 0.\n\n\ncode_skipped\n \n\n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  True unless container was already started.\n\n\nstdout\n \n\n  Stdout value(s) unless \nstdout\n option is provided.\n\n\nstderr\n \n\n  Stderr value(s) unless \nstderr\n option is provided.\n\n\n\n\nExample\n\n\n1- builds an image from dockerfile without any resourcess\n\n\nnikita.docker.start({\n  container: 'toto',\n  attach: true\n}, function(err, is_true, stdout, stderr){\n  console.log( err ? err.message : 'Container state changed to started: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering Docker start\", level: 'DEBUG', module: 'nikita/lib/docker/start'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validation\n  throw Error 'Missing container parameter' unless options.container?\n  # rm is false by default only if options.service is true\n  cmd = 'start'\n  cmd += ' -a' if options.attach\n  cmd += \" #{options.container}\"\n  @docker.status shy: true, options, (err, is_running) ->\n    throw err if err\n    if is_running\n    then options.log message: \"Container already started #{options.container} (Skipping)\", level: 'INFO', module: 'nikita/lib/docker/start'\n    else options.log message: \"Starting container #{options.container}\", level: 'INFO', module: 'nikita/lib/docker/start'\n    @end() if is_running\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'\nutil = require 'util'",
            "title": "Start.coffee"
        },
        {
            "location": "/docker/start.coffee/#nikitadockerrestartoptions-callback",
            "text": "Start a container.",
            "title": "nikita.docker.restart(options, [callback])"
        },
        {
            "location": "/docker/start.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  container  (string)  \n  Name/ID of the container, required.  machine  (string)  \n  Name of the docker-machine, required if using docker-machine.  attach  (boolean)  \n  attach STDOUT/STDERR, default to false.  code  (int|array)  \n  Expected code(s) returned by the command, int or array of int, default to 0.  code_skipped   \n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.",
            "title": "Options"
        },
        {
            "location": "/docker/start.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  True unless container was already started.  stdout   \n  Stdout value(s) unless  stdout  option is provided.  stderr   \n  Stderr value(s) unless  stderr  option is provided.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/start.coffee/#example",
            "text": "1- builds an image from dockerfile without any resourcess  nikita.docker.start({\n  container: 'toto',\n  attach: true\n}, function(err, is_true, stdout, stderr){\n  console.log( err ? err.message : 'Container state changed to started: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/start.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering Docker start\", level: 'DEBUG', module: 'nikita/lib/docker/start'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validation\n  throw Error 'Missing container parameter' unless options.container?\n  # rm is false by default only if options.service is true\n  cmd = 'start'\n  cmd += ' -a' if options.attach\n  cmd += \" #{options.container}\"\n  @docker.status shy: true, options, (err, is_running) ->\n    throw err if err\n    if is_running\n    then options.log message: \"Container already started #{options.container} (Skipping)\", level: 'INFO', module: 'nikita/lib/docker/start'\n    else options.log message: \"Starting container #{options.container}\", level: 'INFO', module: 'nikita/lib/docker/start'\n    @end() if is_running\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback",
            "title": "Source Code"
        },
        {
            "location": "/docker/start.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'\nutil = require 'util'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/status.coffee/",
            "text": "nikita.docker.status(options, [callback])\n\n\nReturn true if container is running. This function is not native to docker. \n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\ncontainer\n (string|array) \n\n  Name or Id of the container, required.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  True if container is running.\n\n\nstdout\n \n\n  Stdout value(s) unless \nstdout\n option is provided.\n\n\nstderr\n \n\n  Stderr value(s) unless \nstderr\n option is provided.\n\n\n\n\nExample\n\n\nnikita.docker({\n  ssh: ssh\n  target: 'test-image.tar'\n  image: 'test-image'\n  compression: 'gzip'\n  entrypoint: '/bin/true'\n}, function(err, status, stdout, stderr){\n  console.log( err ? err.message : 'Container running: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validation\n  throw Error 'Missing container parameter' unless options.container?\n  # Construct exec command\n  cmd = \"ps | grep '#{options.container}'\"\n  @system.execute\n    cmd: docker.wrap options, cmd\n    code_skipped: 1\n  , docker.callback\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'",
            "title": "Status.coffee"
        },
        {
            "location": "/docker/status.coffee/#nikitadockerstatusoptions-callback",
            "text": "Return true if container is running. This function is not native to docker.",
            "title": "nikita.docker.status(options, [callback])"
        },
        {
            "location": "/docker/status.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  container  (string|array)  \n  Name or Id of the container, required.  machine  (string)  \n  Name of the docker-machine, required if using docker-machine.",
            "title": "Options"
        },
        {
            "location": "/docker/status.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  True if container is running.  stdout   \n  Stdout value(s) unless  stdout  option is provided.  stderr   \n  Stderr value(s) unless  stderr  option is provided.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/status.coffee/#example",
            "text": "nikita.docker({\n  ssh: ssh\n  target: 'test-image.tar'\n  image: 'test-image'\n  compression: 'gzip'\n  entrypoint: '/bin/true'\n}, function(err, status, stdout, stderr){\n  console.log( err ? err.message : 'Container running: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/status.coffee/#source-code",
            "text": "module.exports = (options) ->\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validation\n  throw Error 'Missing container parameter' unless options.container?\n  # Construct exec command\n  cmd = \"ps | grep '#{options.container}'\"\n  @system.execute\n    cmd: docker.wrap options, cmd\n    code_skipped: 1\n  , docker.callback",
            "title": "Source Code"
        },
        {
            "location": "/docker/status.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/stop.coffee/",
            "text": "nikita.docker.stop(options, [callback])\n\n\nStop a started container.\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\ncontainer\n (string) \n\n  Name/ID of the container, required.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine.\n\n\ntimeout\n (int) \n\n  Seconds to wait for stop before killing it\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  True unless container was already stopped.\n\n\n\n\nExample\n\n\nnikita.docker.stop({\n  container: 'toto'\n}, function(err, is_true){\n  console.log( err ? err.message : 'Container state changed to stopped: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering Docker stop\", level: 'DEBUG', module: 'nikita/lib/docker/stop'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  throw Error 'Missing container parameter' unless options.container?\n  # rm is false by default only if options.service is true\n  cmd = 'stop'\n  cmd += \" -t #{options.timeout}\" if options.timeout?\n  cmd += \" #{options.container}\"\n  @docker.status shy: true, options, (err, is_running) ->\n    throw err if err\n    if is_running\n    then options.log message: \"Stopping container #{options.container}\", level: 'INFO', module: 'nikita/lib/docker/stop'\n    else options.log message: \"Container already stopped #{options.container} (Skipping)\", level: 'INFO', module: 'nikita/lib/docker/stop'\n    @end() unless is_running\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'\nutil = require 'util'",
            "title": "Stop.coffee"
        },
        {
            "location": "/docker/stop.coffee/#nikitadockerstopoptions-callback",
            "text": "Stop a started container.",
            "title": "nikita.docker.stop(options, [callback])"
        },
        {
            "location": "/docker/stop.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  container  (string)  \n  Name/ID of the container, required.  machine  (string)  \n  Name of the docker-machine, required if using docker-machine.  timeout  (int)  \n  Seconds to wait for stop before killing it",
            "title": "Options"
        },
        {
            "location": "/docker/stop.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  True unless container was already stopped.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/stop.coffee/#example",
            "text": "nikita.docker.stop({\n  container: 'toto'\n}, function(err, is_true){\n  console.log( err ? err.message : 'Container state changed to stopped: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/stop.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering Docker stop\", level: 'DEBUG', module: 'nikita/lib/docker/stop'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  throw Error 'Missing container parameter' unless options.container?\n  # rm is false by default only if options.service is true\n  cmd = 'stop'\n  cmd += \" -t #{options.timeout}\" if options.timeout?\n  cmd += \" #{options.container}\"\n  @docker.status shy: true, options, (err, is_running) ->\n    throw err if err\n    if is_running\n    then options.log message: \"Stopping container #{options.container}\", level: 'INFO', module: 'nikita/lib/docker/stop'\n    else options.log message: \"Container already stopped #{options.container} (Skipping)\", level: 'INFO', module: 'nikita/lib/docker/stop'\n    @end() unless is_running\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback",
            "title": "Source Code"
        },
        {
            "location": "/docker/stop.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'\nutil = require 'util'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/unpause.coffee/",
            "text": "nikita.docker.unpause(options, [callback])\n\n\nUnpause all processes within a container.\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\ncontainer\n (string) \n\n  Name/ID of the container, required.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  True if container was unpaused.\n\n\n\n\nExample\n\n\nnikita.docker.pause({\n  container: 'toto'\n}, function(err, is_true){\n  console.log( err ? err.message : 'Container was unpaused: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering Docker unpause\", level: 'DEBUG', module: 'nikita/lib/docker/unpause'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validation\n  throw Error 'Missing container parameter' unless options.container?\n  @system.execute\n    cmd: docker.wrap options, \"unpause #{options.container}\"\n  , -> docker.callback callback, arguments...\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'\nutil = require 'util'",
            "title": "Unpause.coffee"
        },
        {
            "location": "/docker/unpause.coffee/#nikitadockerunpauseoptions-callback",
            "text": "Unpause all processes within a container.",
            "title": "nikita.docker.unpause(options, [callback])"
        },
        {
            "location": "/docker/unpause.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  container  (string)  \n  Name/ID of the container, required.  machine  (string)  \n  Name of the docker-machine, required if using docker-machine.",
            "title": "Options"
        },
        {
            "location": "/docker/unpause.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  True if container was unpaused.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/unpause.coffee/#example",
            "text": "nikita.docker.pause({\n  container: 'toto'\n}, function(err, is_true){\n  console.log( err ? err.message : 'Container was unpaused: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/unpause.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering Docker unpause\", level: 'DEBUG', module: 'nikita/lib/docker/unpause'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validation\n  throw Error 'Missing container parameter' unless options.container?\n  @system.execute\n    cmd: docker.wrap options, \"unpause #{options.container}\"\n  , -> docker.callback callback, arguments...",
            "title": "Source Code"
        },
        {
            "location": "/docker/unpause.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'\nutil = require 'util'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/volume_create.coffee/",
            "text": "nikita.volume_create(options, [callback])\n\n\nCreate a volume. \n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\ndriver\n (string) \n\n  Specify volume driver name.\n\n\nlabel\n (string|array) \n\n  Set metadata for a volume.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine.\n\n\nname\n (string) \n\n  Specify volume name.\n\n\nopt\n (string|array) \n\n  Set driver specific options.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  True is volume was created.\n\n\n\n\nExample\n\n\nnikita.docker.pause({\n  name: 'my_volume'\n}, function(err, created){\n  console.log( err ? err.message : 'Volume created: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering Docker volume_create\", level: 'DEBUG', module: 'nikita/lib/docker/volume_create'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Normalize options\n  options.label = [options.label] if typeof options.label is 'string'\n  options.opt = [options.opt] if typeof options.opt is 'string'\n  # Build the docker command arguments\n  cmd = [\"volume create\"]\n  cmd.push \"--driver #{options.driver}\" if options.driver\n  cmd.push \"--label #{options.label.join ','}\" if options.label\n  cmd.push \"--name #{options.name}\" if options.name\n  cmd.push \"--opt #{options.opt.join ','}\" if options.opt\n  cmd = cmd.join ' '\n  @system.execute\n    if: options.name\n    cmd: docker.wrap options, \"volume inspect #{options.name}\"\n    code: 1\n    code_skipped: 0\n    shy: true\n  @system.execute\n    if: -> not options.name or @status -1\n    cmd: docker.wrap options, cmd\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'",
            "title": "Volume create.coffee"
        },
        {
            "location": "/docker/volume_create.coffee/#nikitavolume_createoptions-callback",
            "text": "Create a volume.",
            "title": "nikita.volume_create(options, [callback])"
        },
        {
            "location": "/docker/volume_create.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  driver  (string)  \n  Specify volume driver name.  label  (string|array)  \n  Set metadata for a volume.  machine  (string)  \n  Name of the docker-machine, required if using docker-machine.  name  (string)  \n  Specify volume name.  opt  (string|array)  \n  Set driver specific options.",
            "title": "Options"
        },
        {
            "location": "/docker/volume_create.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  True is volume was created.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/volume_create.coffee/#example",
            "text": "nikita.docker.pause({\n  name: 'my_volume'\n}, function(err, created){\n  console.log( err ? err.message : 'Volume created: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/volume_create.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering Docker volume_create\", level: 'DEBUG', module: 'nikita/lib/docker/volume_create'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Normalize options\n  options.label = [options.label] if typeof options.label is 'string'\n  options.opt = [options.opt] if typeof options.opt is 'string'\n  # Build the docker command arguments\n  cmd = [\"volume create\"]\n  cmd.push \"--driver #{options.driver}\" if options.driver\n  cmd.push \"--label #{options.label.join ','}\" if options.label\n  cmd.push \"--name #{options.name}\" if options.name\n  cmd.push \"--opt #{options.opt.join ','}\" if options.opt\n  cmd = cmd.join ' '\n  @system.execute\n    if: options.name\n    cmd: docker.wrap options, \"volume inspect #{options.name}\"\n    code: 1\n    code_skipped: 0\n    shy: true\n  @system.execute\n    if: -> not options.name or @status -1\n    cmd: docker.wrap options, cmd",
            "title": "Source Code"
        },
        {
            "location": "/docker/volume_create.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/volume_rm.coffee/",
            "text": "nikita.volume_rm(options, [callback])\n\n\nRemove a volume. \n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\ncontainer\n (string|array). \n\n  Name or Id of the container, required.   \n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine.\n\n\nname\n (string) \n\n  Specify volume name.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  True is volume was removed.\n\n\n\n\nExample\n\n\nnikita.docker.volume_rm({\n  name: 'my_volume'\n}, function(err, status){\n  console.log( err ? err.message : 'Volume removed: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering Docker volume_rm\", level: 'DEBUG', module: 'nikita/lib/docker/volume_rm'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validation\n  throw Error \"Missing required option name\" unless options.name\n  @system.execute\n    cmd: docker.wrap options, \"volume rm #{options.name}\"\n    code: 0\n    code_skipped: 1\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'",
            "title": "Volume rm.coffee"
        },
        {
            "location": "/docker/volume_rm.coffee/#nikitavolume_rmoptions-callback",
            "text": "Remove a volume.",
            "title": "nikita.volume_rm(options, [callback])"
        },
        {
            "location": "/docker/volume_rm.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  container  (string|array).  \n  Name or Id of the container, required.     machine  (string)  \n  Name of the docker-machine, required if using docker-machine.  name  (string)  \n  Specify volume name.",
            "title": "Options"
        },
        {
            "location": "/docker/volume_rm.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  True is volume was removed.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/volume_rm.coffee/#example",
            "text": "nikita.docker.volume_rm({\n  name: 'my_volume'\n}, function(err, status){\n  console.log( err ? err.message : 'Volume removed: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/volume_rm.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering Docker volume_rm\", level: 'DEBUG', module: 'nikita/lib/docker/volume_rm'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validation\n  throw Error \"Missing required option name\" unless options.name\n  @system.execute\n    cmd: docker.wrap options, \"volume rm #{options.name}\"\n    code: 0\n    code_skipped: 1",
            "title": "Source Code"
        },
        {
            "location": "/docker/volume_rm.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/wait.coffee/",
            "text": "nikita.docker.wait(options, [callback])\n\n\nBlock until a container stops.\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\ncontainer\n (string) \n\n  Name/ID of the container, optional.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, optional if using docker-machine.\n\n\ncode\n (int|array) \n\n  Expected code(s) returned by the command, int or array of int, default to 0.\n\n\ncode_skipped\n \n\n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  True unless container was already stopped.\n\n\n\n\nExample\n\n\nnikita.docker.wait({\n  container: 'toto'\n}, function(err, is_true){\n  console.log( err ? err.message : 'Volume removed: ' + status);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering Docker wait\", level: 'DEBUG', module: 'nikita/lib/docker/wait'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validation\n  return callback Error 'Missing container parameter' unless options.container?\n  # rm is false by default only if options.service is true\n  cmd = \"wait #{options.container} | read r; return $r\"\n  # Construct other exec parameter\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback\n\n\n\nModules Dependencies\n\n\ndocker = require '../misc/docker'\nutil = require 'util'",
            "title": "Wait.coffee"
        },
        {
            "location": "/docker/wait.coffee/#nikitadockerwaitoptions-callback",
            "text": "Block until a container stops.",
            "title": "nikita.docker.wait(options, [callback])"
        },
        {
            "location": "/docker/wait.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  container  (string)  \n  Name/ID of the container, optional.  machine  (string)  \n  Name of the docker-machine, optional if using docker-machine.  code  (int|array)  \n  Expected code(s) returned by the command, int or array of int, default to 0.  code_skipped   \n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.",
            "title": "Options"
        },
        {
            "location": "/docker/wait.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  True unless container was already stopped.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/wait.coffee/#example",
            "text": "nikita.docker.wait({\n  container: 'toto'\n}, function(err, is_true){\n  console.log( err ? err.message : 'Volume removed: ' + status);\n})",
            "title": "Example"
        },
        {
            "location": "/docker/wait.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering Docker wait\", level: 'DEBUG', module: 'nikita/lib/docker/wait'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validation\n  return callback Error 'Missing container parameter' unless options.container?\n  # rm is false by default only if options.service is true\n  cmd = \"wait #{options.container} | read r; return $r\"\n  # Construct other exec parameter\n  @system.execute\n    cmd: docker.wrap options, cmd\n  , docker.callback",
            "title": "Source Code"
        },
        {
            "location": "/docker/wait.coffee/#modules-dependencies",
            "text": "docker = require '../misc/docker'\nutil = require 'util'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/docker/compose/index.coffee/",
            "text": "nikita.docker.compose(options, [callback])\n\n\nCreate and start containers according to a docker-compose file\n\nnikita.docker.compose\n is an alias to \nnikita.docker.compose.up\n\n\nOptions\n\n\n\n\nboot2docker\n (boolean) \n\n  Whether to use boot2docker or not, default to false.\n\n\nmachine\n (string) \n\n  Name of the docker-machine, required if using docker-machine.\n\n\ncontent\n (string) \n\n  The content of the docker-compose.yml to write if not exist.\n\n\neof\n (string) \n\n  Inherited from nikita.file use when writing docker-compose.yml file.\n\n\nbackup\n (string|boolean) \n\n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.\n\n\ndetached\n (boolean) \n\n  Run Containers in detached mode. Default to true.\n\n\nforce\n (boolean) \n\n  Force to re-create the containers if the config and image have not changed\n  Default to false\n\n\nservices\n (string|array)\n  Specify specific services to create.\n\n\ntarget\n (string) \n\n  The docker-compose.yml absolute's file's path, required if no content is \n  specified.\n\n\ncode\n (int|array) \n\n  Expected code(s) returned by the command, int or array of int, default to 0.\n\n\ncode_skipped\n \n\n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n    Error object if any.   \n\n\nexecuted\n \n\n    if command was executed   \n\n\nstdout\n \n\n    Stdout value(s) unless \nstdout\n option is provided.   \n\n\nstderr\n \n\n    Stderr value(s) unless \nstderr\n option is provided.   \n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering Docker Compose\", level: 'DEBUG', module: 'nikita/lib/docker/compose/up'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  throw Error 'Missing docker-compose content or target' if not options.target? and not options.content?\n  if options.content and not options.target?\n    options.target ?= \"/tmp/nikita_docker_compose_#{Date.now()}/docker-compose.yml\"\n    clean_target = true\n  options.detached ?= true\n  options.force ?= false\n  options.recreate ?= false\n  options.services ?= []\n  options.services = [options.services] if not Array.isArray options.services\n  services = options.services.join ' '\n  # Construct exec command\n  cmd = \" --file #{options.target}\"\n  cmd_ps = \"#{cmd} ps -q | xargs docker #{docker.opts options} inspect\"\n  cmd_up = \"#{cmd} up\"\n  cmd_up += ' -d ' if options.detached\n  cmd_up += ' --force-recreate ' if options.force\n  cmd_up +=  \" #{services}\"\n  source_dir = \"#{path.dirname options.target}\"\n  options.eof ?= true\n  options.backup ?= false\n  options.compose = true\n  @call ->\n    @file.yaml\n      if: options.content?\n      eof: options.eof\n      backup: options.backup\n      target: options.target\n      content: options.content\n  @call (_, callback) ->\n    @system.execute\n      cmd: docker.wrap options, cmd_ps\n      cwd: options.cwd\n      uid: options.uid\n      code_skipped: 123\n      stdout_log: false\n    , (err, status, stdout, stderr) ->\n      return callback err if err\n      return callback null, true unless status\n      containers = JSON.parse stdout\n      status = containers.some (container) -> not container.State.Running\n      options.log \"Docker created, need start\" if status\n      callback null, status\n  @system.execute\n    if: -> options.force or @status()\n    cwd: source_dir\n    uid: options.uid\n    cmd: docker.wrap options, cmd_up\n  , docker.callback\n  @system.remove\n    if: clean_target\n    target: options.target\n    always: true # Not yet implemented\n\n\n\nModules Dependencies\n\n\ndocker = require '../../misc/docker'\npath = require 'path'",
            "title": "Index.coffee"
        },
        {
            "location": "/docker/compose/index.coffee/#nikitadockercomposeoptions-callback",
            "text": "Create and start containers according to a docker-compose file nikita.docker.compose  is an alias to  nikita.docker.compose.up",
            "title": "nikita.docker.compose(options, [callback])"
        },
        {
            "location": "/docker/compose/index.coffee/#options",
            "text": "boot2docker  (boolean)  \n  Whether to use boot2docker or not, default to false.  machine  (string)  \n  Name of the docker-machine, required if using docker-machine.  content  (string)  \n  The content of the docker-compose.yml to write if not exist.  eof  (string)  \n  Inherited from nikita.file use when writing docker-compose.yml file.  backup  (string|boolean)  \n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.  detached  (boolean)  \n  Run Containers in detached mode. Default to true.  force  (boolean)  \n  Force to re-create the containers if the config and image have not changed\n  Default to false  services  (string|array)\n  Specify specific services to create.  target  (string)  \n  The docker-compose.yml absolute's file's path, required if no content is \n  specified.  code  (int|array)  \n  Expected code(s) returned by the command, int or array of int, default to 0.  code_skipped   \n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.",
            "title": "Options"
        },
        {
            "location": "/docker/compose/index.coffee/#callback-parameters",
            "text": "err   \n    Error object if any.     executed   \n    if command was executed     stdout   \n    Stdout value(s) unless  stdout  option is provided.     stderr   \n    Stderr value(s) unless  stderr  option is provided.",
            "title": "Callback parameters"
        },
        {
            "location": "/docker/compose/index.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering Docker Compose\", level: 'DEBUG', module: 'nikita/lib/docker/compose/up'\n  # Global options\n  options.docker ?= {}\n  options[k] ?= v for k, v of options.docker\n  # Validate parameters\n  throw Error 'Missing docker-compose content or target' if not options.target? and not options.content?\n  if options.content and not options.target?\n    options.target ?= \"/tmp/nikita_docker_compose_#{Date.now()}/docker-compose.yml\"\n    clean_target = true\n  options.detached ?= true\n  options.force ?= false\n  options.recreate ?= false\n  options.services ?= []\n  options.services = [options.services] if not Array.isArray options.services\n  services = options.services.join ' '\n  # Construct exec command\n  cmd = \" --file #{options.target}\"\n  cmd_ps = \"#{cmd} ps -q | xargs docker #{docker.opts options} inspect\"\n  cmd_up = \"#{cmd} up\"\n  cmd_up += ' -d ' if options.detached\n  cmd_up += ' --force-recreate ' if options.force\n  cmd_up +=  \" #{services}\"\n  source_dir = \"#{path.dirname options.target}\"\n  options.eof ?= true\n  options.backup ?= false\n  options.compose = true\n  @call ->\n    @file.yaml\n      if: options.content?\n      eof: options.eof\n      backup: options.backup\n      target: options.target\n      content: options.content\n  @call (_, callback) ->\n    @system.execute\n      cmd: docker.wrap options, cmd_ps\n      cwd: options.cwd\n      uid: options.uid\n      code_skipped: 123\n      stdout_log: false\n    , (err, status, stdout, stderr) ->\n      return callback err if err\n      return callback null, true unless status\n      containers = JSON.parse stdout\n      status = containers.some (container) -> not container.State.Running\n      options.log \"Docker created, need start\" if status\n      callback null, status\n  @system.execute\n    if: -> options.force or @status()\n    cwd: source_dir\n    uid: options.uid\n    cmd: docker.wrap options, cmd_up\n  , docker.callback\n  @system.remove\n    if: clean_target\n    target: options.target\n    always: true # Not yet implemented",
            "title": "Source Code"
        },
        {
            "location": "/docker/compose/index.coffee/#modules-dependencies",
            "text": "docker = require '../../misc/docker'\npath = require 'path'",
            "title": "Modules Dependencies"
        },
        {
            "location": "/file/assert.coffee/",
            "text": "nikita.file.assert(options)\n\n\nAssert a file exists or a provided text match the content of a text file.\n\n\nOptions\n\n\n\n\ncontent\n (buffer|string) \n\n  Text to validate.   \n\n\nencoding\n (string) \n\n  Content encoding, see the Node.js supported Buffer encoding.   \n\n\nfiletype\n (string|array) \n\n  Validate the file, could be any \nfile type constants\n\n  or one of 'ifreg', 'file', 'ifdir', 'directory', 'ifchr', 'chardevice', \n  'iffblk', 'blockdevice', 'ififo', 'fifo', 'iflink', 'symlink', 'ifsock', \n  'socket'.   \n\n\nmd5\n (string) \n\n  Validate signature.   \n\n\nmode\n (string) \n\n  Validate file permissions.   \n\n\nnot\n (boolean) \n\n  Negates the validation.   \n\n\nsha1\n (string) \n\n  Validate signature.    \n\n\nsha256\n (string) \n\n  Validate signature.   \n\n\nsource\n (string) \n\n  Alias of option \"target\".   \n\n\ntarget\n (string) \n\n  File storing the content to assert.   \n\n\ntrim\n (boolean) \n\n  Trim the actuel and expected content before matching, default is \"false\".\n\n\nuid\n (int|string) \n\n  User ID to assert.   \n\n\ngid\n (int|string) \n\n  Group ID to assert.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n (Error) \n\n  Error if assertion failed.   \n\n\n\n\nExamples\n\n\nValidate the content of a file:\n\n\nnikita.file.assert({\n  ssh: connection\n  target: '/tmp/a_file'     \n  content: 'nikita is around' \n}, function(err){\n  console.log(err);\n});\n\n\n\n\nEnsure a file does not exists:\n\n\nnikita.file.assert({\n  ssh: connection\n  target: '/tmp/a_file'     \n  not: true\n}, function(err){\n  console.log(err);\n});\n\n\n\n\nSource code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering file.assert\", level: 'DEBUG', module: 'nikita/lib/file/assert'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  options.trim ?= false\n  options.encoding ?= 'utf8'\n  options.target ?= options.argument\n  options.target ?= options.source\n  options.filetype ?= []\n  options.filetype = [options.filetype] unless Array.isArray options.filetype\n  options.filetype = for filetype in options.filetype\n    continue unless filetype\n    if typeof filetype is 'string'\n      switch filetype.toLowerCase()\n        when 'ifreg', 'file' then fs.constants.S_IFREG\n        when 'ifdir', 'directory' then fs.constants.S_IFDIR\n        when 'ifchr', 'chardevice' then fs.constants.S_IFCHR\n        when 'iffblk', 'blockdevice' then fs.constants.S_IFBLK\n        when 'ififo', 'fifo' then fs.constants.S_IFIFO\n        when 'iflink', 'symlink' then fs.constants.S_IFLNK\n        when 'ifsock', 'socket' then fs.constants.S_IFSOCK\n        else filetype\n    else filetype\n  options.mode ?= []\n  options.mode = [options.mode] unless Array.isArray options.mode\n  throw Error 'Missing option: \"target\"' unless options.target\n  if typeof options.content is 'string'\n    options.content = options.content.trim() if options.trim\n    options.content = Buffer.from options.content, options.encoding\n  else if Buffer.isBuffer options.content\n    options.content = buffer.trim options.content, options.encoding if options.trim\n  else if options.content? and not options.content instanceof RegExp\n    throw Error \"Invalid option 'content': expect string, buffer or regexp\"\n  # Assert file exists\n  @call\n    unless: options.content? or options.md5 or options.sha1 or options.sha256 or options.mode.length\n  , (_, callback) ->\n    @fs.exists ssh: options.ssh, target: options.target.toString(), (err, exists) ->\n      unless options.not\n        unless exists\n          options.error ?= \"File does not exists: #{JSON.stringify options.target}\"\n          err = Error options.error\n      else\n        if exists\n          options.error ?= \"File exists: #{JSON.stringify options.target}\"\n          err = Error options.error\n      callback err\n  # Assert file filetype\n  @call\n    if: options.filetype.length\n  , (_, callback) ->\n    @fs.lstat ssh: options.ssh, target: options.target, (err, stat) ->\n      return callback err if err\n      if fs.constants.S_IFREG in options.filetype\n        return callback Error \"Invalid filetype: expect a regular file\" unless stat.isFile()\n      else if fs.constants.S_IFDIR in options.filetype\n        return callback Error \"Invalid filetype: expect a directory\" unless stat.isDirectory()\n      else if fs.constants.S_IFCHR in options.filetype\n        return callback Error \"Invalid filetype: expect a character-oriented device file\" unless stat.isCharacterDevice()\n      else if fs.constants.S_IFBLK in options.filetype\n        return callback Error \"Invalid filetype: expect a block-oriented device file\" unless stat.isBlockDevice()\n      else if fs.constants.S_IFIFO in options.filetype\n        return callback Error \"Invalid filetype: expect a FIFO/pipe\" unless stat.isFIFO()\n      else if fs.constants.S_IFLNK in options.filetype\n        return callback Error \"Invalid filetype: expect a symbolic link\" unless stat.isSymbolicLink()\n      else if fs.constants.S_IFSOCK in options.filetype\n        return callback Error \"Invalid filetype: expect a socket\" unless stat.isSocket()\n      else\n        return callback Error \"Invalid filetype: #{options.filetype.join ' '}\"\n      callback()\n  # Assert content equal\n  @call\n    if: options.content? and (typeof options.content is 'string' or Buffer.isBuffer options.content)\n  , (_, callback) ->\n    @fs.readFile ssh: options.ssh, target: options.target, (err, buf) ->\n      return callback err if err\n      buf = buffer.trim buf, options.encoding if options.trim\n      unless options.not\n        unless buf.equals options.content\n          options.error ?= \"Invalid content: expect #{JSON.stringify options.content.toString()} and got #{JSON.stringify buf.toString()}\"\n          err = Error options.error\n      else\n        if buf.equals options.content\n          options.error ?= \"Unexpected content: #{JSON.stringify options.content.toString()}\"\n          err = Error options.error\n      callback err\n  # Assert content match\n  @call\n    if: options.content? and options.content instanceof RegExp\n  , (_, callback) ->\n    @fs.readFile ssh: options.ssh, target: options.target, (err, buffer) ->\n      return callback err if err\n      unless options.not\n        unless options.content.test buffer \n          options.error ?= \"Invalid content match: expect #{JSON.stringify options.content.toString()} and got #{JSON.stringify buffer.toString()}\"\n          err = Error options.error\n      else\n        if options.content.test buffer\n          options.error ?= \"Unexpected content match: #{JSON.stringify options.content.toString()}\"\n          err = Error options.error\n      callback err\n  # Assert hash match\n  (algo = 'md5'; hash = options.md5) if options.md5\n  (algo = 'sha1'; hash = options.sha1) if options.sha1\n  (algo = 'sha256'; hash = options.sha256) if options.sha256\n  @call\n    if: algo\n  , (_, callback) ->\n    file.hash ssh, options.target, algo, (err, h) =>\n      return callback Error \"Target does not exists: #{options.target}\" if err?.code is 'ENOENT'\n      return callback err if err\n      unless options.not\n        if hash isnt h\n          options.error ?= \"Invalid #{algo} signature: expect #{JSON.stringify hash} and got #{JSON.stringify h}\"\n          err = Error options.error\n      else\n        if hash is h\n          options.error ?= \"Matching #{algo} signature: #{JSON.stringify hash}\"\n          err = Error options.error\n      callback err\n  # Assert uid ownerships\n  @call\n    if: options.uid?\n  , (_, callback) ->\n    @fs.stat ssh: options.ssh, target: options.target, (err, stat) ->\n      return callback Error \"Target does not exists: #{options.target}\" if err?.code is 'ENOENT'\n      unless options.not\n        unless \"#{stat.uid}\" is \"#{options.uid}\"\n          options.error ?= \"Unexpected uid: expected \\\"#{options.uid}\\\" and got \\\"#{stat.uid}\\\"\"\n          err = Error options.error\n      else\n        if \"#{stat.uid}\" is \"#{options.uid}\"\n          options.error ?= \"Unexpected matching uid: expected \\\"#{options.uid}\\\"\"\n          err = Error options.error\n      callback err\n  # Assert gid ownerships\n  @call\n    if: options.gid?\n  , (_, callback) ->\n    @fs.stat ssh: options.ssh, target: options.target, (err, stat) ->\n      return callback Error \"Target does not exists: #{options.target}\" if err?.code is 'ENOENT'\n      unless options.not\n        unless \"#{stat.gid}\" is \"#{options.gid}\"\n          options.error ?= \"Unexpected gid: expected \\\"#{options.gid}\\\" and got \\\"#{stat.gid}\\\"\"\n          err = Error options.error\n      else\n        if \"#{stat.gid}\" is \"#{options.gid}\"\n          options.error ?= \"Unexpected matching gid: expected \\\"#{options.gid}\\\"\"\n          err = Error options.error\n      callback err\n  # Assert file permissions\n  @call\n    if: options.mode.length\n  , (_, callback) ->\n    @fs.stat ssh: options.ssh, target: options.target, (err, stat) ->\n      return callback Error \"Target does not exists: #{options.target}\" if err?.code is 'ENOENT'\n      unless options.not\n        unless misc.mode.compare options.mode, stat.mode\n          expect = options.mode.map (mode) -> \"#{pad 4, misc.mode.stringify(mode), '0'}\"\n          options.error ?= \"Invalid mode: expect #{expect} and got #{misc.mode.stringify(stat.mode).substr -4}\"\n          err = Error options.error\n      else\n        if misc.mode.compare options.mode, stat.mode\n          expect = options.mode.map (mode) -> \"#{pad 4, misc.mode.stringify(mode), '0'}\"\n          options.error ?= \"Unexpected valid mode: #{expect}\"\n          err = Error options.error\n      callback err\n\n\n\nDependencies\n\n\npad = require 'pad'\nfs = require 'fs'\nmisc = require '../misc'\nfile = require '../misc/file'\nbuffer = require '../misc/buffer'",
            "title": "Assert.coffee"
        },
        {
            "location": "/file/assert.coffee/#nikitafileassertoptions",
            "text": "Assert a file exists or a provided text match the content of a text file.",
            "title": "nikita.file.assert(options)"
        },
        {
            "location": "/file/assert.coffee/#options",
            "text": "content  (buffer|string)  \n  Text to validate.     encoding  (string)  \n  Content encoding, see the Node.js supported Buffer encoding.     filetype  (string|array)  \n  Validate the file, could be any  file type constants \n  or one of 'ifreg', 'file', 'ifdir', 'directory', 'ifchr', 'chardevice', \n  'iffblk', 'blockdevice', 'ififo', 'fifo', 'iflink', 'symlink', 'ifsock', \n  'socket'.     md5  (string)  \n  Validate signature.     mode  (string)  \n  Validate file permissions.     not  (boolean)  \n  Negates the validation.     sha1  (string)  \n  Validate signature.      sha256  (string)  \n  Validate signature.     source  (string)  \n  Alias of option \"target\".     target  (string)  \n  File storing the content to assert.     trim  (boolean)  \n  Trim the actuel and expected content before matching, default is \"false\".  uid  (int|string)  \n  User ID to assert.     gid  (int|string)  \n  Group ID to assert.",
            "title": "Options"
        },
        {
            "location": "/file/assert.coffee/#callback-parameters",
            "text": "err  (Error)  \n  Error if assertion failed.",
            "title": "Callback parameters"
        },
        {
            "location": "/file/assert.coffee/#examples",
            "text": "Validate the content of a file:  nikita.file.assert({\n  ssh: connection\n  target: '/tmp/a_file'     \n  content: 'nikita is around' \n}, function(err){\n  console.log(err);\n});  Ensure a file does not exists:  nikita.file.assert({\n  ssh: connection\n  target: '/tmp/a_file'     \n  not: true\n}, function(err){\n  console.log(err);\n});",
            "title": "Examples"
        },
        {
            "location": "/file/assert.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering file.assert\", level: 'DEBUG', module: 'nikita/lib/file/assert'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  options.trim ?= false\n  options.encoding ?= 'utf8'\n  options.target ?= options.argument\n  options.target ?= options.source\n  options.filetype ?= []\n  options.filetype = [options.filetype] unless Array.isArray options.filetype\n  options.filetype = for filetype in options.filetype\n    continue unless filetype\n    if typeof filetype is 'string'\n      switch filetype.toLowerCase()\n        when 'ifreg', 'file' then fs.constants.S_IFREG\n        when 'ifdir', 'directory' then fs.constants.S_IFDIR\n        when 'ifchr', 'chardevice' then fs.constants.S_IFCHR\n        when 'iffblk', 'blockdevice' then fs.constants.S_IFBLK\n        when 'ififo', 'fifo' then fs.constants.S_IFIFO\n        when 'iflink', 'symlink' then fs.constants.S_IFLNK\n        when 'ifsock', 'socket' then fs.constants.S_IFSOCK\n        else filetype\n    else filetype\n  options.mode ?= []\n  options.mode = [options.mode] unless Array.isArray options.mode\n  throw Error 'Missing option: \"target\"' unless options.target\n  if typeof options.content is 'string'\n    options.content = options.content.trim() if options.trim\n    options.content = Buffer.from options.content, options.encoding\n  else if Buffer.isBuffer options.content\n    options.content = buffer.trim options.content, options.encoding if options.trim\n  else if options.content? and not options.content instanceof RegExp\n    throw Error \"Invalid option 'content': expect string, buffer or regexp\"\n  # Assert file exists\n  @call\n    unless: options.content? or options.md5 or options.sha1 or options.sha256 or options.mode.length\n  , (_, callback) ->\n    @fs.exists ssh: options.ssh, target: options.target.toString(), (err, exists) ->\n      unless options.not\n        unless exists\n          options.error ?= \"File does not exists: #{JSON.stringify options.target}\"\n          err = Error options.error\n      else\n        if exists\n          options.error ?= \"File exists: #{JSON.stringify options.target}\"\n          err = Error options.error\n      callback err\n  # Assert file filetype\n  @call\n    if: options.filetype.length\n  , (_, callback) ->\n    @fs.lstat ssh: options.ssh, target: options.target, (err, stat) ->\n      return callback err if err\n      if fs.constants.S_IFREG in options.filetype\n        return callback Error \"Invalid filetype: expect a regular file\" unless stat.isFile()\n      else if fs.constants.S_IFDIR in options.filetype\n        return callback Error \"Invalid filetype: expect a directory\" unless stat.isDirectory()\n      else if fs.constants.S_IFCHR in options.filetype\n        return callback Error \"Invalid filetype: expect a character-oriented device file\" unless stat.isCharacterDevice()\n      else if fs.constants.S_IFBLK in options.filetype\n        return callback Error \"Invalid filetype: expect a block-oriented device file\" unless stat.isBlockDevice()\n      else if fs.constants.S_IFIFO in options.filetype\n        return callback Error \"Invalid filetype: expect a FIFO/pipe\" unless stat.isFIFO()\n      else if fs.constants.S_IFLNK in options.filetype\n        return callback Error \"Invalid filetype: expect a symbolic link\" unless stat.isSymbolicLink()\n      else if fs.constants.S_IFSOCK in options.filetype\n        return callback Error \"Invalid filetype: expect a socket\" unless stat.isSocket()\n      else\n        return callback Error \"Invalid filetype: #{options.filetype.join ' '}\"\n      callback()\n  # Assert content equal\n  @call\n    if: options.content? and (typeof options.content is 'string' or Buffer.isBuffer options.content)\n  , (_, callback) ->\n    @fs.readFile ssh: options.ssh, target: options.target, (err, buf) ->\n      return callback err if err\n      buf = buffer.trim buf, options.encoding if options.trim\n      unless options.not\n        unless buf.equals options.content\n          options.error ?= \"Invalid content: expect #{JSON.stringify options.content.toString()} and got #{JSON.stringify buf.toString()}\"\n          err = Error options.error\n      else\n        if buf.equals options.content\n          options.error ?= \"Unexpected content: #{JSON.stringify options.content.toString()}\"\n          err = Error options.error\n      callback err\n  # Assert content match\n  @call\n    if: options.content? and options.content instanceof RegExp\n  , (_, callback) ->\n    @fs.readFile ssh: options.ssh, target: options.target, (err, buffer) ->\n      return callback err if err\n      unless options.not\n        unless options.content.test buffer \n          options.error ?= \"Invalid content match: expect #{JSON.stringify options.content.toString()} and got #{JSON.stringify buffer.toString()}\"\n          err = Error options.error\n      else\n        if options.content.test buffer\n          options.error ?= \"Unexpected content match: #{JSON.stringify options.content.toString()}\"\n          err = Error options.error\n      callback err\n  # Assert hash match\n  (algo = 'md5'; hash = options.md5) if options.md5\n  (algo = 'sha1'; hash = options.sha1) if options.sha1\n  (algo = 'sha256'; hash = options.sha256) if options.sha256\n  @call\n    if: algo\n  , (_, callback) ->\n    file.hash ssh, options.target, algo, (err, h) =>\n      return callback Error \"Target does not exists: #{options.target}\" if err?.code is 'ENOENT'\n      return callback err if err\n      unless options.not\n        if hash isnt h\n          options.error ?= \"Invalid #{algo} signature: expect #{JSON.stringify hash} and got #{JSON.stringify h}\"\n          err = Error options.error\n      else\n        if hash is h\n          options.error ?= \"Matching #{algo} signature: #{JSON.stringify hash}\"\n          err = Error options.error\n      callback err\n  # Assert uid ownerships\n  @call\n    if: options.uid?\n  , (_, callback) ->\n    @fs.stat ssh: options.ssh, target: options.target, (err, stat) ->\n      return callback Error \"Target does not exists: #{options.target}\" if err?.code is 'ENOENT'\n      unless options.not\n        unless \"#{stat.uid}\" is \"#{options.uid}\"\n          options.error ?= \"Unexpected uid: expected \\\"#{options.uid}\\\" and got \\\"#{stat.uid}\\\"\"\n          err = Error options.error\n      else\n        if \"#{stat.uid}\" is \"#{options.uid}\"\n          options.error ?= \"Unexpected matching uid: expected \\\"#{options.uid}\\\"\"\n          err = Error options.error\n      callback err\n  # Assert gid ownerships\n  @call\n    if: options.gid?\n  , (_, callback) ->\n    @fs.stat ssh: options.ssh, target: options.target, (err, stat) ->\n      return callback Error \"Target does not exists: #{options.target}\" if err?.code is 'ENOENT'\n      unless options.not\n        unless \"#{stat.gid}\" is \"#{options.gid}\"\n          options.error ?= \"Unexpected gid: expected \\\"#{options.gid}\\\" and got \\\"#{stat.gid}\\\"\"\n          err = Error options.error\n      else\n        if \"#{stat.gid}\" is \"#{options.gid}\"\n          options.error ?= \"Unexpected matching gid: expected \\\"#{options.gid}\\\"\"\n          err = Error options.error\n      callback err\n  # Assert file permissions\n  @call\n    if: options.mode.length\n  , (_, callback) ->\n    @fs.stat ssh: options.ssh, target: options.target, (err, stat) ->\n      return callback Error \"Target does not exists: #{options.target}\" if err?.code is 'ENOENT'\n      unless options.not\n        unless misc.mode.compare options.mode, stat.mode\n          expect = options.mode.map (mode) -> \"#{pad 4, misc.mode.stringify(mode), '0'}\"\n          options.error ?= \"Invalid mode: expect #{expect} and got #{misc.mode.stringify(stat.mode).substr -4}\"\n          err = Error options.error\n      else\n        if misc.mode.compare options.mode, stat.mode\n          expect = options.mode.map (mode) -> \"#{pad 4, misc.mode.stringify(mode), '0'}\"\n          options.error ?= \"Unexpected valid mode: #{expect}\"\n          err = Error options.error\n      callback err",
            "title": "Source code"
        },
        {
            "location": "/file/assert.coffee/#dependencies",
            "text": "pad = require 'pad'\nfs = require 'fs'\nmisc = require '../misc'\nfile = require '../misc/file'\nbuffer = require '../misc/buffer'",
            "title": "Dependencies"
        },
        {
            "location": "/file/cache.coffee/",
            "text": "nikita.file.cache(options, [callback])\n\n\nDownload a file and place it on a local or remote folder for later usage.\n\n\nOptions\n\n\n\n\ncache_dir\n (path)  \n\n  If local_cache is not a string, the cache file path is resolved from cache dir and cache file.\n  By default: './'    \n\n\ncache_file\n (string | boolean) \n\n  Alias for \"target\".   \n\n\ncache_local\n (boolean) \n\n  Apply to SSH mode, treat the cache file and directories as local from where\n  the command is used instead of over SSH.   \n\n\nfail\n (boolean) \n\n  Send an error if the HTTP response code is invalid. Similar to the curl\n  option of the same name.   \n\n\nforce\n (boolean) \n\n  Overwrite the target file if it exists, bypass md5 verification.   \n\n\nheaders\n (array) \n\n  Extra header  to include in the request when sending HTTP to a server.   \n\n\nlocation\n (boolean) \n\n  If the server reports that the requested page has moved to a different\n  location (indicated with a Location: header and a 3XX response code), this\n  option will make curl redo the request on the new place.   \n\n\nproxy\n (string) \n\n  Use the specified HTTP proxy. If the port number is not specified, it is\n  assumed at port 1080. See curl(1) man page.   \n\n\nsource\n (path) \n\n  File, HTTP URL, FTP, GIT repository. File is the default protocol if source\n  is provided without any.   \n\n\ntarget\n (string | boolean) \n\n  Cache the file on the executing machine, equivalent to cache unless an ssh\n  connection is provided. If a string is provided, it will be the cache path.\n  Default to the basename of source.   \n\n\n\n\nCallback Parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value is \"true\" if cache file was created or modified.   \n\n\n\n\nHTTP example\n\n\nrequire('nikita').download({\n  source: 'https://github.com/wdavidw/node-nikita/tarball/v0.0.1',\n  cache_dir: '/var/tmp'\n}, function(err, status){\n  console.log(err ? err.message : 'File downloaded: ' + status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering file.cache\", level: 'DEBUG', module: 'nikita/lib/file/cache'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  options.source = options.argument if options.argument?\n  throw Error \"Missing source: '#{options.source}'\" unless options.source\n  throw Error \"Missing one of 'target', 'cache_file' or 'cache_dir' option\" unless options.cache_file or options.target or options.cache_dir\n  options.target ?= options.cache_file\n  options.target ?= path.basename options.source\n  options.target = path.resolve options.cache_dir, options.target\n  options.source = options.source.substr 7 if /^file:\\/\\//.test options.source\n  options.headers ?= []\n  if options.md5?\n    throw Error \"Invalid MD5 Hash:#{options.md5}\" unless typeof options.md5 in ['string', 'boolean']\n    algo = 'md5'\n    hash = options.md5\n  else if options.sha1?\n    throw Error \"Invalid SHA-1 Hash:#{options.sha1}\" unless typeof options.sha1 in ['string', 'boolean']\n    algo = 'sha1'\n    hash = options.sha1\n  else if options.sha256?\n    throw Error \"Invalid SHA-1 Hash:#{options.sha256}\" unless typeof options.sha256 in ['string', 'boolean']\n    algo = 'sha256'\n    hash = options.sha256\n  else\n    algo = 'md5'\n    hash = false\n  u = url.parse options.source\n  @call (_, callback) ->\n    unless u.protocol is null\n      options.log message: \"Bypass source hash computation for non-file protocols\", level: 'WARN', module: 'nikita/lib/file/cache'\n      return callback()\n    return callback() if hash isnt true\n    file.hash ssh, options.source, algo, (err, value) ->\n      return callback err if err\n      options.log message: \"Computed hash value is '#{value}'\", level: 'INFO', module: 'nikita/lib/file/cache'\n      hash = value\n      callback()\n  # Download the file if\n  # - file doesnt exist\n  # - option force is provided\n  # - hash isnt true and doesnt match\n  @call shy: true, (_, callback) ->\n    options.log message: \"Check if target (#{options.target}) exists\", level: 'DEBUG', module: 'nikita/lib/file/cache'\n    @fs.exists ssh: options.ssh, target: options.target, (err, exists) =>\n      return callback err if err\n      if exists\n        options.log message: \"Target file exists\", level: 'INFO', module: 'nikita/lib/file/cache'\n        # If no checksum , we ignore MD5 check\n        if options.force\n          options.log message: \"Force mode, cache will be overwritten\", level: 'DEBUG', module: 'nikita/lib/file/cache'\n          return callback null, true\n        else if hash and typeof hash is 'string'\n          # then we compute the checksum of the file\n          options.log message: \"Comparing #{algo} hash\", level: 'DEBUG', module: 'nikita/lib/file/cache'\n          file.hash ssh, options.target, algo, (err, c_hash) =>\n            return callback err if err\n            # And compare with the checksum provided by the user\n            if hash is c_hash\n              options.log message: \"Hashes match, skipping\", level: 'DEBUG', module: 'nikita/lib/file/cache'\n              return callback null, false\n            options.log message: \"Hashes don't match, delete then re-download\", level: 'WARN', module: 'nikita/lib/file/cache'\n            @fs.unlink ssh: options.ssh, target: options.target, (err) ->\n              return callback err if err\n              callback null, true\n        else\n          options.log message: \"Target file exists, check disabled, skipping\", level: 'DEBUG', module: 'nikita/lib/file/cache'\n          callback null, false\n      else\n        options.log message: \"Target file does not exists\", level: 'INFO', module: 'nikita/lib/file/cache'\n        callback null, true\n  , (err, status) ->\n    @end() unless status\n  # Place into cache\n  if u.protocol in protocols_http\n    fail = if options.fail then \"--fail\" else ''\n    k = if u.protocol is 'https:' then '-k' else ''\n    cmd = \"curl #{fail} #{k} -s #{options.source} -o #{options.target}\"\n    cmd += \" --location\" if options.location\n    cmd += \" --header \\\"#{header}\\\"\" for header in options.headers\n    cmd += \" -x #{options.proxy}\" if options.proxy\n    @system.mkdir\n      ssh: if options.cache_local then false else ssh\n      target: path.dirname options.target\n    @system.execute\n      cmd: cmd\n      ssh: if options.cache_local then false else ssh\n      unless_exists: options.target\n  else\n    @system.mkdir # todo: copy shall handle this\n      target: \"#{path.dirname options.target}\"\n    @system.copy\n      source: \"#{options.source}\"\n      target: \"#{options.target}\"\n  # TODO: validate the cache\n  @next (err, status) ->\n    callback err, status, options.target\n\nmodule.exports.protocols_http = protocols_http = ['http:', 'https:']\nmodule.exports.protocols_ftp = protocols_ftp = ['ftp:', 'ftps:']\n\n\n\nDependencies\n\n\npath = require 'path'\nurl = require 'url'\ncurl = require '../misc/curl'\nfile = require '../misc/file'",
            "title": "Cache.coffee"
        },
        {
            "location": "/file/cache.coffee/#nikitafilecacheoptions-callback",
            "text": "Download a file and place it on a local or remote folder for later usage.",
            "title": "nikita.file.cache(options, [callback])"
        },
        {
            "location": "/file/cache.coffee/#options",
            "text": "cache_dir  (path)   \n  If local_cache is not a string, the cache file path is resolved from cache dir and cache file.\n  By default: './'      cache_file  (string | boolean)  \n  Alias for \"target\".     cache_local  (boolean)  \n  Apply to SSH mode, treat the cache file and directories as local from where\n  the command is used instead of over SSH.     fail  (boolean)  \n  Send an error if the HTTP response code is invalid. Similar to the curl\n  option of the same name.     force  (boolean)  \n  Overwrite the target file if it exists, bypass md5 verification.     headers  (array)  \n  Extra header  to include in the request when sending HTTP to a server.     location  (boolean)  \n  If the server reports that the requested page has moved to a different\n  location (indicated with a Location: header and a 3XX response code), this\n  option will make curl redo the request on the new place.     proxy  (string)  \n  Use the specified HTTP proxy. If the port number is not specified, it is\n  assumed at port 1080. See curl(1) man page.     source  (path)  \n  File, HTTP URL, FTP, GIT repository. File is the default protocol if source\n  is provided without any.     target  (string | boolean)  \n  Cache the file on the executing machine, equivalent to cache unless an ssh\n  connection is provided. If a string is provided, it will be the cache path.\n  Default to the basename of source.",
            "title": "Options"
        },
        {
            "location": "/file/cache.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value is \"true\" if cache file was created or modified.",
            "title": "Callback Parameters"
        },
        {
            "location": "/file/cache.coffee/#http-example",
            "text": "require('nikita').download({\n  source: 'https://github.com/wdavidw/node-nikita/tarball/v0.0.1',\n  cache_dir: '/var/tmp'\n}, function(err, status){\n  console.log(err ? err.message : 'File downloaded: ' + status);\n});",
            "title": "HTTP example"
        },
        {
            "location": "/file/cache.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering file.cache\", level: 'DEBUG', module: 'nikita/lib/file/cache'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  options.source = options.argument if options.argument?\n  throw Error \"Missing source: '#{options.source}'\" unless options.source\n  throw Error \"Missing one of 'target', 'cache_file' or 'cache_dir' option\" unless options.cache_file or options.target or options.cache_dir\n  options.target ?= options.cache_file\n  options.target ?= path.basename options.source\n  options.target = path.resolve options.cache_dir, options.target\n  options.source = options.source.substr 7 if /^file:\\/\\//.test options.source\n  options.headers ?= []\n  if options.md5?\n    throw Error \"Invalid MD5 Hash:#{options.md5}\" unless typeof options.md5 in ['string', 'boolean']\n    algo = 'md5'\n    hash = options.md5\n  else if options.sha1?\n    throw Error \"Invalid SHA-1 Hash:#{options.sha1}\" unless typeof options.sha1 in ['string', 'boolean']\n    algo = 'sha1'\n    hash = options.sha1\n  else if options.sha256?\n    throw Error \"Invalid SHA-1 Hash:#{options.sha256}\" unless typeof options.sha256 in ['string', 'boolean']\n    algo = 'sha256'\n    hash = options.sha256\n  else\n    algo = 'md5'\n    hash = false\n  u = url.parse options.source\n  @call (_, callback) ->\n    unless u.protocol is null\n      options.log message: \"Bypass source hash computation for non-file protocols\", level: 'WARN', module: 'nikita/lib/file/cache'\n      return callback()\n    return callback() if hash isnt true\n    file.hash ssh, options.source, algo, (err, value) ->\n      return callback err if err\n      options.log message: \"Computed hash value is '#{value}'\", level: 'INFO', module: 'nikita/lib/file/cache'\n      hash = value\n      callback()\n  # Download the file if\n  # - file doesnt exist\n  # - option force is provided\n  # - hash isnt true and doesnt match\n  @call shy: true, (_, callback) ->\n    options.log message: \"Check if target (#{options.target}) exists\", level: 'DEBUG', module: 'nikita/lib/file/cache'\n    @fs.exists ssh: options.ssh, target: options.target, (err, exists) =>\n      return callback err if err\n      if exists\n        options.log message: \"Target file exists\", level: 'INFO', module: 'nikita/lib/file/cache'\n        # If no checksum , we ignore MD5 check\n        if options.force\n          options.log message: \"Force mode, cache will be overwritten\", level: 'DEBUG', module: 'nikita/lib/file/cache'\n          return callback null, true\n        else if hash and typeof hash is 'string'\n          # then we compute the checksum of the file\n          options.log message: \"Comparing #{algo} hash\", level: 'DEBUG', module: 'nikita/lib/file/cache'\n          file.hash ssh, options.target, algo, (err, c_hash) =>\n            return callback err if err\n            # And compare with the checksum provided by the user\n            if hash is c_hash\n              options.log message: \"Hashes match, skipping\", level: 'DEBUG', module: 'nikita/lib/file/cache'\n              return callback null, false\n            options.log message: \"Hashes don't match, delete then re-download\", level: 'WARN', module: 'nikita/lib/file/cache'\n            @fs.unlink ssh: options.ssh, target: options.target, (err) ->\n              return callback err if err\n              callback null, true\n        else\n          options.log message: \"Target file exists, check disabled, skipping\", level: 'DEBUG', module: 'nikita/lib/file/cache'\n          callback null, false\n      else\n        options.log message: \"Target file does not exists\", level: 'INFO', module: 'nikita/lib/file/cache'\n        callback null, true\n  , (err, status) ->\n    @end() unless status\n  # Place into cache\n  if u.protocol in protocols_http\n    fail = if options.fail then \"--fail\" else ''\n    k = if u.protocol is 'https:' then '-k' else ''\n    cmd = \"curl #{fail} #{k} -s #{options.source} -o #{options.target}\"\n    cmd += \" --location\" if options.location\n    cmd += \" --header \\\"#{header}\\\"\" for header in options.headers\n    cmd += \" -x #{options.proxy}\" if options.proxy\n    @system.mkdir\n      ssh: if options.cache_local then false else ssh\n      target: path.dirname options.target\n    @system.execute\n      cmd: cmd\n      ssh: if options.cache_local then false else ssh\n      unless_exists: options.target\n  else\n    @system.mkdir # todo: copy shall handle this\n      target: \"#{path.dirname options.target}\"\n    @system.copy\n      source: \"#{options.source}\"\n      target: \"#{options.target}\"\n  # TODO: validate the cache\n  @next (err, status) ->\n    callback err, status, options.target\n\nmodule.exports.protocols_http = protocols_http = ['http:', 'https:']\nmodule.exports.protocols_ftp = protocols_ftp = ['ftp:', 'ftps:']",
            "title": "Source Code"
        },
        {
            "location": "/file/cache.coffee/#dependencies",
            "text": "path = require 'path'\nurl = require 'url'\ncurl = require '../misc/curl'\nfile = require '../misc/file'",
            "title": "Dependencies"
        },
        {
            "location": "/file/cson.coffee/",
            "text": "nikita.file.cson(options, callback)\n\n\nOptions\n\n\n\n\nbackup\n (string|boolean) \n\n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.\n\n\ncontent\n \n\n  Object to stringify.   \n\n\ntarget\n \n\n  File path where to write content to or a callback.   \n\n\nmerge\n \n\n  Read the target if it exists and merge its content.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nwritten\n \n\n  Number of written actions with modifications.   \n\n\n\n\nExample\n\n\nrequire('nikita').file.yaml({\n  content: {\n    'my_key': 'my value'\n  },\n  target: '/tmp/my_file'\n}, function(err, written){\n  console.log(err ? err.message : 'Content was updated: ' + !!written);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering file.yaml\", level: 'DEBUG', module: 'nikita/lib/file/yaml'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  options.line_width ?= 160\n  options.clean ?= true\n  options.encoding ?= 'utf8'\n  # Validate parameters\n  throw Error 'Required Option: content' unless options.content\n  throw Error 'Required Option: target' unless options.target\n  # Start real work\n  @call\n    if: options.merge\n  , ->\n    options.log message: \"Get Target Content\", level: 'DEBUG', module: 'nikita/lib/file/cson'\n    @fs.readFile\n      ssh: options.ssh\n      target: options.target\n      encoding: options.encoding\n    , (err, content) ->\n      # File does not exists, this is ok, there is simply nothing to merge\n      if err?.code is 'ENOENT'\n        options.log message: \"No Target Content To Merged\", level: 'DEBUG', module: 'nikita/lib/file/cson'\n        return\n      throw err if err\n      try\n        content = season.parse content\n        options.content = misc.merge content, options.content\n        options.log message: \"Target Content Merged\", level: 'DEBUG', module: 'nikita/lib/file/cson'\n      catch err\n        # Maybe change error message with sth like \"Failed to parse...\"\n        throw err\n  @call ->\n    options.log message: \"Serialize Content\", level: 'DEBUG', module: 'nikita/lib/file/cson'\n    @file\n      content: season.stringify options.content\n      target: options.target\n      backup: options.backup\n\n\n\nDependencies\n\n\nmisc = require '../misc'\nseason = require 'season'\n\n\n\nResources",
            "title": "Cson.coffee"
        },
        {
            "location": "/file/cson.coffee/#nikitafilecsonoptions-callback",
            "text": "",
            "title": "nikita.file.cson(options, callback)"
        },
        {
            "location": "/file/cson.coffee/#options",
            "text": "backup  (string|boolean)  \n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.  content   \n  Object to stringify.     target   \n  File path where to write content to or a callback.     merge   \n  Read the target if it exists and merge its content.",
            "title": "Options"
        },
        {
            "location": "/file/cson.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     written   \n  Number of written actions with modifications.",
            "title": "Callback parameters"
        },
        {
            "location": "/file/cson.coffee/#example",
            "text": "require('nikita').file.yaml({\n  content: {\n    'my_key': 'my value'\n  },\n  target: '/tmp/my_file'\n}, function(err, written){\n  console.log(err ? err.message : 'Content was updated: ' + !!written);\n});",
            "title": "Example"
        },
        {
            "location": "/file/cson.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering file.yaml\", level: 'DEBUG', module: 'nikita/lib/file/yaml'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  options.line_width ?= 160\n  options.clean ?= true\n  options.encoding ?= 'utf8'\n  # Validate parameters\n  throw Error 'Required Option: content' unless options.content\n  throw Error 'Required Option: target' unless options.target\n  # Start real work\n  @call\n    if: options.merge\n  , ->\n    options.log message: \"Get Target Content\", level: 'DEBUG', module: 'nikita/lib/file/cson'\n    @fs.readFile\n      ssh: options.ssh\n      target: options.target\n      encoding: options.encoding\n    , (err, content) ->\n      # File does not exists, this is ok, there is simply nothing to merge\n      if err?.code is 'ENOENT'\n        options.log message: \"No Target Content To Merged\", level: 'DEBUG', module: 'nikita/lib/file/cson'\n        return\n      throw err if err\n      try\n        content = season.parse content\n        options.content = misc.merge content, options.content\n        options.log message: \"Target Content Merged\", level: 'DEBUG', module: 'nikita/lib/file/cson'\n      catch err\n        # Maybe change error message with sth like \"Failed to parse...\"\n        throw err\n  @call ->\n    options.log message: \"Serialize Content\", level: 'DEBUG', module: 'nikita/lib/file/cson'\n    @file\n      content: season.stringify options.content\n      target: options.target\n      backup: options.backup",
            "title": "Source Code"
        },
        {
            "location": "/file/cson.coffee/#dependencies",
            "text": "misc = require '../misc'\nseason = require 'season'",
            "title": "Dependencies"
        },
        {
            "location": "/file/cson.coffee/#resources",
            "text": "",
            "title": "Resources"
        },
        {
            "location": "/file/download.coffee/",
            "text": "nikita.file.download(options, [callback])\n\n\nDownload files using various protocols.\n\n\nIn local mode (with an SSH connection), the \nhttp\n protocol is handled with the\n\"request\" module when executed locally, the \nftp\n protocol is handled with the\n\"jsftp\" and the \nfile\n protocol is handle with the native \nfs\n module.\n\n\nThe behavior of download may be confusing wether you are running over SSH or\nnot. It's philosophy mostly rely on the target point of view. When download\nrun, the target is local, compared to the upload function where target\nis remote.\n\n\nA checksum may provided with the option \"sha256\", \"sha1\" or \"md5\" to validate the uploaded\nfile signature.\n\n\nCaching is active if \"cache_dir\" or \"cache_file\" are defined to anything but false.\nIf cache_dir is not a string, default value is './'\nIf cache_file is not a string, default is source basename.\n\n\nNikita resolve the path from \"cache_dir\" to \"cache_file\", so if cache_file is an\nabsolute path, \"cache_dir\" will be ignored\n\n\nIf no cache is used, signature validation is only active if a checksum is\nprovided.\n\n\nIf cache is used, signature validation is always active, and md5sum is automatically\ncalculated if neither sha256, sh1 nor md5 is provided.\n\n\nOptions\n\n\n\n\ncache\n (boolean) \n\n  Activate the cache, default to true if either \"cache_dir\" or \"cache_file\" is\n  activated.   \n\n\ncache_dir\n (path) \n\n  If local_cache is not a string, the cache file path is resolved from cache\n  dir and cache file. \n\n  By default: './'   \n\n\ncache_file\n (string | boolean) \n\n  Cache the file on the executing machine, equivalent to cache unless an ssh\n  connection is provided. If a string is provided, it will be the cache path. \n\n  By default: basename of source   \n\n\nforce\n (boolean) \n\n  Overwrite target file if it exists.   \n\n\nforce_cache\n (boolean) \n\n  Force cache overwrite if it exists   \n\n\ngid\n \n\n  Group name or id who owns the target file.   \n\n\nheaders\n (array) \n\n  Extra  header  to include in the request when sending HTTP to a server.   \n\n\nlocation\n (boolean) \n\n  If the server reports that the requested page has moved to a different\n  location (indicated with a Location: header and a 3XX response code), this\n  option will make curl redo the request on the new place.   \n\n\nmd5\n (MD5 Hash) \n\n  Hash of the file using MD5. Used to check integrity\n\n\nmode\n (octal mode) \n\n  Permissions of the target. If specified, nikita will chmod after download   \n\n\nproxy\n (string) \n\n  Use the specified HTTP proxy. If the port number is not specified, it is\n  assumed at port 1080. See curl(1) man page.   \n\n\nsha1\n (SHA-1 Hash) \n\n  Hash of the file using SHA-1. Used to check integrity.   \n\n\nsha256\n (SHA-256 Hash) \n\n  Hash of the file using SHA-256. Used to check integrity.   \n\n\nsource\n (path) \n\n  File, HTTP URL, FTP, GIT repository. File is the default protocol if source\n  is provided without any.   \n\n\ntarget\n (path) \n\n  Path where the file is downloaded.   \n\n\nuid\n \n\n  User name or id who owns the target file.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\ndownloaded\n \n\n  Value is \"true\" if file was downloaded.   \n\n\n\n\nFile example\n\n\nrequire('nikita').download({\n  source: 'file://path/to/something',\n  target: 'node-sigar.tgz'\n}, function(err, downloaded){\n  console.log(err ? err.message : 'File was downloaded: ' + downloaded);\n});\n\n\n\n\nHTTP example\n\n\nnikita.download\n  source: 'https://github.com/wdavidw/node-nikita/tarball/v0.0.1'\n  target: 'node-sigar.tgz'\n, (err, downloaded) -> ...\n\n\n\n\nFTP example\n\n\nnikita.download\n  source: 'ftp://myhost.com:3334/wdavidw/node-nikita/tarball/v0.0.1'\n  target: 'node-sigar.tgz'\n  user: 'johndoe',\n  pass: '12345'\n, (err, downloaded) -> ...\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: 'Entering file.download', level: 'DEBUG', module: 'nikita/lib/file/download'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  throw Error \"Missing source: #{options.source}\" unless options.source\n  throw Error \"Missing target: #{options.target}\" unless options.target\n  options.source = options.source.substr 7 if /^file:\\/\\//.test options.source\n  stageDestination = null\n  if options.md5?\n    throw Error \"Invalid MD5 Hash:#{options.md5}\" unless typeof options.md5 in ['string', 'boolean']\n    algo = 'md5'\n    source_hash = options.md5\n  else if options.sha1?\n    throw Error \"Invalid SHA-1 Hash:#{options.sha1}\" unless typeof options.sha1 in ['string', 'boolean']\n    algo = 'sha1'\n    source_hash = options.sha1\n  else if options.sha256?\n    throw Error \"Invalid SHA-256 Hash:#{options.sha256}\" unless typeof options.sha256 in ['string', 'boolean']\n    algo = 'sha256'\n    source_hash = options.sha256\n  else\n    algo = 'md5'\n  protocols_http = ['http:', 'https:']\n  protocols_ftp = ['ftp:', 'ftps:']\n  # hash_info = null\n  options.log message: \"Using force: #{JSON.stringify options.force}\", level: 'DEBUG', module: 'nikita/lib/file/download'\n  source_url = url.parse options.source\n  # Disable caching if source is a local file and cache isnt exlicitly set by user\n  options.cache = false if not options.cache? and source_url.protocol is null\n  options.cache ?= !!(options.cache_dir or options.cache_file)\n  @call # Accelarator in case we know the target signature\n    if: typeof source_hash is 'string'\n    shy: true\n  , (_, callback) ->\n      options.log message: \"Shortcircuit check if provided hash match target\", level: 'WARN', module: 'nikita/lib/file/download'\n      file.hash ssh, options.target, algo, (err, hash) =>\n        err = null if err?.code is 'ENOENT'\n        callback err, source_hash is hash\n    , (err, end) ->\n      return unless end\n      options.log message: \"Destination with valid signature, download aborted\", level: 'INFO', module: 'nikita/lib/file/download'\n      @end()\n  @file.cache # Download the file and place it inside local cache\n    if: options.cache\n    ssh: false\n    source: options.source\n    cache_dir: options.cache_dir\n    cache_file: options.cache_file\n    headers: options.headers\n    md5: options.md5\n    proxy: options.proxy\n    location: options.location\n  , (err, cached, file) ->\n    throw err if err\n    options.source = file if options.cache\n    source_url = url.parse options.source\n  @fs.stat ssh: options.ssh, target: options.target, relax: true, (err, stat) ->\n    throw err if err and err.code isnt 'ENOENT'\n    if stat?.isDirectory()\n      options.log message: \"Destination is a directory\", level: 'DEBUG', module: 'nikita/lib/file/download'\n      options.target = path.join options.target, path.basename options.source\n    stageDestination = \"#{options.target}.#{Date.now()}#{Math.round(Math.random()*1000)}\"\n  @call\n    if: -> source_url.protocol in protocols_http\n  , ->\n      options.log message: \"HTTP Download\", level: 'DEBUG', module: 'nikita/lib/file/download'\n      fail = if options.fail then \"--fail\" else ''\n      k = if source_url.protocol is 'https:' then '-k' else ''\n      cmd = \"curl #{fail} #{k} -s #{options.source} -o #{stageDestination}\"\n      cmd += \" -x #{options.proxy}\" if options.proxy\n      options.log message: \"Download file from url using curl\", level: 'INFO', module: 'nikita/lib/file/download'\n      @system.mkdir\n        shy: true\n        target: path.dirname stageDestination\n      @system.execute\n        cmd: cmd\n        shy: true\n      @call\n        if: typeof source_hash is 'string'\n      , (_, callback) ->\n          file.hash ssh, stageDestination, algo, (err, hash) =>\n            return callback Error \"Invalid downloaded checksum, found '#{hash}' instead of '#{source_hash}'\" if source_hash isnt hash\n            callback()\n      @call (_, callback) ->\n        file.compare_hash (if options.cache then null else ssh), stageDestination, ssh, options.target, algo, (err, match, hash1, hash2) ->\n          options.log message: \"Hash dont match, source is '#{hash1}' and target is '#{hash2}'\", level: 'WARN', module: 'nikita/lib/file/download' unless match\n          options.log message: \"Hash matches as '#{hash1}'\", level: 'INFO', module: 'nikita/lib/file/download' if match\n          callback err, not match\n      @system.remove\n        unless: -> @status -1\n        shy: true\n        target: stageDestination\n  @call\n    if: -> source_url.protocol not in protocols_http and not ssh\n  , ->\n      options.log message: \"File Download without ssh (with or without cache)\", level: 'DEBUG', module: 'nikita/lib/file/download'\n      @call (_, callback) ->\n        file.compare_hash null, options.source, null, options.target, algo, (err, match, hash1, hash2) ->\n          options.log message: \"Hash dont match, source is '#{hash1}' and target is '#{hash2}'\", level: 'WARN', module: 'nikita/lib/file/download' unless match\n          options.log message: \"Hash matches as '#{hash1}'\", level: 'INFO', module: 'nikita/lib/file/download' if match\n          callback err, not match\n      @system.mkdir\n        if: -> @status -1\n        shy: true\n        target: path.dirname stageDestination\n      @fs.copy\n        if: -> @status -2\n        source: options.source\n        target: stageDestination\n  @call\n    if: -> source_url.protocol not in protocols_http and ssh\n  , ->\n      options.log message: \"File Download with ssh (with or without cache)\", level: 'DEBUG', module: 'nikita/lib/file/download'\n      @call (_, callback) ->\n        file.compare_hash null, options.source, ssh, options.target, algo, (err, match, hash1, hash2) ->\n          options.log message: \"Hash dont match, source is '#{hash1}' and target is '#{hash2}'\", level: 'WARN', module: 'nikita/lib/file/download' unless match\n          options.log message: \"Hash matches as '#{hash1}'\", level: 'INFO', module: 'nikita/lib/file/download' if match\n          callback err, not match\n      @system.mkdir\n        if: -> @status -1\n        shy: true\n        target: path.dirname stageDestination\n      @call\n        if: -> @status -2\n      , (_, callback) ->\n          options.log message: \"Local source: '#{options.source}'\", level: 'INFO', module: 'nikita/lib/file/download'\n          options.log message: \"Remote target: '#{stageDestination}'\", level: 'INFO', module: 'nikita/lib/file/download'\n          # TODO: incompatible with sudo\n          rs = fs.createReadStream options.source\n          rs.on 'error', (err) ->\n            console.log 'rs on error', err\n          ssh2fs.writeFile ssh, stageDestination, rs, (err) ->\n            options.log \"Upload failed from local to remote\" if err\n            callback err\n  @call ->\n    options.log message: \"Unstage downloaded file\", level: 'DEBUG', module: 'nikita/lib/file/download'\n    @system.move\n      if: @status()\n      source: stageDestination\n      target: options.target\n    @system.chmod\n      target: options.target\n      mode: options.mode\n      if: options.mode?\n    @system.chown\n      target: options.target\n      uid: options.uid\n      gid: options.gid\n      if: options.uid? or options.gid?\n\n\n\nModule Dependencies\n\n\nfs = require 'fs'\nssh2fs = require 'ssh2-fs'\npath = require('path').posix # need to detect ssh connection\nurl = require 'url'\ncurl = require '../misc/curl'\nfile = require '../misc/file'",
            "title": "Download.coffee"
        },
        {
            "location": "/file/download.coffee/#nikitafiledownloadoptions-callback",
            "text": "Download files using various protocols.  In local mode (with an SSH connection), the  http  protocol is handled with the\n\"request\" module when executed locally, the  ftp  protocol is handled with the\n\"jsftp\" and the  file  protocol is handle with the native  fs  module.  The behavior of download may be confusing wether you are running over SSH or\nnot. It's philosophy mostly rely on the target point of view. When download\nrun, the target is local, compared to the upload function where target\nis remote.  A checksum may provided with the option \"sha256\", \"sha1\" or \"md5\" to validate the uploaded\nfile signature.  Caching is active if \"cache_dir\" or \"cache_file\" are defined to anything but false.\nIf cache_dir is not a string, default value is './'\nIf cache_file is not a string, default is source basename.  Nikita resolve the path from \"cache_dir\" to \"cache_file\", so if cache_file is an\nabsolute path, \"cache_dir\" will be ignored  If no cache is used, signature validation is only active if a checksum is\nprovided.  If cache is used, signature validation is always active, and md5sum is automatically\ncalculated if neither sha256, sh1 nor md5 is provided.",
            "title": "nikita.file.download(options, [callback])"
        },
        {
            "location": "/file/download.coffee/#options",
            "text": "cache  (boolean)  \n  Activate the cache, default to true if either \"cache_dir\" or \"cache_file\" is\n  activated.     cache_dir  (path)  \n  If local_cache is not a string, the cache file path is resolved from cache\n  dir and cache file.  \n  By default: './'     cache_file  (string | boolean)  \n  Cache the file on the executing machine, equivalent to cache unless an ssh\n  connection is provided. If a string is provided, it will be the cache path.  \n  By default: basename of source     force  (boolean)  \n  Overwrite target file if it exists.     force_cache  (boolean)  \n  Force cache overwrite if it exists     gid   \n  Group name or id who owns the target file.     headers  (array)  \n  Extra  header  to include in the request when sending HTTP to a server.     location  (boolean)  \n  If the server reports that the requested page has moved to a different\n  location (indicated with a Location: header and a 3XX response code), this\n  option will make curl redo the request on the new place.     md5  (MD5 Hash)  \n  Hash of the file using MD5. Used to check integrity  mode  (octal mode)  \n  Permissions of the target. If specified, nikita will chmod after download     proxy  (string)  \n  Use the specified HTTP proxy. If the port number is not specified, it is\n  assumed at port 1080. See curl(1) man page.     sha1  (SHA-1 Hash)  \n  Hash of the file using SHA-1. Used to check integrity.     sha256  (SHA-256 Hash)  \n  Hash of the file using SHA-256. Used to check integrity.     source  (path)  \n  File, HTTP URL, FTP, GIT repository. File is the default protocol if source\n  is provided without any.     target  (path)  \n  Path where the file is downloaded.     uid   \n  User name or id who owns the target file.",
            "title": "Options"
        },
        {
            "location": "/file/download.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     downloaded   \n  Value is \"true\" if file was downloaded.",
            "title": "Callback parameters"
        },
        {
            "location": "/file/download.coffee/#file-example",
            "text": "require('nikita').download({\n  source: 'file://path/to/something',\n  target: 'node-sigar.tgz'\n}, function(err, downloaded){\n  console.log(err ? err.message : 'File was downloaded: ' + downloaded);\n});",
            "title": "File example"
        },
        {
            "location": "/file/download.coffee/#http-example",
            "text": "nikita.download\n  source: 'https://github.com/wdavidw/node-nikita/tarball/v0.0.1'\n  target: 'node-sigar.tgz'\n, (err, downloaded) -> ...",
            "title": "HTTP example"
        },
        {
            "location": "/file/download.coffee/#ftp-example",
            "text": "nikita.download\n  source: 'ftp://myhost.com:3334/wdavidw/node-nikita/tarball/v0.0.1'\n  target: 'node-sigar.tgz'\n  user: 'johndoe',\n  pass: '12345'\n, (err, downloaded) -> ...",
            "title": "FTP example"
        },
        {
            "location": "/file/download.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: 'Entering file.download', level: 'DEBUG', module: 'nikita/lib/file/download'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  throw Error \"Missing source: #{options.source}\" unless options.source\n  throw Error \"Missing target: #{options.target}\" unless options.target\n  options.source = options.source.substr 7 if /^file:\\/\\//.test options.source\n  stageDestination = null\n  if options.md5?\n    throw Error \"Invalid MD5 Hash:#{options.md5}\" unless typeof options.md5 in ['string', 'boolean']\n    algo = 'md5'\n    source_hash = options.md5\n  else if options.sha1?\n    throw Error \"Invalid SHA-1 Hash:#{options.sha1}\" unless typeof options.sha1 in ['string', 'boolean']\n    algo = 'sha1'\n    source_hash = options.sha1\n  else if options.sha256?\n    throw Error \"Invalid SHA-256 Hash:#{options.sha256}\" unless typeof options.sha256 in ['string', 'boolean']\n    algo = 'sha256'\n    source_hash = options.sha256\n  else\n    algo = 'md5'\n  protocols_http = ['http:', 'https:']\n  protocols_ftp = ['ftp:', 'ftps:']\n  # hash_info = null\n  options.log message: \"Using force: #{JSON.stringify options.force}\", level: 'DEBUG', module: 'nikita/lib/file/download'\n  source_url = url.parse options.source\n  # Disable caching if source is a local file and cache isnt exlicitly set by user\n  options.cache = false if not options.cache? and source_url.protocol is null\n  options.cache ?= !!(options.cache_dir or options.cache_file)\n  @call # Accelarator in case we know the target signature\n    if: typeof source_hash is 'string'\n    shy: true\n  , (_, callback) ->\n      options.log message: \"Shortcircuit check if provided hash match target\", level: 'WARN', module: 'nikita/lib/file/download'\n      file.hash ssh, options.target, algo, (err, hash) =>\n        err = null if err?.code is 'ENOENT'\n        callback err, source_hash is hash\n    , (err, end) ->\n      return unless end\n      options.log message: \"Destination with valid signature, download aborted\", level: 'INFO', module: 'nikita/lib/file/download'\n      @end()\n  @file.cache # Download the file and place it inside local cache\n    if: options.cache\n    ssh: false\n    source: options.source\n    cache_dir: options.cache_dir\n    cache_file: options.cache_file\n    headers: options.headers\n    md5: options.md5\n    proxy: options.proxy\n    location: options.location\n  , (err, cached, file) ->\n    throw err if err\n    options.source = file if options.cache\n    source_url = url.parse options.source\n  @fs.stat ssh: options.ssh, target: options.target, relax: true, (err, stat) ->\n    throw err if err and err.code isnt 'ENOENT'\n    if stat?.isDirectory()\n      options.log message: \"Destination is a directory\", level: 'DEBUG', module: 'nikita/lib/file/download'\n      options.target = path.join options.target, path.basename options.source\n    stageDestination = \"#{options.target}.#{Date.now()}#{Math.round(Math.random()*1000)}\"\n  @call\n    if: -> source_url.protocol in protocols_http\n  , ->\n      options.log message: \"HTTP Download\", level: 'DEBUG', module: 'nikita/lib/file/download'\n      fail = if options.fail then \"--fail\" else ''\n      k = if source_url.protocol is 'https:' then '-k' else ''\n      cmd = \"curl #{fail} #{k} -s #{options.source} -o #{stageDestination}\"\n      cmd += \" -x #{options.proxy}\" if options.proxy\n      options.log message: \"Download file from url using curl\", level: 'INFO', module: 'nikita/lib/file/download'\n      @system.mkdir\n        shy: true\n        target: path.dirname stageDestination\n      @system.execute\n        cmd: cmd\n        shy: true\n      @call\n        if: typeof source_hash is 'string'\n      , (_, callback) ->\n          file.hash ssh, stageDestination, algo, (err, hash) =>\n            return callback Error \"Invalid downloaded checksum, found '#{hash}' instead of '#{source_hash}'\" if source_hash isnt hash\n            callback()\n      @call (_, callback) ->\n        file.compare_hash (if options.cache then null else ssh), stageDestination, ssh, options.target, algo, (err, match, hash1, hash2) ->\n          options.log message: \"Hash dont match, source is '#{hash1}' and target is '#{hash2}'\", level: 'WARN', module: 'nikita/lib/file/download' unless match\n          options.log message: \"Hash matches as '#{hash1}'\", level: 'INFO', module: 'nikita/lib/file/download' if match\n          callback err, not match\n      @system.remove\n        unless: -> @status -1\n        shy: true\n        target: stageDestination\n  @call\n    if: -> source_url.protocol not in protocols_http and not ssh\n  , ->\n      options.log message: \"File Download without ssh (with or without cache)\", level: 'DEBUG', module: 'nikita/lib/file/download'\n      @call (_, callback) ->\n        file.compare_hash null, options.source, null, options.target, algo, (err, match, hash1, hash2) ->\n          options.log message: \"Hash dont match, source is '#{hash1}' and target is '#{hash2}'\", level: 'WARN', module: 'nikita/lib/file/download' unless match\n          options.log message: \"Hash matches as '#{hash1}'\", level: 'INFO', module: 'nikita/lib/file/download' if match\n          callback err, not match\n      @system.mkdir\n        if: -> @status -1\n        shy: true\n        target: path.dirname stageDestination\n      @fs.copy\n        if: -> @status -2\n        source: options.source\n        target: stageDestination\n  @call\n    if: -> source_url.protocol not in protocols_http and ssh\n  , ->\n      options.log message: \"File Download with ssh (with or without cache)\", level: 'DEBUG', module: 'nikita/lib/file/download'\n      @call (_, callback) ->\n        file.compare_hash null, options.source, ssh, options.target, algo, (err, match, hash1, hash2) ->\n          options.log message: \"Hash dont match, source is '#{hash1}' and target is '#{hash2}'\", level: 'WARN', module: 'nikita/lib/file/download' unless match\n          options.log message: \"Hash matches as '#{hash1}'\", level: 'INFO', module: 'nikita/lib/file/download' if match\n          callback err, not match\n      @system.mkdir\n        if: -> @status -1\n        shy: true\n        target: path.dirname stageDestination\n      @call\n        if: -> @status -2\n      , (_, callback) ->\n          options.log message: \"Local source: '#{options.source}'\", level: 'INFO', module: 'nikita/lib/file/download'\n          options.log message: \"Remote target: '#{stageDestination}'\", level: 'INFO', module: 'nikita/lib/file/download'\n          # TODO: incompatible with sudo\n          rs = fs.createReadStream options.source\n          rs.on 'error', (err) ->\n            console.log 'rs on error', err\n          ssh2fs.writeFile ssh, stageDestination, rs, (err) ->\n            options.log \"Upload failed from local to remote\" if err\n            callback err\n  @call ->\n    options.log message: \"Unstage downloaded file\", level: 'DEBUG', module: 'nikita/lib/file/download'\n    @system.move\n      if: @status()\n      source: stageDestination\n      target: options.target\n    @system.chmod\n      target: options.target\n      mode: options.mode\n      if: options.mode?\n    @system.chown\n      target: options.target\n      uid: options.uid\n      gid: options.gid\n      if: options.uid? or options.gid?",
            "title": "Source Code"
        },
        {
            "location": "/file/download.coffee/#module-dependencies",
            "text": "fs = require 'fs'\nssh2fs = require 'ssh2-fs'\npath = require('path').posix # need to detect ssh connection\nurl = require 'url'\ncurl = require '../misc/curl'\nfile = require '../misc/file'",
            "title": "Module Dependencies"
        },
        {
            "location": "/file/index.coffee/",
            "text": "nikita.file(options, callback)\n\n\nWrite a file or a portion of an existing file.\n\n\nOptions\n\n\n\n\nappend\n \n\n  Append the content to the target file. If target does not exist,\n  the file will be created.\n\n\nbackup\n (string|boolean) \n\n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.\n\n\nbackup_mode\n \n\n  Backup file mode (permission and sticky bits), defaults to \n0o0400\n, in the \n  form of \n{mode: 0o0400}\n or \n{mode: \"0400\"}\n.\n\n\ncontent\n \n\n  Text to be written, an alternative to source which reference a file.\n\n\ndiff\n (boolean | function) \n\n  Print diff information, pass a readable diff and the result of \njsdiff.diffLines\n as\n  arguments if a function, default to true.\n\n\neof\n \n\n  Ensure the file ends with this charactere sequence, special values are\n  'windows', 'mac', 'unix' and 'unicode' (respectively \"\\r\\n\", \"\\r\", \"\\n\",\n  \"\\u2028\"), will be auto-detected if \"true\", default to false or \"\\n\" if\n  \"true\" and not detected.\n\n\nfrom\n \n\n  Replace from after this marker, a string or a regular expression.\n\n\ngid\n \n\n  File group name or group id.\n\n\nlocal\n \n\n  Treat the source as local instead of remote, only apply with \"ssh\"\n  option.\n\n\nmatch\n \n\n  Replace this marker, a string or a regular expression, default to the\n  replaced string if missing.\n\n\nmode\n \n\n  File mode (permission and sticky bits), default to \n0o0644\n, in the form of\n  \n{mode: 0o0744}\n or \n{mode: \"0744\"}\n.\n\n\nplace_before\n (string, boolean, regex) \n\n  Place the content before the match.\n\n\nreplace\n \n\n  The content to be inserted, used conjointly with the from, to or match\n  options.\n\n\nsource\n \n\n  File path from where to extract the content, do not use conjointly with\n  content.\n\n\ntarget\n \n\n  File path where to write content to.\n\n\nto\n \n\n  Replace to before this marker, a string or a regular expression.\n\n\nuid\n \n\n  File user name or user id.\n\n\nunlink\n (boolean) \n\n  Replace the existing link, leaving the refered file untouched.\n\n\nwrite\n \n\n  An array containing multiple transformation where a transformation is an\n  object accepting the options \nfrom\n, \nto\n, \nmatch\n and \nreplace\n.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  Indicate file modifications.\n\n\n\n\nImplementation details\n\n\nInternally, this function uses the \"chmod\" and \"chown\" function and, thus,\nhonor all their options including \"mode\", \"uid\" and \"gid\".\n\n\nDiff Lines\n\n\nDiff can be obtained when the options \"diff\" is set to true or a function. The\ninformation is provided in two ways:\n\n\n\n\nwhen \ntrue\n, a formated string written to the \"stdout\" option.\n\n\nwhen a function, a readable diff and the array returned by the function \n  \ndiff.diffLines\n, see the \ndiffLines\n package for additionnal information.\n\n\n\n\nMore about the \nappend\n option\n\n\nThe \nappend\n option allows more advanced usages. If \nappend\n is \"null\", it will\nadd the value of the \"replace\" option at the end of the file when no match\nis found and when the value is a string.\n\n\nUsing the \nappend\n option conjointly with the \nmatch\n and \nreplace\n options gets\neven more interesting. If append is a string or a regular expression, it will\nplace the value of the \"replace\" option just after the match. Internally, a\nstring value will be converted to a regular expression. For example the string\n\"test\" will end up converted to the regular expression \n/test/mg\n.\n\n\nReplacing part of a file using from and to markers\n\n\nrequire('nikita').file({\n  content: 'here we are\\n# from\\nlets try to replace that one\\n# to\\nyou coquin',\n  from: '# from\\n',\n  to: '# to',\n  replace: 'my friend\\n',\n  target: scratch+'/a_file'\n}, function(err, written){\n  // '# here we are\\n# from\\nmy friend\\n# to\\nyou coquin'\n})\n\n\n\n\nReplacing a matched line by a string\n\n\nrequire('nikita').file({\n  content: 'email=david(at)adaltas(dot)com\\nusername=root',\n  match: /(username)=(.*)/,\n  replace: '$1=david (was $2)',\n  target: scratch+'/a_file'\n}, function(err, written){\n  // '# email=david(at)adaltas(dot)com\\nusername=david (was root)'\n})\n\n\n\n\nReplacing part of a file using a regular expression\n\n\nrequire('nikita').file({\n  content: 'here we are\\nlets try to replace that one\\nyou coquin',\n  match: /(.*try) (.*)/,\n  replace: ['my friend, $1'],\n  target: scratch+'/a_file'\n}, function(err, written){\n  // '# here we are\\nmy friend, lets try\\nyou coquin'\n})\n\n\n\n\nReplacing with the global and multiple lines options\n\n\nrequire('nikita').file({\n  content: '#A config file\\n#property=30\\nproperty=10\\n#End of Config',\n  match: /^property=.*$/mg,\n  replace: 'property=50',\n  target: scratch+'/a_file'\n}, function(err, written){\n  // '# A config file\\n#property=30\\nproperty=50\\n#End of Config'\n})\n\n\n\n\nAppending a line after each line containing \"property\"\n\n\nrequire('nikita').file({\n  content: '#A config file\\n#property=30\\nproperty=10\\n#End of Config',\n  match: /^.*comment.*$/mg,\n  replace: '# comment',\n  target: scratch+'/a_file',\n  append: 'property'\n}, function(err, written){\n  // '# A config file\\n#property=30\\n# comment\\nproperty=50\\n# comment\\n#End of Config'\n})\n\n\n\n\nMultiple transformations\n\n\nrequire('nikita').file({\n  content: 'username: me\\nemail: my@email\\nfriends: you',\n  write: [\n    {match: /^(username).*$/mg, replace: '$1: you'},\n    {match: /^email.*$/mg, replace: ''},\n    {match: /^(friends).*$/mg, replace: '$1: me'}\n  ],\n  target: scratch+'/a_file'\n}, function(err, written){\n  // 'username: you\\n\\nfriends: me'\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering file\", level: 'DEBUG', module: 'nikita/lib/file'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Validate parameters\n  return throw Error 'Missing source or content' unless (options.source or options.content?) or options.replace or options.write?\n  return throw Error 'Define either source or content' if options.source and options.content\n  return throw Error 'Missing target' unless options.target\n  options.log message: \"Source is \\\"#{options.source}\\\"\", level: 'DEBUG', module: 'nikita/lib/file'\n  options.log message: \"Destination is \\\"#{options.target}\\\"\", level: 'DEBUG', module: 'nikita/lib/file'\n  options.content = options.content.toString() if options.content and Buffer.isBuffer options.content\n  options.content = options.content options if typeof options.content is 'function'\n  options.diff ?= options.diff or !!options.stdout\n  options.engine ?= 'nunjunks'\n  options.unlink ?= false\n  options.encoding ?= 'utf8'\n  switch options.eof\n    when 'unix'\n      options.eof = \"\\n\"\n    when 'mac'\n      options.eof = \"\\r\"\n    when 'windows'\n      options.eof = \"\\r\\n\"\n    when 'unicode'\n      options.eof = \"\\u2028\"\n  target  = null\n  targetHash = null\n  options.write ?= []\n  if options.from? or options.to? or options.match? or options.replace? or options.place_before?\n    options.write.push\n      from: options.from\n      to: options.to\n      match: options.match\n      replace: options.replace\n      append: options.append\n      place_before: options.place_before\n    options.append = false\n  for w in options.write\n    if not w.from? and not w.to? and not w.match? and w.replace?\n      w.match = w.replace\n  # Start work\n  @call (_, callback) -> # read source\n    if options.content?\n      options.content = \"#{options.content}\" if typeof options.content is 'number'\n      return callback()\n    # Option \"local\" force to bypass the ssh\n    # connection, use by the upload function\n    source = options.source or options.target\n    options.log message: \"Force local source is \\\"#{if options.local then 'true' else 'false'}\\\"\", level: 'DEBUG', module: 'nikita/lib/file'\n    @fs.exists\n      ssh: if options.local then false else options.ssh\n      target: source\n    , (err, exists) ->\n      return callback err if err\n      unless exists\n        return callback Error \"Source does not exist: #{JSON.stringify options.source}\" if options.source\n        options.content = ''\n        return callback()\n      options.log message: \"Reading source\", level: 'DEBUG', module: 'nikita/lib/file'\n      @fs.readFile\n        ssh: if options.local then false else options.ssh\n        target: source\n        encoding: options.encoding\n      , (err, src) ->\n        return callback err if err\n        options.content = src\n        callback()\n  targetStat = null\n  @call (_, callback) -> # read target\n    # no need to test changes if target is a callback\n    return callback() if typeof options.target is 'function'\n    exists = =>\n      options.log message: \"Stat target\", level: 'DEBUG', module: 'nikita/lib/file'\n      @fs.lstat ssh: options.ssh, target: options.target, relax: true, (err, stat) ->\n        return do_mkdir() if err?.code is 'ENOENT'\n        return callback err if err\n        targetStat = stat\n        if stat.isDirectory()\n          options.target = \"#{options.target}/#{path.basename options.source}\"\n          options.log message: \"Destination is a directory and is now \\\"options.target\\\"\", level: 'INFO', module: 'nikita/lib/file'\n          # Destination is the parent directory, let's see if the file exist inside\n          @fs.stat ssh: options.ssh, target: options.target, (err, stat) ->\n            if err?.code is 'ENOENT'\n              options.log message: \"New target does not exist\", level: 'INFO', module: 'nikita/lib/file'\n              return callback()\n            return callback err if err\n            return callback Error \"Destination is not a file: #{options.target}\" unless stat.isFile()\n            options.log message: \"New target exist\", level: 'INFO', module: 'nikita/lib/file'\n            targetStat = stat\n            do_read()\n        else if stat.isSymbolicLink()\n          options.log message: \"Destination is a symlink\", level: 'INFO', module: 'nikita/lib/file'\n          return do_read() unless options.unlink\n          @fs.unlink ssh: options.ssh, target: options.target, (err) ->\n            return callback err if err\n            callback() # Dont go to mkdir since parent dir exists\n        else if stat.isFile()\n          options.log message: \"Destination is a file\", level: 'INFO', module: 'nikita/lib/file'\n          do_read()\n        else\n          callback Error \"Invalid File Type Destination: #{options.target}\"\n    do_mkdir = =>\n      options.mode = parseInt(options.mode, 8) if typeof options.mode is 'string' \n      @system.mkdir\n        target: path.dirname options.target\n        uid: options.uid\n        gid: options.gid\n        # force execution right on mkdir\n        mode: if options.mode then (options.mode | 0o111) else 0o755 \n        # Modify uid and gid if the dir does not yet exists\n        unless_exists: path.dirname options.target\n      , (err, created) ->\n        return callback err if err\n        callback()\n    do_read = =>\n      options.log message: \"Reading target\", level: 'DEBUG', module: 'nikita/lib/file'\n      @fs.readFile ssh: options.ssh, target: options.target, encoding: options.encoding, (err, dest) ->\n        return callback err if err\n        target = dest # only used by diff\n        targetHash = string.hash dest\n        callback()\n    exists()\n  @call  -> # render\n    string.render options if options.context?\n  @call -> # skip_empty_lines\n    return unless options.skip_empty_lines?\n    options.log message: \"Skip empty lines\", level: 'DEBUG', module: 'nikita/lib/file'\n    options.content = options.content.replace /(\\r\\n|[\\n\\r\\u0085\\u2028\\u2029])\\s*(\\r\\n|[\\n\\r\\u0085\\u2028\\u2029])/g, \"$1\"\n  @call -> # replace_partial\n    string.replace_partial options if options.write.length\n  @call -> # eof\n    return unless options.eof?\n    options.log message: 'Checking option eof', level: 'DEBUG', module: 'nikita/lib/file'\n    if options.eof is true\n      for char, i in options.content\n        if char is '\\r'\n          options.eof = if options.content[i+1] is '\\n' then '\\r\\n' else char\n          break\n        if char is '\\n' or char is '\\u2028'\n          options.eof = char\n          break;\n      options.eof = '\\n' if options.eof is true\n      options.log message: \"Option eof is true, guessing as #{JSON.stringify options.eof}\", level: 'INFO', module: 'nikita/lib/file'\n    unless string.endsWith options.content, options.eof\n      options.log message: 'Add eof', level: 'INFO', module: 'nikita/lib/file'\n      options.content += options.eof\n  @call (_, callback) -> # diff\n    return callback() if targetHash is string.hash options.content\n    options.log message: \"File content has changed: #{options.target}\", level: 'WARN', module: 'nikita/lib/file'\n    {raw, text} = diff target, options.content, options\n    options.diff text, raw if typeof options.diff is 'function'\n    options.log message: text, type: 'diff', level: 'INFO', module: 'nikita/lib/file'\n    callback null, true\n  @call -> # backup\n    return unless @status()\n    return unless options.backup and targetHash\n    options.log message: \"Create backup\", level: 'INFO', module: 'nikita/lib/file'\n    options.backup_mode ?= 0o0400\n    backup = if typeof options.backup is 'string' then options.backup else \".#{Date.now()}\"\n    @system.copy\n      ssh: options.ssh\n      source: options.target\n      target: \"#{options.target}#{backup}\"\n      mode: options.backup_mode\n  @call (_, callback) -> # file\n    return callback() unless @status()\n    if typeof options.target is 'function'\n      options.log message: 'Write target with user function', level: 'INFO', module: 'nikita/lib/file'\n      options.target options.content\n      return callback()\n    options.flags ?= 'a' if options.append\n    # Ownership and permission are also handled\n    # Mode is setted by default here to avoid a chmod 644 on existing file if option.mode is not specified\n    options.mode ?= 0o0644\n    @fs.writeFile\n      target: options.target\n      flags: options.flags\n      content: options.content\n    , callback\n  @system.uid_gid\n    uid: options.uid\n    gid: options.gid\n    shy: true\n  , (err, status, {uid, gid, default_gid}) ->\n    options.uid = uid\n    options.gid = unless targetStat then default_gid else gid\n  @call ->\n    # Option gid is set at runtime if target is a new file\n    @system.chown\n      target: options.target\n      stat: targetStat\n      ssh: options.ssh\n      sudo: options.sudo\n      uid: options.uid\n      gid: options.gid\n      if: options.uid? or options.gid?\n      unless: options.target is 'function'\n  @system.chmod\n    target: options.target\n    stat: targetStat\n    ssh: options.ssh\n    sudo: options.sudo\n    mode: options.mode\n    if: options.mode?\n    unless: options.target is 'function'\n\n\n\nDependencies\n\n\npath = require 'path'\neco = require 'eco'\nnunjucks = require 'nunjucks/src/environment'\nmisc = require '../misc'\ndiff = require '../misc/diff'\nstring = require '../misc/string'",
            "title": "Index.coffee"
        },
        {
            "location": "/file/index.coffee/#nikitafileoptions-callback",
            "text": "Write a file or a portion of an existing file.",
            "title": "nikita.file(options, callback)"
        },
        {
            "location": "/file/index.coffee/#options",
            "text": "append   \n  Append the content to the target file. If target does not exist,\n  the file will be created.  backup  (string|boolean)  \n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.  backup_mode   \n  Backup file mode (permission and sticky bits), defaults to  0o0400 , in the \n  form of  {mode: 0o0400}  or  {mode: \"0400\"} .  content   \n  Text to be written, an alternative to source which reference a file.  diff  (boolean | function)  \n  Print diff information, pass a readable diff and the result of  jsdiff.diffLines  as\n  arguments if a function, default to true.  eof   \n  Ensure the file ends with this charactere sequence, special values are\n  'windows', 'mac', 'unix' and 'unicode' (respectively \"\\r\\n\", \"\\r\", \"\\n\",\n  \"\\u2028\"), will be auto-detected if \"true\", default to false or \"\\n\" if\n  \"true\" and not detected.  from   \n  Replace from after this marker, a string or a regular expression.  gid   \n  File group name or group id.  local   \n  Treat the source as local instead of remote, only apply with \"ssh\"\n  option.  match   \n  Replace this marker, a string or a regular expression, default to the\n  replaced string if missing.  mode   \n  File mode (permission and sticky bits), default to  0o0644 , in the form of\n   {mode: 0o0744}  or  {mode: \"0744\"} .  place_before  (string, boolean, regex)  \n  Place the content before the match.  replace   \n  The content to be inserted, used conjointly with the from, to or match\n  options.  source   \n  File path from where to extract the content, do not use conjointly with\n  content.  target   \n  File path where to write content to.  to   \n  Replace to before this marker, a string or a regular expression.  uid   \n  File user name or user id.  unlink  (boolean)  \n  Replace the existing link, leaving the refered file untouched.  write   \n  An array containing multiple transformation where a transformation is an\n  object accepting the options  from ,  to ,  match  and  replace .",
            "title": "Options"
        },
        {
            "location": "/file/index.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  Indicate file modifications.",
            "title": "Callback parameters"
        },
        {
            "location": "/file/index.coffee/#implementation-details",
            "text": "Internally, this function uses the \"chmod\" and \"chown\" function and, thus,\nhonor all their options including \"mode\", \"uid\" and \"gid\".",
            "title": "Implementation details"
        },
        {
            "location": "/file/index.coffee/#diff-lines",
            "text": "Diff can be obtained when the options \"diff\" is set to true or a function. The\ninformation is provided in two ways:   when  true , a formated string written to the \"stdout\" option.  when a function, a readable diff and the array returned by the function \n   diff.diffLines , see the  diffLines  package for additionnal information.",
            "title": "Diff Lines"
        },
        {
            "location": "/file/index.coffee/#more-about-the-append-option",
            "text": "The  append  option allows more advanced usages. If  append  is \"null\", it will\nadd the value of the \"replace\" option at the end of the file when no match\nis found and when the value is a string.  Using the  append  option conjointly with the  match  and  replace  options gets\neven more interesting. If append is a string or a regular expression, it will\nplace the value of the \"replace\" option just after the match. Internally, a\nstring value will be converted to a regular expression. For example the string\n\"test\" will end up converted to the regular expression  /test/mg .",
            "title": "More about the append option"
        },
        {
            "location": "/file/index.coffee/#replacing-part-of-a-file-using-from-and-to-markers",
            "text": "require('nikita').file({\n  content: 'here we are\\n# from\\nlets try to replace that one\\n# to\\nyou coquin',\n  from: '# from\\n',\n  to: '# to',\n  replace: 'my friend\\n',\n  target: scratch+'/a_file'\n}, function(err, written){\n  // '# here we are\\n# from\\nmy friend\\n# to\\nyou coquin'\n})",
            "title": "Replacing part of a file using from and to markers"
        },
        {
            "location": "/file/index.coffee/#replacing-a-matched-line-by-a-string",
            "text": "require('nikita').file({\n  content: 'email=david(at)adaltas(dot)com\\nusername=root',\n  match: /(username)=(.*)/,\n  replace: '$1=david (was $2)',\n  target: scratch+'/a_file'\n}, function(err, written){\n  // '# email=david(at)adaltas(dot)com\\nusername=david (was root)'\n})",
            "title": "Replacing a matched line by a string"
        },
        {
            "location": "/file/index.coffee/#replacing-part-of-a-file-using-a-regular-expression",
            "text": "require('nikita').file({\n  content: 'here we are\\nlets try to replace that one\\nyou coquin',\n  match: /(.*try) (.*)/,\n  replace: ['my friend, $1'],\n  target: scratch+'/a_file'\n}, function(err, written){\n  // '# here we are\\nmy friend, lets try\\nyou coquin'\n})",
            "title": "Replacing part of a file using a regular expression"
        },
        {
            "location": "/file/index.coffee/#replacing-with-the-global-and-multiple-lines-options",
            "text": "require('nikita').file({\n  content: '#A config file\\n#property=30\\nproperty=10\\n#End of Config',\n  match: /^property=.*$/mg,\n  replace: 'property=50',\n  target: scratch+'/a_file'\n}, function(err, written){\n  // '# A config file\\n#property=30\\nproperty=50\\n#End of Config'\n})",
            "title": "Replacing with the global and multiple lines options"
        },
        {
            "location": "/file/index.coffee/#appending-a-line-after-each-line-containing-property",
            "text": "require('nikita').file({\n  content: '#A config file\\n#property=30\\nproperty=10\\n#End of Config',\n  match: /^.*comment.*$/mg,\n  replace: '# comment',\n  target: scratch+'/a_file',\n  append: 'property'\n}, function(err, written){\n  // '# A config file\\n#property=30\\n# comment\\nproperty=50\\n# comment\\n#End of Config'\n})",
            "title": "Appending a line after each line containing \"property\""
        },
        {
            "location": "/file/index.coffee/#multiple-transformations",
            "text": "require('nikita').file({\n  content: 'username: me\\nemail: my@email\\nfriends: you',\n  write: [\n    {match: /^(username).*$/mg, replace: '$1: you'},\n    {match: /^email.*$/mg, replace: ''},\n    {match: /^(friends).*$/mg, replace: '$1: me'}\n  ],\n  target: scratch+'/a_file'\n}, function(err, written){\n  // 'username: you\\n\\nfriends: me'\n})",
            "title": "Multiple transformations"
        },
        {
            "location": "/file/index.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering file\", level: 'DEBUG', module: 'nikita/lib/file'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Validate parameters\n  return throw Error 'Missing source or content' unless (options.source or options.content?) or options.replace or options.write?\n  return throw Error 'Define either source or content' if options.source and options.content\n  return throw Error 'Missing target' unless options.target\n  options.log message: \"Source is \\\"#{options.source}\\\"\", level: 'DEBUG', module: 'nikita/lib/file'\n  options.log message: \"Destination is \\\"#{options.target}\\\"\", level: 'DEBUG', module: 'nikita/lib/file'\n  options.content = options.content.toString() if options.content and Buffer.isBuffer options.content\n  options.content = options.content options if typeof options.content is 'function'\n  options.diff ?= options.diff or !!options.stdout\n  options.engine ?= 'nunjunks'\n  options.unlink ?= false\n  options.encoding ?= 'utf8'\n  switch options.eof\n    when 'unix'\n      options.eof = \"\\n\"\n    when 'mac'\n      options.eof = \"\\r\"\n    when 'windows'\n      options.eof = \"\\r\\n\"\n    when 'unicode'\n      options.eof = \"\\u2028\"\n  target  = null\n  targetHash = null\n  options.write ?= []\n  if options.from? or options.to? or options.match? or options.replace? or options.place_before?\n    options.write.push\n      from: options.from\n      to: options.to\n      match: options.match\n      replace: options.replace\n      append: options.append\n      place_before: options.place_before\n    options.append = false\n  for w in options.write\n    if not w.from? and not w.to? and not w.match? and w.replace?\n      w.match = w.replace\n  # Start work\n  @call (_, callback) -> # read source\n    if options.content?\n      options.content = \"#{options.content}\" if typeof options.content is 'number'\n      return callback()\n    # Option \"local\" force to bypass the ssh\n    # connection, use by the upload function\n    source = options.source or options.target\n    options.log message: \"Force local source is \\\"#{if options.local then 'true' else 'false'}\\\"\", level: 'DEBUG', module: 'nikita/lib/file'\n    @fs.exists\n      ssh: if options.local then false else options.ssh\n      target: source\n    , (err, exists) ->\n      return callback err if err\n      unless exists\n        return callback Error \"Source does not exist: #{JSON.stringify options.source}\" if options.source\n        options.content = ''\n        return callback()\n      options.log message: \"Reading source\", level: 'DEBUG', module: 'nikita/lib/file'\n      @fs.readFile\n        ssh: if options.local then false else options.ssh\n        target: source\n        encoding: options.encoding\n      , (err, src) ->\n        return callback err if err\n        options.content = src\n        callback()\n  targetStat = null\n  @call (_, callback) -> # read target\n    # no need to test changes if target is a callback\n    return callback() if typeof options.target is 'function'\n    exists = =>\n      options.log message: \"Stat target\", level: 'DEBUG', module: 'nikita/lib/file'\n      @fs.lstat ssh: options.ssh, target: options.target, relax: true, (err, stat) ->\n        return do_mkdir() if err?.code is 'ENOENT'\n        return callback err if err\n        targetStat = stat\n        if stat.isDirectory()\n          options.target = \"#{options.target}/#{path.basename options.source}\"\n          options.log message: \"Destination is a directory and is now \\\"options.target\\\"\", level: 'INFO', module: 'nikita/lib/file'\n          # Destination is the parent directory, let's see if the file exist inside\n          @fs.stat ssh: options.ssh, target: options.target, (err, stat) ->\n            if err?.code is 'ENOENT'\n              options.log message: \"New target does not exist\", level: 'INFO', module: 'nikita/lib/file'\n              return callback()\n            return callback err if err\n            return callback Error \"Destination is not a file: #{options.target}\" unless stat.isFile()\n            options.log message: \"New target exist\", level: 'INFO', module: 'nikita/lib/file'\n            targetStat = stat\n            do_read()\n        else if stat.isSymbolicLink()\n          options.log message: \"Destination is a symlink\", level: 'INFO', module: 'nikita/lib/file'\n          return do_read() unless options.unlink\n          @fs.unlink ssh: options.ssh, target: options.target, (err) ->\n            return callback err if err\n            callback() # Dont go to mkdir since parent dir exists\n        else if stat.isFile()\n          options.log message: \"Destination is a file\", level: 'INFO', module: 'nikita/lib/file'\n          do_read()\n        else\n          callback Error \"Invalid File Type Destination: #{options.target}\"\n    do_mkdir = =>\n      options.mode = parseInt(options.mode, 8) if typeof options.mode is 'string' \n      @system.mkdir\n        target: path.dirname options.target\n        uid: options.uid\n        gid: options.gid\n        # force execution right on mkdir\n        mode: if options.mode then (options.mode | 0o111) else 0o755 \n        # Modify uid and gid if the dir does not yet exists\n        unless_exists: path.dirname options.target\n      , (err, created) ->\n        return callback err if err\n        callback()\n    do_read = =>\n      options.log message: \"Reading target\", level: 'DEBUG', module: 'nikita/lib/file'\n      @fs.readFile ssh: options.ssh, target: options.target, encoding: options.encoding, (err, dest) ->\n        return callback err if err\n        target = dest # only used by diff\n        targetHash = string.hash dest\n        callback()\n    exists()\n  @call  -> # render\n    string.render options if options.context?\n  @call -> # skip_empty_lines\n    return unless options.skip_empty_lines?\n    options.log message: \"Skip empty lines\", level: 'DEBUG', module: 'nikita/lib/file'\n    options.content = options.content.replace /(\\r\\n|[\\n\\r\\u0085\\u2028\\u2029])\\s*(\\r\\n|[\\n\\r\\u0085\\u2028\\u2029])/g, \"$1\"\n  @call -> # replace_partial\n    string.replace_partial options if options.write.length\n  @call -> # eof\n    return unless options.eof?\n    options.log message: 'Checking option eof', level: 'DEBUG', module: 'nikita/lib/file'\n    if options.eof is true\n      for char, i in options.content\n        if char is '\\r'\n          options.eof = if options.content[i+1] is '\\n' then '\\r\\n' else char\n          break\n        if char is '\\n' or char is '\\u2028'\n          options.eof = char\n          break;\n      options.eof = '\\n' if options.eof is true\n      options.log message: \"Option eof is true, guessing as #{JSON.stringify options.eof}\", level: 'INFO', module: 'nikita/lib/file'\n    unless string.endsWith options.content, options.eof\n      options.log message: 'Add eof', level: 'INFO', module: 'nikita/lib/file'\n      options.content += options.eof\n  @call (_, callback) -> # diff\n    return callback() if targetHash is string.hash options.content\n    options.log message: \"File content has changed: #{options.target}\", level: 'WARN', module: 'nikita/lib/file'\n    {raw, text} = diff target, options.content, options\n    options.diff text, raw if typeof options.diff is 'function'\n    options.log message: text, type: 'diff', level: 'INFO', module: 'nikita/lib/file'\n    callback null, true\n  @call -> # backup\n    return unless @status()\n    return unless options.backup and targetHash\n    options.log message: \"Create backup\", level: 'INFO', module: 'nikita/lib/file'\n    options.backup_mode ?= 0o0400\n    backup = if typeof options.backup is 'string' then options.backup else \".#{Date.now()}\"\n    @system.copy\n      ssh: options.ssh\n      source: options.target\n      target: \"#{options.target}#{backup}\"\n      mode: options.backup_mode\n  @call (_, callback) -> # file\n    return callback() unless @status()\n    if typeof options.target is 'function'\n      options.log message: 'Write target with user function', level: 'INFO', module: 'nikita/lib/file'\n      options.target options.content\n      return callback()\n    options.flags ?= 'a' if options.append\n    # Ownership and permission are also handled\n    # Mode is setted by default here to avoid a chmod 644 on existing file if option.mode is not specified\n    options.mode ?= 0o0644\n    @fs.writeFile\n      target: options.target\n      flags: options.flags\n      content: options.content\n    , callback\n  @system.uid_gid\n    uid: options.uid\n    gid: options.gid\n    shy: true\n  , (err, status, {uid, gid, default_gid}) ->\n    options.uid = uid\n    options.gid = unless targetStat then default_gid else gid\n  @call ->\n    # Option gid is set at runtime if target is a new file\n    @system.chown\n      target: options.target\n      stat: targetStat\n      ssh: options.ssh\n      sudo: options.sudo\n      uid: options.uid\n      gid: options.gid\n      if: options.uid? or options.gid?\n      unless: options.target is 'function'\n  @system.chmod\n    target: options.target\n    stat: targetStat\n    ssh: options.ssh\n    sudo: options.sudo\n    mode: options.mode\n    if: options.mode?\n    unless: options.target is 'function'",
            "title": "Source Code"
        },
        {
            "location": "/file/index.coffee/#dependencies",
            "text": "path = require 'path'\neco = require 'eco'\nnunjucks = require 'nunjucks/src/environment'\nmisc = require '../misc'\ndiff = require '../misc/diff'\nstring = require '../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/file/ini.coffee/",
            "text": "nikita.file.ini(options, callback)\n\n\nWrite an object as .ini file. Note, we are internally using the \nini\n module.\nHowever, there is a subtile difference. Any key provided with value of \n\nundefined\n or \nnull\n will be disregarded. Within a \nmerge\n, it get more\nprowerfull and tricky: the original value will be kept if \nundefined\n is\nprovided while the value will be removed if \nnull\n is provided.\n\n\nThe \nfile.ini\n function rely on the \nfile\n function and accept all of its\noptions. It introduces the \nmerge\n option which instruct to read the\ntarget file if it exists and merge its parsed object with the one\nprovided in the \ncontent\n option.\n\n\nOptions\n\n\n\n\nbackup\n (string|boolean) \n\n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.\n\n\nclean\n \n\n  Remove all the lines whithout a key and a value, default to \"true\".\n\n\ncontent\n (object) \n\n  Object to stringify.\n\n\nescape\n (boolean) \n\n  Escape the section's header title replace '.' by '.'; \"true\" by default.\n\n\nmerge\n \n\n  Read the target if it exists and merge its content.\n\n\nparse\n \n\n  User-defined function to parse the content from ini format, default to\n  \nrequire('ini').parse\n, see 'misc.ini.parse_multi_brackets'.\n\n\nseparator\n \n\n  Default separator between keys and values, default to \" : \".\n\n\nstringify\n \n\n  User-defined function to stringify the content to ini format, default to\n  \nrequire('ini').stringify\n, see 'misc.ini.stringify_square_then_curly' for\n  an example.\n\n\neol\n (string) \n\n  Characters for line delimiter, usage depends on the stringify option, with \n  the default stringify option, default to unix style if executed remotely \n  (SSH) or to the platform if executed locally (\"\\r\\n for windows\", \n  \"\\n\" otherwise)\n\n\nsource\n (string) \n\n  Path to a ini file providing default options; lower precedence than the\n  content object; may be used conjointly with the local option; optional, use\n  should_exists to enforce its presence.\n\n\ntarget\n \n\n  File path where to write content to or a callback.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nwritten\n \n\n  Number of written actions with modifications.   \n\n\n\n\nExample\n\n\nrequire('nikita').ini({\n  content: {\n    'my_key': 'my value'\n  },\n  target: '/tmp/my_file'\n}, function(err, written){\n  console.log(err ? err.message : 'Content was updated: ' + !!written);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering file.ini\", level: 'DEBUG', module: 'nikita/lib/file/ini'\n  # Normalization\n  options.clean ?= true\n  options.escape ?= true\n  options.content ?= {}\n  options.encoding ?= 'utf8'\n  # Validation\n  throw Error \"Required Option: one of 'content' or 'source' is mandatory\" unless options.content or not options.source\n  throw Error \"Required Option: option 'target' is mandatory\" unless options.target\n  org_props = {}\n  default_props = {}\n  parse = options.parse or misc.ini.parse\n  # Original properties\n  @fs.readFile\n    ssh: options.ssh\n    target: options.target\n    encoding: options.encoding\n    relax: true\n  , (err, data) ->\n    return if err?.code is 'ENOENT'\n    throw err if err\n    org_props = misc.merge parse(data, options)\n  # Default properties\n  @fs.readFile\n    if: options.source\n    ssh: if options.local then false else options.ssh\n    target: options.source\n    encoding: options.encoding\n    relax: true\n  , (err, data) ->\n    return if err?.code is 'ENOENT'\n    throw err if err\n    return unless options.source\n    content = misc.ini.clean options.content, true\n    options.content = misc.merge parse(data, options), options.content\n  # Merge\n  @call if: options.merge , (_, callback) ->\n    options.content = misc.merge org_props, options.content\n    options.log message: \"Get content for merge\", level: 'DEBUG', module: 'nikita/lib/file/ini'\n    callback()\n  @call ->\n    if options.clean\n      options.log message: \"Clean content\", level: 'INFO', module: 'nikita/lib/file/ini'\n      misc.ini.clean options.content\n    options.log message: \"Serialize content\", level: 'DEBUG', module: 'nikita/lib/file/ini'\n    stringify = options.stringify or misc.ini.stringify\n    @file\n      target: options.target\n      content: stringify options.content, options\n      backup: options.backup\n      diff: options.diff\n      eof: options.eof\n      gid: options.gid\n      uid: options.uid\n      mode: options.mode\n\n\n\nDependencies\n\n\nmisc = require '../misc'\n{merge} = require '../misc'",
            "title": "Ini.coffee"
        },
        {
            "location": "/file/ini.coffee/#nikitafileinioptions-callback",
            "text": "Write an object as .ini file. Note, we are internally using the  ini  module.\nHowever, there is a subtile difference. Any key provided with value of  undefined  or  null  will be disregarded. Within a  merge , it get more\nprowerfull and tricky: the original value will be kept if  undefined  is\nprovided while the value will be removed if  null  is provided.  The  file.ini  function rely on the  file  function and accept all of its\noptions. It introduces the  merge  option which instruct to read the\ntarget file if it exists and merge its parsed object with the one\nprovided in the  content  option.",
            "title": "nikita.file.ini(options, callback)"
        },
        {
            "location": "/file/ini.coffee/#options",
            "text": "backup  (string|boolean)  \n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.  clean   \n  Remove all the lines whithout a key and a value, default to \"true\".  content  (object)  \n  Object to stringify.  escape  (boolean)  \n  Escape the section's header title replace '.' by '.'; \"true\" by default.  merge   \n  Read the target if it exists and merge its content.  parse   \n  User-defined function to parse the content from ini format, default to\n   require('ini').parse , see 'misc.ini.parse_multi_brackets'.  separator   \n  Default separator between keys and values, default to \" : \".  stringify   \n  User-defined function to stringify the content to ini format, default to\n   require('ini').stringify , see 'misc.ini.stringify_square_then_curly' for\n  an example.  eol  (string)  \n  Characters for line delimiter, usage depends on the stringify option, with \n  the default stringify option, default to unix style if executed remotely \n  (SSH) or to the platform if executed locally (\"\\r\\n for windows\", \n  \"\\n\" otherwise)  source  (string)  \n  Path to a ini file providing default options; lower precedence than the\n  content object; may be used conjointly with the local option; optional, use\n  should_exists to enforce its presence.  target   \n  File path where to write content to or a callback.",
            "title": "Options"
        },
        {
            "location": "/file/ini.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     written   \n  Number of written actions with modifications.",
            "title": "Callback parameters"
        },
        {
            "location": "/file/ini.coffee/#example",
            "text": "require('nikita').ini({\n  content: {\n    'my_key': 'my value'\n  },\n  target: '/tmp/my_file'\n}, function(err, written){\n  console.log(err ? err.message : 'Content was updated: ' + !!written);\n});",
            "title": "Example"
        },
        {
            "location": "/file/ini.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering file.ini\", level: 'DEBUG', module: 'nikita/lib/file/ini'\n  # Normalization\n  options.clean ?= true\n  options.escape ?= true\n  options.content ?= {}\n  options.encoding ?= 'utf8'\n  # Validation\n  throw Error \"Required Option: one of 'content' or 'source' is mandatory\" unless options.content or not options.source\n  throw Error \"Required Option: option 'target' is mandatory\" unless options.target\n  org_props = {}\n  default_props = {}\n  parse = options.parse or misc.ini.parse\n  # Original properties\n  @fs.readFile\n    ssh: options.ssh\n    target: options.target\n    encoding: options.encoding\n    relax: true\n  , (err, data) ->\n    return if err?.code is 'ENOENT'\n    throw err if err\n    org_props = misc.merge parse(data, options)\n  # Default properties\n  @fs.readFile\n    if: options.source\n    ssh: if options.local then false else options.ssh\n    target: options.source\n    encoding: options.encoding\n    relax: true\n  , (err, data) ->\n    return if err?.code is 'ENOENT'\n    throw err if err\n    return unless options.source\n    content = misc.ini.clean options.content, true\n    options.content = misc.merge parse(data, options), options.content\n  # Merge\n  @call if: options.merge , (_, callback) ->\n    options.content = misc.merge org_props, options.content\n    options.log message: \"Get content for merge\", level: 'DEBUG', module: 'nikita/lib/file/ini'\n    callback()\n  @call ->\n    if options.clean\n      options.log message: \"Clean content\", level: 'INFO', module: 'nikita/lib/file/ini'\n      misc.ini.clean options.content\n    options.log message: \"Serialize content\", level: 'DEBUG', module: 'nikita/lib/file/ini'\n    stringify = options.stringify or misc.ini.stringify\n    @file\n      target: options.target\n      content: stringify options.content, options\n      backup: options.backup\n      diff: options.diff\n      eof: options.eof\n      gid: options.gid\n      uid: options.uid\n      mode: options.mode",
            "title": "Source Code"
        },
        {
            "location": "/file/ini.coffee/#dependencies",
            "text": "misc = require '../misc'\n{merge} = require '../misc'",
            "title": "Dependencies"
        },
        {
            "location": "/file/json.coffee/",
            "text": "nikita.file.json(options, callback)\n\n\nOptions\n\n\n\n\nbackup\n (string|boolean) \n\n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.\n\n\ncontent\n (javascript)\n\n  The javascript code to stringify.\n\n\npretty\n (boolean | int)\n\n  Prettify the JSON output, accept the number of spaces as an integer, default\n  to none if false or to 2 spaces indentation if true.\n\n\nsource\n (string) \n\n  Path to a JSON file providing default values.\n\n\ntarget\n (string) \n\n  Path to the destination file.\n\n\nmerge\n (boolean)\n\n  Merge the user content with the content of the destination file if it\n  exists.\n\n\ntransform\n (function)\n\n  User provided function to modify the javascript before it is stringified\n  into JSON.\n\n\n\n\nThe properties \"backup\", \"diff\", \"eof\", \"gid\", \"uid\", \"mode\" will\nbe passed to the \nfile\n function.\n\n\nExemple\n\n\nMerge the destination file with user provided content.\n\n\nrequire('nikita')\n.file.json({\n  target: \"/path/to/target.json\",\n  content: { preferences: { colors: 'blue' } },\n  transform: function(data){\n    if(data.indexOf('red') < 0){ data.push('red'); }\n    return data;\n  },\n  merge: true,\n  pretty: true\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering file.json\", level: 'DEBUG', module: 'nikita/lib/file/json'\n  # Options\n  options.content ?= {}\n  options.pretty ?= false\n  options.pretty = 2 if options.pretty is true\n  options.transform ?= null\n  throw Error \"Required Option: the 'target' option is required\" unless options.target\n  throw Error \"Invalid options: \\\"transform\\\"\" if options.transform and typeof options.transform isnt 'function'\n  @call if: options.merge, (_, callback) ->\n    @fs.readFile\n      ssh: options.ssh\n      target: options.target\n      encoding: 'utf8'\n      relax: true\n    , (err, json) ->\n      return callback() if err?.code is 'ENOENT'\n      options.content = merge JSON.parse(json), options.content unless err\n      callback err\n  @call if: options.source, (_, callback) ->\n    @fs.readFile\n      ssh: if options.local then false else options.ssh\n      target: options.source\n      encoding: 'utf8'\n    , (err, json) ->\n      options.content = merge JSON.parse(json), options.content unless err\n      callback err\n  @call if: options.transform, ->\n    options.content = options.transform options.content\n  @file\n    target: options.target\n    content: -> JSON.stringify options.content, null, options.pretty\n    backup: options.backup\n    diff: options.diff\n    eof: options.eof\n    gid: options.gid\n    uid: options.uid\n    mode: options.mode\n\n\n\nDependencies\n\n\n{merge} = require '../misc'",
            "title": "Json.coffee"
        },
        {
            "location": "/file/json.coffee/#nikitafilejsonoptions-callback",
            "text": "",
            "title": "nikita.file.json(options, callback)"
        },
        {
            "location": "/file/json.coffee/#options",
            "text": "backup  (string|boolean)  \n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.  content  (javascript) \n  The javascript code to stringify.  pretty  (boolean | int) \n  Prettify the JSON output, accept the number of spaces as an integer, default\n  to none if false or to 2 spaces indentation if true.  source  (string)  \n  Path to a JSON file providing default values.  target  (string)  \n  Path to the destination file.  merge  (boolean) \n  Merge the user content with the content of the destination file if it\n  exists.  transform  (function) \n  User provided function to modify the javascript before it is stringified\n  into JSON.   The properties \"backup\", \"diff\", \"eof\", \"gid\", \"uid\", \"mode\" will\nbe passed to the  file  function.",
            "title": "Options"
        },
        {
            "location": "/file/json.coffee/#exemple",
            "text": "Merge the destination file with user provided content.  require('nikita')\n.file.json({\n  target: \"/path/to/target.json\",\n  content: { preferences: { colors: 'blue' } },\n  transform: function(data){\n    if(data.indexOf('red') < 0){ data.push('red'); }\n    return data;\n  },\n  merge: true,\n  pretty: true\n})",
            "title": "Exemple"
        },
        {
            "location": "/file/json.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering file.json\", level: 'DEBUG', module: 'nikita/lib/file/json'\n  # Options\n  options.content ?= {}\n  options.pretty ?= false\n  options.pretty = 2 if options.pretty is true\n  options.transform ?= null\n  throw Error \"Required Option: the 'target' option is required\" unless options.target\n  throw Error \"Invalid options: \\\"transform\\\"\" if options.transform and typeof options.transform isnt 'function'\n  @call if: options.merge, (_, callback) ->\n    @fs.readFile\n      ssh: options.ssh\n      target: options.target\n      encoding: 'utf8'\n      relax: true\n    , (err, json) ->\n      return callback() if err?.code is 'ENOENT'\n      options.content = merge JSON.parse(json), options.content unless err\n      callback err\n  @call if: options.source, (_, callback) ->\n    @fs.readFile\n      ssh: if options.local then false else options.ssh\n      target: options.source\n      encoding: 'utf8'\n    , (err, json) ->\n      options.content = merge JSON.parse(json), options.content unless err\n      callback err\n  @call if: options.transform, ->\n    options.content = options.transform options.content\n  @file\n    target: options.target\n    content: -> JSON.stringify options.content, null, options.pretty\n    backup: options.backup\n    diff: options.diff\n    eof: options.eof\n    gid: options.gid\n    uid: options.uid\n    mode: options.mode",
            "title": "Source Code"
        },
        {
            "location": "/file/json.coffee/#dependencies",
            "text": "{merge} = require '../misc'",
            "title": "Dependencies"
        },
        {
            "location": "/file/render.coffee/",
            "text": "nikita.file.render(options, [callback])\n\n\nRender a template file. The following templating engines are\nintegrated. More are added on demand.      \n\n\n\n\nECO\n (default)   \n\n\nNunjucks\n (\"*.j2\")   \n\n\n\n\nOptions\n\n\n\n\nengine\n \n\n  Template engine to use, default to \"eco\".   \n\n\ncontent\n \n\n  Templated content, bypassed if source is provided.   \n\n\nsource\n \n\n  File path where to extract content from.   \n\n\ntarget\n \n\n  File path where to write content to or a callback.   \n\n\ncontext\n \n\n  Map of key values to inject into the template.   \n\n\nfilters\n (function) \n\n  Filter function to extend the nunjucks engine.   \n\n\nlocal\n \n\n  Treat the source as local instead of remote, only apply with \"ssh\"\n  option.   \n\n\nskip_empty_lines\n \n\n  Remove empty lines.   \n\n\nuid\n \n\n  File user name or user id.   \n\n\ngid\n \n\n  File group name or group id.   \n\n\nmode\n \n\n  File mode (permission and sticky bits), default to \n0644\n, in the form of\n  \n{mode: 0o744}\n or \n{mode: \"744\"}\n.   \n\n\n\n\nIf target is a callback, it will be called with the generated content as\nits first argument.   \n\n\nCustom Filters\n\n\nNunjucks allow to add custom filters. Nikita provides some custom filters listed below.\nThese filters are implemented misc/string. They can be overriden through the filters\nparameters   \n\n\n\n\nisString\n \n\n  return true if the variable is a string   \n\n\nisArray\n \n\n  return true if the variable is an array   \n\n\nisObject\n \n\n  return true if the variable is an object. Return false if the variable is an array.   \n\n\nisEmpty\n \n\n  return true if the variable is \nnull\n, \nundefined\n, \n''\n, \n[]\n, or \n{}\n   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value is true if rendered file was created or modified.   \n\n\n\n\nRendering with Nunjucks\n\n\nrequire('nikita').file.render({\n  source: './some/a_template.j2',\n  target: '/tmp/a_file',\n  context: {\n    username: 'a_user'\n  }\n}, function(err, status){\n  console.log(err ? err.message : 'File rendered: ' + !!status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering file.render\", level: 'DEBUG', module: 'nikita/lib/file/render'\n  # Validate parameters\n  options.encoding ?= 'utf8'\n  throw Error 'Required option: source or content' unless options.source or options.content\n  throw Error 'Required option: target' unless options.target\n  throw Error 'Required option: context' unless options.context\n  # Extension\n  if not options.engine and options.source\n    extension = path.extname options.source\n    switch extension\n      when '.j2' then options.engine = 'nunjunks'\n      when '.eco' then options.engine = 'eco'\n      else throw Error \"Invalid Option: extension '#{extension}' is not supported\"\n  # Read source\n  @fs.readFile\n    if: options.source\n    ssh: if options.local then false else options.ssh\n    target: options.source\n    encoding: options.encoding\n  , (err, content) ->\n    if content?\n      options.source = null\n      options.content = content\n  @call ->\n    @file options\n\n\n\nDependencies\n\n\npath = require 'path'",
            "title": "Render.coffee"
        },
        {
            "location": "/file/render.coffee/#nikitafilerenderoptions-callback",
            "text": "Render a template file. The following templating engines are\nintegrated. More are added on demand.         ECO  (default)     Nunjucks  (\"*.j2\")",
            "title": "nikita.file.render(options, [callback])"
        },
        {
            "location": "/file/render.coffee/#options",
            "text": "engine   \n  Template engine to use, default to \"eco\".     content   \n  Templated content, bypassed if source is provided.     source   \n  File path where to extract content from.     target   \n  File path where to write content to or a callback.     context   \n  Map of key values to inject into the template.     filters  (function)  \n  Filter function to extend the nunjucks engine.     local   \n  Treat the source as local instead of remote, only apply with \"ssh\"\n  option.     skip_empty_lines   \n  Remove empty lines.     uid   \n  File user name or user id.     gid   \n  File group name or group id.     mode   \n  File mode (permission and sticky bits), default to  0644 , in the form of\n   {mode: 0o744}  or  {mode: \"744\"} .      If target is a callback, it will be called with the generated content as\nits first argument.",
            "title": "Options"
        },
        {
            "location": "/file/render.coffee/#custom-filters",
            "text": "Nunjucks allow to add custom filters. Nikita provides some custom filters listed below.\nThese filters are implemented misc/string. They can be overriden through the filters\nparameters      isString   \n  return true if the variable is a string     isArray   \n  return true if the variable is an array     isObject   \n  return true if the variable is an object. Return false if the variable is an array.     isEmpty   \n  return true if the variable is  null ,  undefined ,  '' ,  [] , or  {}",
            "title": "Custom Filters"
        },
        {
            "location": "/file/render.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value is true if rendered file was created or modified.",
            "title": "Callback parameters"
        },
        {
            "location": "/file/render.coffee/#rendering-with-nunjucks",
            "text": "require('nikita').file.render({\n  source: './some/a_template.j2',\n  target: '/tmp/a_file',\n  context: {\n    username: 'a_user'\n  }\n}, function(err, status){\n  console.log(err ? err.message : 'File rendered: ' + !!status);\n});",
            "title": "Rendering with Nunjucks"
        },
        {
            "location": "/file/render.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering file.render\", level: 'DEBUG', module: 'nikita/lib/file/render'\n  # Validate parameters\n  options.encoding ?= 'utf8'\n  throw Error 'Required option: source or content' unless options.source or options.content\n  throw Error 'Required option: target' unless options.target\n  throw Error 'Required option: context' unless options.context\n  # Extension\n  if not options.engine and options.source\n    extension = path.extname options.source\n    switch extension\n      when '.j2' then options.engine = 'nunjunks'\n      when '.eco' then options.engine = 'eco'\n      else throw Error \"Invalid Option: extension '#{extension}' is not supported\"\n  # Read source\n  @fs.readFile\n    if: options.source\n    ssh: if options.local then false else options.ssh\n    target: options.source\n    encoding: options.encoding\n  , (err, content) ->\n    if content?\n      options.source = null\n      options.content = content\n  @call ->\n    @file options",
            "title": "Source Code"
        },
        {
            "location": "/file/render.coffee/#dependencies",
            "text": "path = require 'path'",
            "title": "Dependencies"
        },
        {
            "location": "/file/touch.coffee/",
            "text": "nikita.file.touch(options, [callback])\n\n\nCreate a empty file if it does not yet exists.\n\n\nImplementation details\n\n\nStatus will only be true if the file was created.\n\n\nOptions\n\n\n\n\natime\n (Date|int)\n\n  Access time, default to now.   \n\n\ngid\n \n\n  File group name or group id.   \n\n\nmode\n \n\n  File mode (permission and sticky bits), default to \n0o0666\n, in the form of\n  \n{mode: 0o0744}\n or \n{mode: \"0744\"}\n.   \n\n\nmtime\n (Date|int)\n\n  Modification time, default to now.   \n\n\ntarget\n \n\n  File path where to write content to.   \n\n\nuid\n \n\n  File user name or user id.   \n\n\n\n\nCallback Parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value is \"true\" if file was created or modified.   \n\n\n\n\nExample\n\n\nrequire('nikita').file.touch({\n  ssh: ssh,\n  target: '/tmp/a_file'\n}, function(err, touched){\n  console.log(err ? err.message : 'File touched: ' + !!touched);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering file.touch\", level: 'DEBUG', module: 'nikita/lib/file/touch'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  options.target = options.argument if options.argument?\n  throw Error \"Missing target: #{options.target}\" unless options.target\n\n\n\nTest if file exists.\n\n\n  @call (_, callback) ->\n    options.log message: \"Check if target exists \\\"#{options.target}\\\"\", level: 'DEBUG', module: 'nikita/lib/file/touch'\n    @fs.exists ssh: options.ssh, target: options.target, (err, exists) ->\n      options.log message: \"Destination does not exists\", level: 'INFO', module: 'nikita/lib/file/touch' if not err and not exists\n      return callback err, !exists\n\n\n\nIf true, update access and modification time, status wont be affected\n\n\n  @system.execute\n    unless: -> @status()\n    cmd: \"touch #{options.target}\"\n    shy: true\n  , (err) ->\n    options.log message: \"Access and modification times updated\", level: 'DEBUG', module: 'nikita/lib/file/touch' unless err\n\n\n\nIf not, write a new empty file.\n\n\n  @file\n    content: ''\n    target: options.target\n    if: -> @status()\n    mode: options.mode\n    uid: options.uid\n    gid: options.gid",
            "title": "Touch.coffee"
        },
        {
            "location": "/file/touch.coffee/#nikitafiletouchoptions-callback",
            "text": "Create a empty file if it does not yet exists.",
            "title": "nikita.file.touch(options, [callback])"
        },
        {
            "location": "/file/touch.coffee/#implementation-details",
            "text": "Status will only be true if the file was created.",
            "title": "Implementation details"
        },
        {
            "location": "/file/touch.coffee/#options",
            "text": "atime  (Date|int) \n  Access time, default to now.     gid   \n  File group name or group id.     mode   \n  File mode (permission and sticky bits), default to  0o0666 , in the form of\n   {mode: 0o0744}  or  {mode: \"0744\"} .     mtime  (Date|int) \n  Modification time, default to now.     target   \n  File path where to write content to.     uid   \n  File user name or user id.",
            "title": "Options"
        },
        {
            "location": "/file/touch.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value is \"true\" if file was created or modified.",
            "title": "Callback Parameters"
        },
        {
            "location": "/file/touch.coffee/#example",
            "text": "require('nikita').file.touch({\n  ssh: ssh,\n  target: '/tmp/a_file'\n}, function(err, touched){\n  console.log(err ? err.message : 'File touched: ' + !!touched);\n});",
            "title": "Example"
        },
        {
            "location": "/file/touch.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering file.touch\", level: 'DEBUG', module: 'nikita/lib/file/touch'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  options.target = options.argument if options.argument?\n  throw Error \"Missing target: #{options.target}\" unless options.target  Test if file exists.    @call (_, callback) ->\n    options.log message: \"Check if target exists \\\"#{options.target}\\\"\", level: 'DEBUG', module: 'nikita/lib/file/touch'\n    @fs.exists ssh: options.ssh, target: options.target, (err, exists) ->\n      options.log message: \"Destination does not exists\", level: 'INFO', module: 'nikita/lib/file/touch' if not err and not exists\n      return callback err, !exists  If true, update access and modification time, status wont be affected    @system.execute\n    unless: -> @status()\n    cmd: \"touch #{options.target}\"\n    shy: true\n  , (err) ->\n    options.log message: \"Access and modification times updated\", level: 'DEBUG', module: 'nikita/lib/file/touch' unless err  If not, write a new empty file.    @file\n    content: ''\n    target: options.target\n    if: -> @status()\n    mode: options.mode\n    uid: options.uid\n    gid: options.gid",
            "title": "Source Code"
        },
        {
            "location": "/file/upload.coffee/",
            "text": "nikita.file.upload(options, [callback])\n\n\nUpload a file to a remote location. Options are identical to the \"write\"\nfunction with the addition of the \"binary\" option.\n\n\nOptions\n\n\n\n\nbinary\n \n\n  Fast upload implementation, discard all the other option and use its own\n  stream based implementation.\n\n\nfrom\n \n\n  Replace from after this marker, a string or a regular expression.\n\n\nto\n \n\n  Replace to before this marker, a string or a regular expression.\n\n\nmatch\n \n\n  Replace this marker, a string or a regular expression.\n\n\nreplace\n \n\n  The content to be inserted, used conjointly with the from, to or match\n  options.\n\n\ncontent\n \n\n  Text to be written.\n\n\nsource\n \n\n  File path from where to extract the content, do not use conjointly with\n  content.\n\n\ntarget\n \n\n  File path where to write content to.\n\n\nbackup\n (string|boolean) \n\n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.\n\n\nmd5\n \n\n  Validate uploaded file with md5 checksum (only for binary upload for now),\n  may be the string checksum or will be deduced from source if \"true\".\n\n\nsha1\n \n\n  Validate uploaded file with sha1 checksum (only for binary upload for now),\n  may be the string checksum or will be deduced from source if \"true\".\n\n\nssh\n (object|ssh2) \n\n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.\n\n\nstdout\n (stream.Writable) \n\n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.\n\n\nstderr\n (stream.Writable) \n\n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value is \"true\" if file was uploaded.   \n\n\n\n\nExample\n\n\nrequire('nikita').upload({\n  ssh: ssh\n  source: '/tmp/local_file',\n  target: '/tmp/remote_file'\n}, function(err, status){\n  console.info(err ? err.message : 'File uploaded: ' + status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering file.upload\", level: 'DEBUG', module: 'nikita/lib/file/upload'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  throw Error \"Required \\\"source\\\" option\" unless options.source\n  throw Error \"Required \\\"target\\\" option\" unless options.target\n  options.log message: \"Source is \\\"#{options.source}\\\"\", level: 'DEBUG', module: 'nikita/lib/file/upload'\n  options.log message: \"Destination is \\\"#{options.target}\\\"\", level: 'DEBUG', module: 'nikita/lib/file/upload'\n  status = false\n  source_stat = null\n  target_stat = null\n  stage_target = \"#{options.target}.#{Date.now()}#{Math.round(Math.random()*1000)}\"\n  if options.md5?\n    return callback Error \"Invalid MD5 Hash:#{options.md5}\" unless typeof options.md5 in ['string', 'boolean']\n    algo = 'md5'\n    # source_hash = options.md5\n  else if options.sha1?\n    return callback Error \"Invalid SHA-1 Hash:#{options.sha1}\" unless typeof options.sha1 in ['string', 'boolean']\n    algo = 'sha1'\n    # source_hash = options.sha1\n  else\n    algo = 'md5'\n  @call (_, callback) ->\n    @fs.stat ssh: options.ssh, target: options.source, (err, stat) ->\n      callback err if err and err.code isnt 'ENOENT'\n      source_stat = stat\n      callback()\n  @call (_, callback) ->\n    @fs.stat ssh: false, target: options.target, (err, stat) ->\n      return callback() if err and err.code is 'ENOENT'\n      return callback err if err\n      target_stat = stat if stat.isFile()\n      return callback() unless stat.isDirectory()\n      options.target = path.resolve options.target, path.basename options.source\n      @fs.stat ssh: false, target: options.target, (err, stat) ->\n        return callback() if err and err.code is 'ENOENT'\n        return callback err if err\n        target_stat = stat if stat.isFile()\n        return callback() if stat.isFile()\n        callback Error \"Invalid target: #{options.target}\"\n  @call\n    handler: (_, callback) ->\n      return callback null, true unless target_stat\n      file.compare_hash ssh, options.source, null, options.target, algo, (err, match) =>\n        callback err, not match\n  @system.mkdir\n    if: -> @status -1\n    ssh: false\n    target: path.dirname stage_target\n  @call\n    if: -> @status -2\n    handler: (_, callback) ->\n      ssh2fs.createReadStream ssh, options.source, (err, rs) =>\n        return callback err if err\n        ws = fs.createWriteStream stage_target\n        rs.pipe(ws)\n        .on 'close', callback\n        .on 'error', callback\n  @call ->\n    @system.move\n      ssh: false\n      if: @status()\n      source: stage_target\n      target: options.target\n    , (err, status) ->\n      options.log message: \"Unstaged uploaded file\", level: 'INFO', module: 'nikita/lib/file/upload' if status\n    @system.chmod\n      ssh: false\n      target: options.target\n      mode: options.mode\n      if: options.mode?\n    @system.chown\n      ssh: false\n      target: options.target\n      uid: options.uid\n      gid: options.gid\n      if: options.uid? or options.gid?\n\n\n\nDependencies\n\n\nfs = require 'fs'\nssh2fs = require 'ssh2-fs'\npath = require 'path'\nmisc = require '../misc'\nfile = require '../misc/file'",
            "title": "Upload.coffee"
        },
        {
            "location": "/file/upload.coffee/#nikitafileuploadoptions-callback",
            "text": "Upload a file to a remote location. Options are identical to the \"write\"\nfunction with the addition of the \"binary\" option.",
            "title": "nikita.file.upload(options, [callback])"
        },
        {
            "location": "/file/upload.coffee/#options",
            "text": "binary   \n  Fast upload implementation, discard all the other option and use its own\n  stream based implementation.  from   \n  Replace from after this marker, a string or a regular expression.  to   \n  Replace to before this marker, a string or a regular expression.  match   \n  Replace this marker, a string or a regular expression.  replace   \n  The content to be inserted, used conjointly with the from, to or match\n  options.  content   \n  Text to be written.  source   \n  File path from where to extract the content, do not use conjointly with\n  content.  target   \n  File path where to write content to.  backup  (string|boolean)  \n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.  md5   \n  Validate uploaded file with md5 checksum (only for binary upload for now),\n  may be the string checksum or will be deduced from source if \"true\".  sha1   \n  Validate uploaded file with sha1 checksum (only for binary upload for now),\n  may be the string checksum or will be deduced from source if \"true\".  ssh  (object|ssh2)  \n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.  stdout  (stream.Writable)  \n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.  stderr  (stream.Writable)  \n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.",
            "title": "Options"
        },
        {
            "location": "/file/upload.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value is \"true\" if file was uploaded.",
            "title": "Callback parameters"
        },
        {
            "location": "/file/upload.coffee/#example",
            "text": "require('nikita').upload({\n  ssh: ssh\n  source: '/tmp/local_file',\n  target: '/tmp/remote_file'\n}, function(err, status){\n  console.info(err ? err.message : 'File uploaded: ' + status);\n});",
            "title": "Example"
        },
        {
            "location": "/file/upload.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering file.upload\", level: 'DEBUG', module: 'nikita/lib/file/upload'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  throw Error \"Required \\\"source\\\" option\" unless options.source\n  throw Error \"Required \\\"target\\\" option\" unless options.target\n  options.log message: \"Source is \\\"#{options.source}\\\"\", level: 'DEBUG', module: 'nikita/lib/file/upload'\n  options.log message: \"Destination is \\\"#{options.target}\\\"\", level: 'DEBUG', module: 'nikita/lib/file/upload'\n  status = false\n  source_stat = null\n  target_stat = null\n  stage_target = \"#{options.target}.#{Date.now()}#{Math.round(Math.random()*1000)}\"\n  if options.md5?\n    return callback Error \"Invalid MD5 Hash:#{options.md5}\" unless typeof options.md5 in ['string', 'boolean']\n    algo = 'md5'\n    # source_hash = options.md5\n  else if options.sha1?\n    return callback Error \"Invalid SHA-1 Hash:#{options.sha1}\" unless typeof options.sha1 in ['string', 'boolean']\n    algo = 'sha1'\n    # source_hash = options.sha1\n  else\n    algo = 'md5'\n  @call (_, callback) ->\n    @fs.stat ssh: options.ssh, target: options.source, (err, stat) ->\n      callback err if err and err.code isnt 'ENOENT'\n      source_stat = stat\n      callback()\n  @call (_, callback) ->\n    @fs.stat ssh: false, target: options.target, (err, stat) ->\n      return callback() if err and err.code is 'ENOENT'\n      return callback err if err\n      target_stat = stat if stat.isFile()\n      return callback() unless stat.isDirectory()\n      options.target = path.resolve options.target, path.basename options.source\n      @fs.stat ssh: false, target: options.target, (err, stat) ->\n        return callback() if err and err.code is 'ENOENT'\n        return callback err if err\n        target_stat = stat if stat.isFile()\n        return callback() if stat.isFile()\n        callback Error \"Invalid target: #{options.target}\"\n  @call\n    handler: (_, callback) ->\n      return callback null, true unless target_stat\n      file.compare_hash ssh, options.source, null, options.target, algo, (err, match) =>\n        callback err, not match\n  @system.mkdir\n    if: -> @status -1\n    ssh: false\n    target: path.dirname stage_target\n  @call\n    if: -> @status -2\n    handler: (_, callback) ->\n      ssh2fs.createReadStream ssh, options.source, (err, rs) =>\n        return callback err if err\n        ws = fs.createWriteStream stage_target\n        rs.pipe(ws)\n        .on 'close', callback\n        .on 'error', callback\n  @call ->\n    @system.move\n      ssh: false\n      if: @status()\n      source: stage_target\n      target: options.target\n    , (err, status) ->\n      options.log message: \"Unstaged uploaded file\", level: 'INFO', module: 'nikita/lib/file/upload' if status\n    @system.chmod\n      ssh: false\n      target: options.target\n      mode: options.mode\n      if: options.mode?\n    @system.chown\n      ssh: false\n      target: options.target\n      uid: options.uid\n      gid: options.gid\n      if: options.uid? or options.gid?",
            "title": "Source Code"
        },
        {
            "location": "/file/upload.coffee/#dependencies",
            "text": "fs = require 'fs'\nssh2fs = require 'ssh2-fs'\npath = require 'path'\nmisc = require '../misc'\nfile = require '../misc/file'",
            "title": "Dependencies"
        },
        {
            "location": "/file/yaml.coffee/",
            "text": "nikita.file.yaml(options, callback)\n\n\nWrite an object serialized in YAML format. Note, we are internally using the \njs-yaml\n module.\nHowever, there is a subtile difference. Any key provided with value of\n\nundefined\n or \nnull\n will be disregarded. Within a \nmerge\n, it get more\nprowerfull and tricky: the original value will be kept if \nundefined\n is\nprovided while the value will be removed if \nnull\n is provided.\n\n\nThe \nfile.yaml\n function rely on the \nfile\n function and accept all of its\noptions. It introduces the \nmerge\n option which instruct to read the\ntarget file if it exists and merge its parsed object with the one\nprovided in the \ncontent\n option.\n\n\nOptions\n\n\n\n\nappend\n \n\n  Append the content to the target file. If target does not exist,\n  the file will be created. When used with the \nmatch\n and \nreplace\n options,\n  it will append the \nreplace\n value at the end of the file if no match if\n  found and if the value is a string.\n\n\nbackup\n (string|boolean) \n\n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.\n\n\ncontent\n \n\n  Object to stringify.\n\n\ntarget\n \n\n  File path where to write content to or a callback.\n\n\nfrom\n \n\n  Replace from after this marker, a string or a regular expression.\n\n\nlocal\n \n\n  Treat the source as local instead of remote, only apply with \"ssh\" option.\n\n\nindent\n \n\n  Number of space used for indentation. Default to 2.\n\n\nline_width\n.\n  Number of max character before a new line is written. Default to 160.\n\n\nmatch\n \n\n  Replace this marker, a string or a regular expression.\n\n\nmerge\n \n\n  Read the target if it exists and merge its content.\n\n\nreplace\n \n\n  The content to be inserted, used conjointly with the from, to or match\n  options.\n\n\nsource\n \n\n  File path from where to extract the content, do not use conjointly with\n  content.\n\n\nto\n \n\n  Replace to before this marker, a string or a regular expression.\n\n\nssh\n (object|ssh2) \n\n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.\n\n\nstdout\n (stream.Writable) \n\n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.\n\n\nstderr\n (stream.Writable) \n\n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nwritten\n \n\n  Number of written actions with modifications.\n\n\n\n\nExample\n\n\nrequire('nikita').file.yaml({\n  content: {\n    'my_key': 'my value'\n  },\n  target: '/tmp/my_file'\n}, function(err, written){\n  console.info(err ? err.message : 'Content was updated: ' + !!written);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.line_width ?= 160\n  options.log message: \"Entering file.yaml\", level: 'DEBUG', module: 'nikita/lib/file/yaml'\n  options.clean ?= true\n  # Validate parameters\n  throw Error 'Missing content' unless options.content\n  throw Error 'Missing target' unless options.target\n  # Start real work\n  @fs.readFile\n    if: options.merge\n    target: options.target\n    encoding: 'utf8'\n    relax: true\n  , (err, content) ->\n    return unless content?\n    return if err?.code is 'ENOENT'\n    throw err if err\n    yaml.safeLoadAll content, (data) ->\n      data = misc.yaml.clean data, options.content, true\n      options.content = misc.yaml.merge data, options.content\n  @call ->\n    options.indent ?= 2\n    if options.clean\n      options.log message: \"Clean content\", level: 'INFO', module: 'nikita/lib/file/yaml'\n      misc.ini.clean options.content\n    options.log message: \"Serialize content\", level: 'DEBUG', module: 'nikita/lib/file/yaml'\n    options.content = yaml.safeDump options.content, noRefs:true, lineWidth: options.line_width\n    @file options, header: null, (err, written) ->\n      callback err, written\n\n\n\nDependencies\n\n\nmisc = require '../misc'\nyaml = require 'js-yaml'",
            "title": "Yaml.coffee"
        },
        {
            "location": "/file/yaml.coffee/#nikitafileyamloptions-callback",
            "text": "Write an object serialized in YAML format. Note, we are internally using the  js-yaml  module.\nHowever, there is a subtile difference. Any key provided with value of undefined  or  null  will be disregarded. Within a  merge , it get more\nprowerfull and tricky: the original value will be kept if  undefined  is\nprovided while the value will be removed if  null  is provided.  The  file.yaml  function rely on the  file  function and accept all of its\noptions. It introduces the  merge  option which instruct to read the\ntarget file if it exists and merge its parsed object with the one\nprovided in the  content  option.",
            "title": "nikita.file.yaml(options, callback)"
        },
        {
            "location": "/file/yaml.coffee/#options",
            "text": "append   \n  Append the content to the target file. If target does not exist,\n  the file will be created. When used with the  match  and  replace  options,\n  it will append the  replace  value at the end of the file if no match if\n  found and if the value is a string.  backup  (string|boolean)  \n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.  content   \n  Object to stringify.  target   \n  File path where to write content to or a callback.  from   \n  Replace from after this marker, a string or a regular expression.  local   \n  Treat the source as local instead of remote, only apply with \"ssh\" option.  indent   \n  Number of space used for indentation. Default to 2.  line_width .\n  Number of max character before a new line is written. Default to 160.  match   \n  Replace this marker, a string or a regular expression.  merge   \n  Read the target if it exists and merge its content.  replace   \n  The content to be inserted, used conjointly with the from, to or match\n  options.  source   \n  File path from where to extract the content, do not use conjointly with\n  content.  to   \n  Replace to before this marker, a string or a regular expression.  ssh  (object|ssh2)  \n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.  stdout  (stream.Writable)  \n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.  stderr  (stream.Writable)  \n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.",
            "title": "Options"
        },
        {
            "location": "/file/yaml.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  written   \n  Number of written actions with modifications.",
            "title": "Callback parameters"
        },
        {
            "location": "/file/yaml.coffee/#example",
            "text": "require('nikita').file.yaml({\n  content: {\n    'my_key': 'my value'\n  },\n  target: '/tmp/my_file'\n}, function(err, written){\n  console.info(err ? err.message : 'Content was updated: ' + !!written);\n});",
            "title": "Example"
        },
        {
            "location": "/file/yaml.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.line_width ?= 160\n  options.log message: \"Entering file.yaml\", level: 'DEBUG', module: 'nikita/lib/file/yaml'\n  options.clean ?= true\n  # Validate parameters\n  throw Error 'Missing content' unless options.content\n  throw Error 'Missing target' unless options.target\n  # Start real work\n  @fs.readFile\n    if: options.merge\n    target: options.target\n    encoding: 'utf8'\n    relax: true\n  , (err, content) ->\n    return unless content?\n    return if err?.code is 'ENOENT'\n    throw err if err\n    yaml.safeLoadAll content, (data) ->\n      data = misc.yaml.clean data, options.content, true\n      options.content = misc.yaml.merge data, options.content\n  @call ->\n    options.indent ?= 2\n    if options.clean\n      options.log message: \"Clean content\", level: 'INFO', module: 'nikita/lib/file/yaml'\n      misc.ini.clean options.content\n    options.log message: \"Serialize content\", level: 'DEBUG', module: 'nikita/lib/file/yaml'\n    options.content = yaml.safeDump options.content, noRefs:true, lineWidth: options.line_width\n    @file options, header: null, (err, written) ->\n      callback err, written",
            "title": "Source Code"
        },
        {
            "location": "/file/yaml.coffee/#dependencies",
            "text": "misc = require '../misc'\nyaml = require 'js-yaml'",
            "title": "Dependencies"
        },
        {
            "location": "/file/properties/index.coffee/",
            "text": "nikita.file.properties(options, callback)\n\n\nWrite a file in the Java properties format.\n\n\nOptions\n\n\n\n\nbackup\n (string|boolean) \n\n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.\n\n\ncomment\n (boolean) \n\n  Preserve comments.\n\n\ncontent\n (object) \n\n  List of properties to write.\n\n\nlocal\n (boolean) \n\n  Treat the source as local instead of remote, only apply with \"ssh\"\n  option.\n\n\nsort\n (boolean) \n\n  Sort the properties before writting them. False by default.\n\n\ntarget\n (string) \n\n  File path where to write content to.\n\n\ntrim\n (boolean) \n\n  Trim keys and value.\n\n\nmerge\n (boolean) \n\n  Merges content properties with target file. False by default\n\n\nseparator\n (string) \n\n  The caracter to use for separating property and value. '=' by default.\n\n\n\n\nExemple\n\n\nUse a custom delimiter with spaces around the equal sign.\n\n\nrequire('nikita')\n.file.properties({\n  target: \"/path/to/target.json\",\n  content: { key: \"value\" },\n  separator: ' = '\n  merge: true\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering file.properties\", level: 'DEBUG', module: 'nikita/lib/file/properties'\n  # Options\n  throw Error \"Missing argument options.target\" unless options.target\n  options.separator ?= '='\n  options.content ?= {}\n  options.sort ?= false\n  # Trim\n  unless options.trim\n    fnl_props = options.content\n  else \n    fnl_props = {}\n    for k, v of options.content\n      k = k.trim()\n      v = v.trim() if typeof v is 'string'\n      fnl_props[k] = v\n  org_props = {}\n  options.log message: \"Merging \\\"#{if options.merge then 'true' else 'false'}\\\"\", level: 'DEBUG', module: 'nikita/lib/file/properties'\n  # Read Original\n  @file.properties.read\n    if_exists: true\n    ssh: options.ssh\n    target: options.target\n    separator: options.separator\n    comment: options.comment\n    trim: options.trim\n  , (err, props) ->\n    org_props = props or {} unless err\n  # Diff\n  @call (_, callback) ->\n    status = false\n    keys = {}\n    for k in Object.keys(org_props) then keys[k] = true\n    for k in Object.keys(fnl_props) then keys[k] = true\n    for key in Object.keys keys\n      if \"#{org_props[key]}\" isnt \"#{fnl_props[key]}\"\n        options.log? message: \"Property '#{key}' was '#{org_props[k]}' and is now '#{fnl_props[k]}'\", level: 'WARN', module: 'ryba/lib/file/properties'\n        status = true if fnl_props[key]?\n    callback null, status\n  # Merge\n  @call if: options.merge, ->\n    for k, v of fnl_props\n      org_props[k] = fnl_props[k]\n    fnl_props = org_props\n  @call ->\n    # Write data\n    keys = if options.sort then Object.keys(fnl_props).sort() else Object.keys(fnl_props)\n    data = for key in keys\n      if fnl_props[key]?\n      then \"#{key}#{options.separator}#{fnl_props[key]}\"\n      else \"#{key}\" # This is a comment\n    @file\n      target: \"#{options.target}\"\n      content: data.join '\\n'\n      backup: options.backup\n      eof: true\n      shy: true\n    @system.chown\n      target: options.target\n      uid: options.uid\n      gid: options.gid\n      if: options.uid? or options.gid?\n    @system.chmod\n      target: options.target\n      mode: options.mode\n      if: options.mode?",
            "title": "Index.coffee"
        },
        {
            "location": "/file/properties/index.coffee/#nikitafilepropertiesoptions-callback",
            "text": "Write a file in the Java properties format.",
            "title": "nikita.file.properties(options, callback)"
        },
        {
            "location": "/file/properties/index.coffee/#options",
            "text": "backup  (string|boolean)  \n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.  comment  (boolean)  \n  Preserve comments.  content  (object)  \n  List of properties to write.  local  (boolean)  \n  Treat the source as local instead of remote, only apply with \"ssh\"\n  option.  sort  (boolean)  \n  Sort the properties before writting them. False by default.  target  (string)  \n  File path where to write content to.  trim  (boolean)  \n  Trim keys and value.  merge  (boolean)  \n  Merges content properties with target file. False by default  separator  (string)  \n  The caracter to use for separating property and value. '=' by default.",
            "title": "Options"
        },
        {
            "location": "/file/properties/index.coffee/#exemple",
            "text": "Use a custom delimiter with spaces around the equal sign.  require('nikita')\n.file.properties({\n  target: \"/path/to/target.json\",\n  content: { key: \"value\" },\n  separator: ' = '\n  merge: true\n})",
            "title": "Exemple"
        },
        {
            "location": "/file/properties/index.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering file.properties\", level: 'DEBUG', module: 'nikita/lib/file/properties'\n  # Options\n  throw Error \"Missing argument options.target\" unless options.target\n  options.separator ?= '='\n  options.content ?= {}\n  options.sort ?= false\n  # Trim\n  unless options.trim\n    fnl_props = options.content\n  else \n    fnl_props = {}\n    for k, v of options.content\n      k = k.trim()\n      v = v.trim() if typeof v is 'string'\n      fnl_props[k] = v\n  org_props = {}\n  options.log message: \"Merging \\\"#{if options.merge then 'true' else 'false'}\\\"\", level: 'DEBUG', module: 'nikita/lib/file/properties'\n  # Read Original\n  @file.properties.read\n    if_exists: true\n    ssh: options.ssh\n    target: options.target\n    separator: options.separator\n    comment: options.comment\n    trim: options.trim\n  , (err, props) ->\n    org_props = props or {} unless err\n  # Diff\n  @call (_, callback) ->\n    status = false\n    keys = {}\n    for k in Object.keys(org_props) then keys[k] = true\n    for k in Object.keys(fnl_props) then keys[k] = true\n    for key in Object.keys keys\n      if \"#{org_props[key]}\" isnt \"#{fnl_props[key]}\"\n        options.log? message: \"Property '#{key}' was '#{org_props[k]}' and is now '#{fnl_props[k]}'\", level: 'WARN', module: 'ryba/lib/file/properties'\n        status = true if fnl_props[key]?\n    callback null, status\n  # Merge\n  @call if: options.merge, ->\n    for k, v of fnl_props\n      org_props[k] = fnl_props[k]\n    fnl_props = org_props\n  @call ->\n    # Write data\n    keys = if options.sort then Object.keys(fnl_props).sort() else Object.keys(fnl_props)\n    data = for key in keys\n      if fnl_props[key]?\n      then \"#{key}#{options.separator}#{fnl_props[key]}\"\n      else \"#{key}\" # This is a comment\n    @file\n      target: \"#{options.target}\"\n      content: data.join '\\n'\n      backup: options.backup\n      eof: true\n      shy: true\n    @system.chown\n      target: options.target\n      uid: options.uid\n      gid: options.gid\n      if: options.uid? or options.gid?\n    @system.chmod\n      target: options.target\n      mode: options.mode\n      if: options.mode?",
            "title": "Source Code"
        },
        {
            "location": "/file/properties/read.coffee/",
            "text": "nikita.file.properties(options, callback)\n\n\nWrite a file in the Java properties format.\n\n\nOptions\n\n\n\n\ncomment\n (boolean) \n\n  Preserve comments, key is the comment while value is \"null\".\n\n\ntarget\n (string) \n\n  File to read and parse.\n\n\ntrim\n (boolean) \n\n  Trim keys and value.\n\n\nseparator\n (string) \n\n  The caracter to use for separating property and value. '=' by default.\n\n\n\n\nExemple\n\n\nUse a custom delimiter with spaces around the equal sign.\n\n\nrequire('nikita')\n.file.properties.read({\n  target: \"/path/to/target.json\",\n  separator: ' = '\n}, function(err, properties){\n  console.info(err || properties);\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering file.properties\", level: 'DEBUG', module: 'nikita/lib/file/properties/read'\n  # Options\n  options.separator ?= '='\n  options.comment ?= false\n  options.encoding ?= 'utf8'\n  throw Error \"Missing argument options.target\" unless options.target\n  @fs.readFile ssh: options.ssh, target: options.target, encoding: options.encoding, (err, data) ->\n    return callback err if err\n    props = {}\n    # Parse\n    lines = string.lines data\n    for line in lines\n      continue if /^\\s*$/.test line # Empty line\n      if /^#/.test line # Comment\n        props[line] = null if options.comment\n        continue\n      [_,k,v] = ///^(.*?)#{quote options.separator}(.*)$///.exec line\n      k = k.trim() if options.trim\n      v = v.trim() if options.trim\n      props[k] = v\n    callback null, props\n\n\n\nDependencies\n\n\nquote = require 'regexp-quote'\nstring = require '../../misc/string'",
            "title": "Read.coffee"
        },
        {
            "location": "/file/properties/read.coffee/#nikitafilepropertiesoptions-callback",
            "text": "Write a file in the Java properties format.",
            "title": "nikita.file.properties(options, callback)"
        },
        {
            "location": "/file/properties/read.coffee/#options",
            "text": "comment  (boolean)  \n  Preserve comments, key is the comment while value is \"null\".  target  (string)  \n  File to read and parse.  trim  (boolean)  \n  Trim keys and value.  separator  (string)  \n  The caracter to use for separating property and value. '=' by default.",
            "title": "Options"
        },
        {
            "location": "/file/properties/read.coffee/#exemple",
            "text": "Use a custom delimiter with spaces around the equal sign.  require('nikita')\n.file.properties.read({\n  target: \"/path/to/target.json\",\n  separator: ' = '\n}, function(err, properties){\n  console.info(err || properties);\n})",
            "title": "Exemple"
        },
        {
            "location": "/file/properties/read.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering file.properties\", level: 'DEBUG', module: 'nikita/lib/file/properties/read'\n  # Options\n  options.separator ?= '='\n  options.comment ?= false\n  options.encoding ?= 'utf8'\n  throw Error \"Missing argument options.target\" unless options.target\n  @fs.readFile ssh: options.ssh, target: options.target, encoding: options.encoding, (err, data) ->\n    return callback err if err\n    props = {}\n    # Parse\n    lines = string.lines data\n    for line in lines\n      continue if /^\\s*$/.test line # Empty line\n      if /^#/.test line # Comment\n        props[line] = null if options.comment\n        continue\n      [_,k,v] = ///^(.*?)#{quote options.separator}(.*)$///.exec line\n      k = k.trim() if options.trim\n      v = v.trim() if options.trim\n      props[k] = v\n    callback null, props",
            "title": "Source Code"
        },
        {
            "location": "/file/properties/read.coffee/#dependencies",
            "text": "quote = require 'regexp-quote'\nstring = require '../../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/file/types/ceph_conf.coffee/",
            "text": "nikita.file.types.ceph_conf\n\n\nceph is posix-compliant distributed file system. Writes \nconfiguration file\n\nas ceph daemons expect it.\n\n\nOptions\n\n\n\n\nrootdir\n (string) \n\n  Path to the mount point corresponding to the root directory, optional.\n\n\nbackup\n (string|boolean) \n\n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.\n\n\nclean\n \n\n  Remove all the lines whithout a key and a value, default to \"true\".\n\n\ncontent\n \n\n  Object to stringify.\n\n\nmerge\n \n\n  Read the target if it exists and merge its content.\n\n\nparse\n \n\n  User-defined function to parse the content from ini format, default to\n  \nrequire('ini').parse\n, see 'misc.ini.parse_multi_brackets'.\n\n\nseparator\n \n\n  Default separator between keys and values, default to \" : \".\n\n\nstringify\n \n\n  User-defined function to stringify the content to ini format, default to\n  \nrequire('ini').stringify\n, see 'misc.ini.stringify_square_then_curly' for\n  an example.\n\n\ntarget\n (string) \n\n  File to write, default to \"/etc/pacman.conf\".\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering file.types.ceph_conf\", level: 'DEBUG', module: 'nikita/lib/file/types/ceph_conf'\n  throw Error 'Missing target' unless options.target\n  options.target = \"#{path.join options.rootdir, options.target}\" if options.rootdir\n  @file.ini\n    stringify: misc.ini.stringify\n    parse: misc.ini.parse_multi_brackets\n    escape: false\n  , options\n\n\n\nDependencies\n\n\npath = require 'path'\nmisc = require '../../misc'",
            "title": "Ceph conf.coffee"
        },
        {
            "location": "/file/types/ceph_conf.coffee/#options",
            "text": "rootdir  (string)  \n  Path to the mount point corresponding to the root directory, optional.  backup  (string|boolean)  \n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.  clean   \n  Remove all the lines whithout a key and a value, default to \"true\".  content   \n  Object to stringify.  merge   \n  Read the target if it exists and merge its content.  parse   \n  User-defined function to parse the content from ini format, default to\n   require('ini').parse , see 'misc.ini.parse_multi_brackets'.  separator   \n  Default separator between keys and values, default to \" : \".  stringify   \n  User-defined function to stringify the content to ini format, default to\n   require('ini').stringify , see 'misc.ini.stringify_square_then_curly' for\n  an example.  target  (string)  \n  File to write, default to \"/etc/pacman.conf\".",
            "title": "Options"
        },
        {
            "location": "/file/types/ceph_conf.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering file.types.ceph_conf\", level: 'DEBUG', module: 'nikita/lib/file/types/ceph_conf'\n  throw Error 'Missing target' unless options.target\n  options.target = \"#{path.join options.rootdir, options.target}\" if options.rootdir\n  @file.ini\n    stringify: misc.ini.stringify\n    parse: misc.ini.parse_multi_brackets\n    escape: false\n  , options",
            "title": "Source Code"
        },
        {
            "location": "/file/types/ceph_conf.coffee/#dependencies",
            "text": "path = require 'path'\nmisc = require '../../misc'",
            "title": "Dependencies"
        },
        {
            "location": "/file/types/locale_gen.coffee/",
            "text": "nikita.file.types.locale_gen\n\n\nUpdate the locale definition file located in \"/etc/locale.gen\".\n\n\nOptions\n\n\n\n\nrootdir\n (string) \n\n    Path to the mount point corresponding to the root directory, optional.   \n\n\ngenerate\n (string) \n\n    Run \nlocale-gen\n if target was modified.   \n\n\nlocales\n (string) \n\n    List of supported locales, required.   \n\n\ntarget\n (string) \n\n    File to write, default to \"/etc/locale.gen\".   \n\n\n\n\nExample\n\n\nrequire('nikita').file.types.locale_gen({\n  target: '/etc/locale.gen',\n  rootdir: '/mnt',\n  locales: ['fr_FR.UTF-8', 'en_US.UTF-8'],\n  locale: 'en_US.UTF-8'\n})\n\n\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering file.types.local_gen\", level: 'DEBUG', module: 'nikita/lib/file/types/local_gen'\n  # Options\n  options.target ?= '/etc/locale.gen'\n  options.target = \"#{path.join options.rootdir, options.target}\" if options.rootdir\n  # Write configuration\n  @call (_, callback) ->\n    @fs.readFile ssh: options.ssh, target: options.target, encoding: 'ascii', (err, data) ->\n      return callback err if err\n      status = false\n      locales = data.split '\\n'\n      for locale, i in locales\n        if match = /^#([\\w_\\-\\.]+)($| .+$)/.exec locale\n          if match[1] in options.locales\n            locales[i] = match[1]+match[2]\n            status = true\n        if match = /^([\\w_\\-\\.]+)($| .+$)/.exec locale\n          if match[1] not in options.locales\n            locales[i] = '#'+match[1]+match[2]\n            status = true\n      return callback() unless status\n      data = locales.join '\\n'\n      @fs.writeFile ssh: options.ssh, target: options.target, content: data, (err) ->\n        callback err, true\n  # Reload configuration\n  @system.execute\n    if: -> options.generate and @status -1\n    cmd: \"locale-gen\"\n\n\n\nDependencies\n\n\npath = require 'path'",
            "title": "Locale gen.coffee"
        },
        {
            "location": "/file/types/locale_gen.coffee/#options",
            "text": "rootdir  (string)  \n    Path to the mount point corresponding to the root directory, optional.     generate  (string)  \n    Run  locale-gen  if target was modified.     locales  (string)  \n    List of supported locales, required.     target  (string)  \n    File to write, default to \"/etc/locale.gen\".",
            "title": "Options"
        },
        {
            "location": "/file/types/locale_gen.coffee/#example",
            "text": "require('nikita').file.types.locale_gen({\n  target: '/etc/locale.gen',\n  rootdir: '/mnt',\n  locales: ['fr_FR.UTF-8', 'en_US.UTF-8'],\n  locale: 'en_US.UTF-8'\n})  module.exports = (options) ->\n  options.log message: \"Entering file.types.local_gen\", level: 'DEBUG', module: 'nikita/lib/file/types/local_gen'\n  # Options\n  options.target ?= '/etc/locale.gen'\n  options.target = \"#{path.join options.rootdir, options.target}\" if options.rootdir\n  # Write configuration\n  @call (_, callback) ->\n    @fs.readFile ssh: options.ssh, target: options.target, encoding: 'ascii', (err, data) ->\n      return callback err if err\n      status = false\n      locales = data.split '\\n'\n      for locale, i in locales\n        if match = /^#([\\w_\\-\\.]+)($| .+$)/.exec locale\n          if match[1] in options.locales\n            locales[i] = match[1]+match[2]\n            status = true\n        if match = /^([\\w_\\-\\.]+)($| .+$)/.exec locale\n          if match[1] not in options.locales\n            locales[i] = '#'+match[1]+match[2]\n            status = true\n      return callback() unless status\n      data = locales.join '\\n'\n      @fs.writeFile ssh: options.ssh, target: options.target, content: data, (err) ->\n        callback err, true\n  # Reload configuration\n  @system.execute\n    if: -> options.generate and @status -1\n    cmd: \"locale-gen\"",
            "title": "Example"
        },
        {
            "location": "/file/types/locale_gen.coffee/#dependencies",
            "text": "path = require 'path'",
            "title": "Dependencies"
        },
        {
            "location": "/file/types/pacman_conf.coffee/",
            "text": "nikita.file.types.pacman_conf\n\n\npacman is a package manager utility for Arch Linux. The file is usually located \nin \"/etc/pacman.conf\".\n\n\nOptions\n\n\n\n\nrootdir\n (string) \n\n  Path to the mount point corresponding to the root directory, optional.\n\n\nbackup\n (string|boolean) \n\n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.\n\n\nclean\n \n\n  Remove all the lines whithout a key and a value, default to \"true\".\n\n\ncontent\n \n\n  Object to stringify.\n\n\nmerge\n \n\n  Read the target if it exists and merge its content.\n\n\nparse\n \n\n  User-defined function to parse the content from ini format, default to\n  \nrequire('ini').parse\n, see 'misc.ini.parse_multi_brackets'.\n\n\nseparator\n \n\n  Default separator between keys and values, default to \" : \".\n\n\nstringify\n \n\n  User-defined function to stringify the content to ini format, default to\n  \nrequire('ini').stringify\n, see 'misc.ini.stringify_square_then_curly' for\n  an example.\n\n\ntarget\n (string) \n\n  File to write, default to \"/etc/pacman.conf\".\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering file.types.pacman_conf\", level: 'DEBUG', module: 'nikita/lib/file/types/pacman_conf'\n  options.target ?= '/etc/pacman.conf'\n  options.target = \"#{path.join options.rootdir, options.target}\" if options.rootdir\n  @file.ini\n    stringify: misc.ini.stringify_single_key\n  , options\n\n\n\nDependencies\n\n\npath = require 'path'\nmisc = require '../../misc'",
            "title": "Pacman conf.coffee"
        },
        {
            "location": "/file/types/pacman_conf.coffee/#options",
            "text": "rootdir  (string)  \n  Path to the mount point corresponding to the root directory, optional.  backup  (string|boolean)  \n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.  clean   \n  Remove all the lines whithout a key and a value, default to \"true\".  content   \n  Object to stringify.  merge   \n  Read the target if it exists and merge its content.  parse   \n  User-defined function to parse the content from ini format, default to\n   require('ini').parse , see 'misc.ini.parse_multi_brackets'.  separator   \n  Default separator between keys and values, default to \" : \".  stringify   \n  User-defined function to stringify the content to ini format, default to\n   require('ini').stringify , see 'misc.ini.stringify_square_then_curly' for\n  an example.  target  (string)  \n  File to write, default to \"/etc/pacman.conf\".",
            "title": "Options"
        },
        {
            "location": "/file/types/pacman_conf.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering file.types.pacman_conf\", level: 'DEBUG', module: 'nikita/lib/file/types/pacman_conf'\n  options.target ?= '/etc/pacman.conf'\n  options.target = \"#{path.join options.rootdir, options.target}\" if options.rootdir\n  @file.ini\n    stringify: misc.ini.stringify_single_key\n  , options",
            "title": "Source Code"
        },
        {
            "location": "/file/types/pacman_conf.coffee/#dependencies",
            "text": "path = require 'path'\nmisc = require '../../misc'",
            "title": "Dependencies"
        },
        {
            "location": "/file/types/ssh_authorized_keys.coffee/",
            "text": "nikita.file.types.ssh_authorized_keys\n\n\nNote, due to the restrictive permission imposed by sshd on the parent directory,\nthis action will not attempt to create nor modify the parent directory and will\nthrow an Error if it does not exists.\n\n\nOptions\n\n\n\n\ngid\n \n\n  File group name or group id.\n\n\nkeys\n \n\n  Array containing the public keys.\n\n\nmerge\n (string) \n\n  File to write, default to \"/etc/pacman.conf\".\n\n\nmode\n \n\n  File mode (permission and sticky bits), default to \n0o0644\n, in the form of\n\n{mode: 0o0744}\n or \n{mode: \"0744\"}\n.\n\n\ntarget\n (string) \n\n  File to write, default to \"/etc/pacman.conf\".\n\n\nuid\n \n\n  File user name or user id.\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  throw Error \"Required Option: target, got #{JSON.stringify options.target}\" unless options.target\n  throw Error \"Required Option: keys, got #{JSON.stringify options.keys}\" unless options.keys\n  throw Error \"Invallid Option: keys must be an array, got #{JSON.stringify options.keys}\" unless Array.isArray options.keys\n  @file.assert\n    target: path.dirname options.target\n  @file\n    unless: options.merge\n    target: options.target\n    content: options.keys.join '\\n'\n    uid: options.uid\n    gid: options.gid\n    mode: options.mode\n    eof: true\n  @file\n    if: options.merge\n    target: options.target\n    write: for key in options.keys\n      match: new RegExp \".*#{misc.regexp.escape key}.*\", 'mg'\n      replace: key\n      append: true\n    uid: options.uid\n    gid: options.gid\n    mode: options.mode\n    eof: true\n\n\n\nDependencies\n\n\npath = require 'path'\nmisc = require '../../misc'",
            "title": "Ssh authorized keys.coffee"
        },
        {
            "location": "/file/types/ssh_authorized_keys.coffee/#options",
            "text": "gid   \n  File group name or group id.  keys   \n  Array containing the public keys.  merge  (string)  \n  File to write, default to \"/etc/pacman.conf\".  mode   \n  File mode (permission and sticky bits), default to  0o0644 , in the form of {mode: 0o0744}  or  {mode: \"0744\"} .  target  (string)  \n  File to write, default to \"/etc/pacman.conf\".  uid   \n  File user name or user id.",
            "title": "Options"
        },
        {
            "location": "/file/types/ssh_authorized_keys.coffee/#source-code",
            "text": "module.exports = (options) ->\n  throw Error \"Required Option: target, got #{JSON.stringify options.target}\" unless options.target\n  throw Error \"Required Option: keys, got #{JSON.stringify options.keys}\" unless options.keys\n  throw Error \"Invallid Option: keys must be an array, got #{JSON.stringify options.keys}\" unless Array.isArray options.keys\n  @file.assert\n    target: path.dirname options.target\n  @file\n    unless: options.merge\n    target: options.target\n    content: options.keys.join '\\n'\n    uid: options.uid\n    gid: options.gid\n    mode: options.mode\n    eof: true\n  @file\n    if: options.merge\n    target: options.target\n    write: for key in options.keys\n      match: new RegExp \".*#{misc.regexp.escape key}.*\", 'mg'\n      replace: key\n      append: true\n    uid: options.uid\n    gid: options.gid\n    mode: options.mode\n    eof: true",
            "title": "Source Code"
        },
        {
            "location": "/file/types/ssh_authorized_keys.coffee/#dependencies",
            "text": "path = require 'path'\nmisc = require '../../misc'",
            "title": "Dependencies"
        },
        {
            "location": "/file/types/yum_repo.coffee/",
            "text": "nikita.file.types.yum_repo\n\n\nYum is a packet manager for centos/redhat. It uses .repo file located in \n\"/etc/yum.repos.d/\" directory to configure the list of available mirrors.\n\n\nOptions\n\n\nThis action honors all the options from \"nikita.file.ini\". It overwrites the\nfollowing options:\n\n\n\n\nescape\n (boolean) \n\n  Set to \nfalse\n instead of \ntrue\n by default.\n\n\nparse\n \n\n  Set to \nmisc.ini.parse_multi_brackets\n.\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering file.types.yum_repo\", level: 'DEBUG', module: 'nikita/lib/file/types/yum_repo'\n  throw Error \"Required Option: option 'target' is mandatory\" unless options.target\n  # Set the targeyt directory to yum's default path if target is a file name\n  options.target = path.resolve '/etc/yum.repos.d', options.target\n  @file.ini\n    parse: misc.ini.parse_multi_brackets\n    escape: false\n  , options\n\n\n\nDependencies\n\n\npath = require 'path'\nmisc = require '../../misc'",
            "title": "Yum repo.coffee"
        },
        {
            "location": "/file/types/yum_repo.coffee/#options",
            "text": "This action honors all the options from \"nikita.file.ini\". It overwrites the\nfollowing options:   escape  (boolean)  \n  Set to  false  instead of  true  by default.  parse   \n  Set to  misc.ini.parse_multi_brackets .",
            "title": "Options"
        },
        {
            "location": "/file/types/yum_repo.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering file.types.yum_repo\", level: 'DEBUG', module: 'nikita/lib/file/types/yum_repo'\n  throw Error \"Required Option: option 'target' is mandatory\" unless options.target\n  # Set the targeyt directory to yum's default path if target is a file name\n  options.target = path.resolve '/etc/yum.repos.d', options.target\n  @file.ini\n    parse: misc.ini.parse_multi_brackets\n    escape: false\n  , options",
            "title": "Source Code"
        },
        {
            "location": "/file/types/yum_repo.coffee/#dependencies",
            "text": "path = require 'path'\nmisc = require '../../misc'",
            "title": "Dependencies"
        },
        {
            "location": "/file/types/etc_group/read.coffee/",
            "text": "nikita.system.etc_group.read(options, [callback])\n\n\nRead and parse the group definition file located in \"/etc/group\".\n\n\nOptions\n\n\n\n\ncache\n (boolean) \n\n  Cache the result inside the store.\n\n\ntarget\n (string) \n\n  Path to the group definition file, default to \"/etc/group\".\n\n\ngid\n (string|integer) \n\n  Retrieve the information for a specific group name or guid.\n\n\n\n\nSource Code\n\n\nmodule.exports = shy: true, handler: (options, callback) ->\n  options.log message: \"Entering etc_group.read\", level: 'DEBUG', module: 'nikita/lib/system/etc_group/read'\n  options.target ?= '/etc/group'\n  # Retrieve groups from cache\n  groups = null\n  @call\n    if: options.cache and !!@store['nikita:etc_group']\n  , ->\n    options.log message: \"Get group definition from cache\", level: 'INFO', module: 'nikita/lib/system/etc_group/read'\n    groups = @store['nikita:etc_group']\n  # Read system groups and place in cache if requested\n  @fs.readFile\n    unless: options.cache and !!@store['nikita:etc_group']\n    target: options.target\n    encoding: 'ascii'\n  , (err, content) ->\n    throw err if err\n    return unless content?\n    groups = {}\n    for line in string.lines content\n      line = /(.*)\\:(.*)\\:(.*)\\:(.*)/.exec line\n      continue unless line\n      groups[line[1]] = group: line[1], password: line[2], gid: parseInt(line[3]), user_list: if line[4] then line[4].split ',' else []\n    @store['nikita:etc_group'] = groups if options.cache\n  # Pass the group information\n  @next (err) ->\n    return callback err if err\n    return callback null, true, groups unless options.gid\n    return callback null, true, groups[options.gid] if groups[options.gid]?\n    options.gid = parseInt options.gid, 10 if typeof options.gid is 'string' and /\\d+/.test options.gid\n    group = Object.values(groups).filter((group) -> group.gid is options.gid)[0]\n    return callback Error \"Invalid Option: no gid matching #{JSON.stringify options.gid}\" unless group\n    callback null, true, group\n\n\n\nDependencies\n\n\nstring = require '../../../misc/string'",
            "title": "Read.coffee"
        },
        {
            "location": "/file/types/etc_group/read.coffee/#nikitasystemetc_groupreadoptions-callback",
            "text": "Read and parse the group definition file located in \"/etc/group\".",
            "title": "nikita.system.etc_group.read(options, [callback])"
        },
        {
            "location": "/file/types/etc_group/read.coffee/#options",
            "text": "cache  (boolean)  \n  Cache the result inside the store.  target  (string)  \n  Path to the group definition file, default to \"/etc/group\".  gid  (string|integer)  \n  Retrieve the information for a specific group name or guid.",
            "title": "Options"
        },
        {
            "location": "/file/types/etc_group/read.coffee/#source-code",
            "text": "module.exports = shy: true, handler: (options, callback) ->\n  options.log message: \"Entering etc_group.read\", level: 'DEBUG', module: 'nikita/lib/system/etc_group/read'\n  options.target ?= '/etc/group'\n  # Retrieve groups from cache\n  groups = null\n  @call\n    if: options.cache and !!@store['nikita:etc_group']\n  , ->\n    options.log message: \"Get group definition from cache\", level: 'INFO', module: 'nikita/lib/system/etc_group/read'\n    groups = @store['nikita:etc_group']\n  # Read system groups and place in cache if requested\n  @fs.readFile\n    unless: options.cache and !!@store['nikita:etc_group']\n    target: options.target\n    encoding: 'ascii'\n  , (err, content) ->\n    throw err if err\n    return unless content?\n    groups = {}\n    for line in string.lines content\n      line = /(.*)\\:(.*)\\:(.*)\\:(.*)/.exec line\n      continue unless line\n      groups[line[1]] = group: line[1], password: line[2], gid: parseInt(line[3]), user_list: if line[4] then line[4].split ',' else []\n    @store['nikita:etc_group'] = groups if options.cache\n  # Pass the group information\n  @next (err) ->\n    return callback err if err\n    return callback null, true, groups unless options.gid\n    return callback null, true, groups[options.gid] if groups[options.gid]?\n    options.gid = parseInt options.gid, 10 if typeof options.gid is 'string' and /\\d+/.test options.gid\n    group = Object.values(groups).filter((group) -> group.gid is options.gid)[0]\n    return callback Error \"Invalid Option: no gid matching #{JSON.stringify options.gid}\" unless group\n    callback null, true, group",
            "title": "Source Code"
        },
        {
            "location": "/file/types/etc_group/read.coffee/#dependencies",
            "text": "string = require '../../../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/file/types/etc_passwd/read.coffee/",
            "text": "nikita.system.etc_passwd.read(options, [callback])\n\n\nRead and parse the passwd definition file located in \"/etc/passwd\".\n\n\nOptions\n\n\n\n\ncache\n (boolean) \n\n  Cache the result inside the store.\n\n\ntarget\n (string) \n\n  Path to the passwd definition file, default to \"/etc/passwd\".\n\n\nuid\n (string|integer) \n\n  Retrieve the information for a specific user name or uid.\n\n\n\n\nSource Code\n\n\nmodule.exports = shy: true, handler: (options, callback) ->\n  options.log message: \"Entering etc_passwd.read\", level: 'DEBUG', module: 'nikita/lib/system/etc_passwd/read'\n  throw Error 'Invalid Option: uid must be a string or a number' if options.uid and not typeof options.uid in ['string', 'number']\n  options.uid = parseInt options.uid, 10 if typeof options.uid is 'string' and /\\d+/.test options.uid\n  options.target ?= '/etc/passwd'\n  # Retrieve passwd from cache\n  passwd = null\n  @call\n    if: options.cache and !!@store['nikita:etc_passwd']\n  , ->\n    options.log message: \"Get passwd definition from cache\", level: 'INFO', module: 'nikita/lib/system/etc_passwd/read'\n    passwd = @store['nikita:etc_passwd']\n  # Read system passwd and place in cache if requested\n  @fs.readFile\n    unless: options.cache and !!@store['nikita:etc_passwd']\n    target: options.target\n    encoding: 'ascii'\n  , (err, content) ->\n    throw err if err\n    return unless content?\n    passwd = {}\n    for line in string.lines content\n      line = /(.*)\\:\\w\\:(.*)\\:(.*)\\:(.*)\\:(.*)\\:(.*)/.exec line\n      continue unless line\n      passwd[line[1]] = user: line[1], uid: parseInt(line[2]), gid: parseInt(line[3]), comment: line[4], home: line[5], shell: line[6]\n    @store['nikita:etc_passwd'] = passwd if options.cache\n  # Pass the passwd information\n  @next (err) ->\n    return callback err if err\n    return callback null, true, passwd unless options.uid\n    if typeof options.uid is 'string'\n      user = passwd[options.uid]\n      return callback Error \"Invalid Option: no uid matching #{JSON.stringify options.uid}\" unless user\n      callback null, true, user\n    else\n      user = Object.values(passwd).filter((user) -> user.uid is options.uid)[0]\n      return callback Error \"Invalid Option: no uid matching #{JSON.stringify options.uid}\" unless user\n      callback null, true, user\n\n\n\nDependencies\n\n\nstring = require '../../../misc/string'",
            "title": "Read.coffee"
        },
        {
            "location": "/file/types/etc_passwd/read.coffee/#nikitasystemetc_passwdreadoptions-callback",
            "text": "Read and parse the passwd definition file located in \"/etc/passwd\".",
            "title": "nikita.system.etc_passwd.read(options, [callback])"
        },
        {
            "location": "/file/types/etc_passwd/read.coffee/#options",
            "text": "cache  (boolean)  \n  Cache the result inside the store.  target  (string)  \n  Path to the passwd definition file, default to \"/etc/passwd\".  uid  (string|integer)  \n  Retrieve the information for a specific user name or uid.",
            "title": "Options"
        },
        {
            "location": "/file/types/etc_passwd/read.coffee/#source-code",
            "text": "module.exports = shy: true, handler: (options, callback) ->\n  options.log message: \"Entering etc_passwd.read\", level: 'DEBUG', module: 'nikita/lib/system/etc_passwd/read'\n  throw Error 'Invalid Option: uid must be a string or a number' if options.uid and not typeof options.uid in ['string', 'number']\n  options.uid = parseInt options.uid, 10 if typeof options.uid is 'string' and /\\d+/.test options.uid\n  options.target ?= '/etc/passwd'\n  # Retrieve passwd from cache\n  passwd = null\n  @call\n    if: options.cache and !!@store['nikita:etc_passwd']\n  , ->\n    options.log message: \"Get passwd definition from cache\", level: 'INFO', module: 'nikita/lib/system/etc_passwd/read'\n    passwd = @store['nikita:etc_passwd']\n  # Read system passwd and place in cache if requested\n  @fs.readFile\n    unless: options.cache and !!@store['nikita:etc_passwd']\n    target: options.target\n    encoding: 'ascii'\n  , (err, content) ->\n    throw err if err\n    return unless content?\n    passwd = {}\n    for line in string.lines content\n      line = /(.*)\\:\\w\\:(.*)\\:(.*)\\:(.*)\\:(.*)\\:(.*)/.exec line\n      continue unless line\n      passwd[line[1]] = user: line[1], uid: parseInt(line[2]), gid: parseInt(line[3]), comment: line[4], home: line[5], shell: line[6]\n    @store['nikita:etc_passwd'] = passwd if options.cache\n  # Pass the passwd information\n  @next (err) ->\n    return callback err if err\n    return callback null, true, passwd unless options.uid\n    if typeof options.uid is 'string'\n      user = passwd[options.uid]\n      return callback Error \"Invalid Option: no uid matching #{JSON.stringify options.uid}\" unless user\n      callback null, true, user\n    else\n      user = Object.values(passwd).filter((user) -> user.uid is options.uid)[0]\n      return callback Error \"Invalid Option: no uid matching #{JSON.stringify options.uid}\" unless user\n      callback null, true, user",
            "title": "Source Code"
        },
        {
            "location": "/file/types/etc_passwd/read.coffee/#dependencies",
            "text": "string = require '../../../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/fs/chmod.coffee/",
            "text": "nikita.fs.chmod(options, callback)\n\n\nChange permissions of a file.\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.chmod\", level: 'DEBUG', module: 'nikita/lib/fs/chmod'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  # Validate options\n  throw Error \"Missing target: #{JSON.stringify options.target}\" unless options.target\n  throw Error \"Missing option 'mode'\" unless options.mode\n  options.mode = options.mode.toString(8).substr(-4) if typeof options.mode is 'number'\n  @system.execute\n    if: options.mode\n    cmd: \"chmod #{options.mode} #{options.target}\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err) ->\n   callback err",
            "title": "Chmod.coffee"
        },
        {
            "location": "/fs/chmod.coffee/#nikitafschmodoptions-callback",
            "text": "Change permissions of a file.",
            "title": "nikita.fs.chmod(options, callback)"
        },
        {
            "location": "/fs/chmod.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.chmod\", level: 'DEBUG', module: 'nikita/lib/fs/chmod'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  # Validate options\n  throw Error \"Missing target: #{JSON.stringify options.target}\" unless options.target\n  throw Error \"Missing option 'mode'\" unless options.mode\n  options.mode = options.mode.toString(8).substr(-4) if typeof options.mode is 'number'\n  @system.execute\n    if: options.mode\n    cmd: \"chmod #{options.mode} #{options.target}\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err) ->\n   callback err",
            "title": "Source Code"
        },
        {
            "location": "/fs/chown.coffee/",
            "text": "nikita.fs.chown(options, callback)\n\n\nChange ownership of a file.\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.chown\", level: 'DEBUG', module: 'nikita/lib/fs/chown'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  options.uid = null if options.uid is false\n  options.gid = null if options.gid is false\n  # Validate options\n  throw Error \"Missing target: #{JSON.stringify options.target}\" unless options.target\n  throw Error \"Missing one of uid or gid option\" unless options.uid? or options.gid?\n  @system.execute\n    if: options.uid? or options.gid?\n    cmd: \"\"\"\n    [ ! -z '#{if options.uid? then options.uid else ''}' ] && chown #{options.uid} #{options.target}\n    [ ! -z '#{if options.gid? then options.gid else ''}' ] && chgrp #{options.gid} #{options.target}\n    \"\"\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err) ->\n   callback err",
            "title": "Chown.coffee"
        },
        {
            "location": "/fs/chown.coffee/#nikitafschownoptions-callback",
            "text": "Change ownership of a file.",
            "title": "nikita.fs.chown(options, callback)"
        },
        {
            "location": "/fs/chown.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.chown\", level: 'DEBUG', module: 'nikita/lib/fs/chown'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  options.uid = null if options.uid is false\n  options.gid = null if options.gid is false\n  # Validate options\n  throw Error \"Missing target: #{JSON.stringify options.target}\" unless options.target\n  throw Error \"Missing one of uid or gid option\" unless options.uid? or options.gid?\n  @system.execute\n    if: options.uid? or options.gid?\n    cmd: \"\"\"\n    [ ! -z '#{if options.uid? then options.uid else ''}' ] && chown #{options.uid} #{options.target}\n    [ ! -z '#{if options.gid? then options.gid else ''}' ] && chgrp #{options.gid} #{options.target}\n    \"\"\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err) ->\n   callback err",
            "title": "Source Code"
        },
        {
            "location": "/fs/copy.coffee/",
            "text": "nikita.fs.copy(options, callback)\n\n\nChange permissions of a file.\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.copy\", level: 'DEBUG', module: 'nikita/lib/fs/copy'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  # Validate options\n  throw Error \"Missing target: #{JSON.stringify options.target}\" unless options.target\n  throw Error \"Missing source: #{JSON.stringify options.source}\" unless options.source\n  @system.execute\n    cmd: \"\"\"\n    [ ! -d `dirname \"#{options.target}\"` ] && exit 2\n    cp #{options.source} #{options.target}\n    \"\"\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err) ->\n    if err?.code is 2\n      err.code = 'ENOENT'\n      err.errno = -2\n      err.syscall = 'open'\n      err.path = options.target\n      err.message = \"Invalid Target: no such file or directory, open #{JSON.stringify options.target}\"\n    callback err",
            "title": "Copy.coffee"
        },
        {
            "location": "/fs/copy.coffee/#nikitafscopyoptions-callback",
            "text": "Change permissions of a file.",
            "title": "nikita.fs.copy(options, callback)"
        },
        {
            "location": "/fs/copy.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.copy\", level: 'DEBUG', module: 'nikita/lib/fs/copy'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  # Validate options\n  throw Error \"Missing target: #{JSON.stringify options.target}\" unless options.target\n  throw Error \"Missing source: #{JSON.stringify options.source}\" unless options.source\n  @system.execute\n    cmd: \"\"\"\n    [ ! -d `dirname \"#{options.target}\"` ] && exit 2\n    cp #{options.source} #{options.target}\n    \"\"\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err) ->\n    if err?.code is 2\n      err.code = 'ENOENT'\n      err.errno = -2\n      err.syscall = 'open'\n      err.path = options.target\n      err.message = \"Invalid Target: no such file or directory, open #{JSON.stringify options.target}\"\n    callback err",
            "title": "Source Code"
        },
        {
            "location": "/fs/createReadStream.coffee/",
            "text": "nikita.fs.createReadStream(options, callback)\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.createReadStream\", level: 'DEBUG', module: 'nikita/lib/fs/createReadStream'\n  ssh = @ssh options.ssh\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  options.target_tmp ?= \"/tmp/nikita_#{string.hash options.target}\" if options.sudo\n  content = null\n  @call if: options.target_tmp, ->\n    @system.execute\n      sudo: options.sudo\n      bash: options.bash\n      arch_chroot: options.arch_chroot\n      cmd: \"\"\"\n      [ ! -f '#{options.target}' ] && exit\n      cp '#{options.target}' '#{options.target_tmp}'\n      \"\"\"\n  , (err, status) ->\n    options.log unless err\n    then message: \"Placing original file in temporary path before reading\", level: 'INFO', module: 'nikita/lib/fs/createReadStream'\n    else message: \"Failed to place original file in temporary path\", level: 'ERROR', module: 'nikita/lib/fs/createReadStream'\n    callback err if err\n  @call ->\n    buffers = []\n    options.log message: \"Reading file #{options.target_tmp or options.target}\", level: 'DEBUG', module: 'nikita/lib/fs/createReadStream'\n    fs.createReadStream ssh, options.target_tmp or options.target, (err, rs) ->\n      return callback err if err\n      rs.on 'readable', ->\n        options.on_readable rs\n      rs.on 'error', callback\n      rs.on 'end', callback\n\n\n\nDependencies\n\n\nfs = require 'ssh2-fs'",
            "title": "createReadStream.coffee"
        },
        {
            "location": "/fs/createReadStream.coffee/#nikitafscreatereadstreamoptions-callback",
            "text": "",
            "title": "nikita.fs.createReadStream(options, callback)"
        },
        {
            "location": "/fs/createReadStream.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.createReadStream\", level: 'DEBUG', module: 'nikita/lib/fs/createReadStream'\n  ssh = @ssh options.ssh\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  options.target_tmp ?= \"/tmp/nikita_#{string.hash options.target}\" if options.sudo\n  content = null\n  @call if: options.target_tmp, ->\n    @system.execute\n      sudo: options.sudo\n      bash: options.bash\n      arch_chroot: options.arch_chroot\n      cmd: \"\"\"\n      [ ! -f '#{options.target}' ] && exit\n      cp '#{options.target}' '#{options.target_tmp}'\n      \"\"\"\n  , (err, status) ->\n    options.log unless err\n    then message: \"Placing original file in temporary path before reading\", level: 'INFO', module: 'nikita/lib/fs/createReadStream'\n    else message: \"Failed to place original file in temporary path\", level: 'ERROR', module: 'nikita/lib/fs/createReadStream'\n    callback err if err\n  @call ->\n    buffers = []\n    options.log message: \"Reading file #{options.target_tmp or options.target}\", level: 'DEBUG', module: 'nikita/lib/fs/createReadStream'\n    fs.createReadStream ssh, options.target_tmp or options.target, (err, rs) ->\n      return callback err if err\n      rs.on 'readable', ->\n        options.on_readable rs\n      rs.on 'error', callback\n      rs.on 'end', callback",
            "title": "Source Code"
        },
        {
            "location": "/fs/createReadStream.coffee/#dependencies",
            "text": "fs = require 'ssh2-fs'",
            "title": "Dependencies"
        },
        {
            "location": "/fs/exists.coffee/",
            "text": "nikita.fs.lstat(options, callback)\n\n\nRetrieve file information. If path is a symbolic link, then the link itself is\nstat-ed, not the file that it refers to.\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.exists\", level: 'DEBUG', module: 'nikita/lib/fs/exists'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  @fs.stat\n    target: options.target\n    dereference: true\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n    relax: true\n  , (err) ->\n    callback null, not err",
            "title": "Exists.coffee"
        },
        {
            "location": "/fs/exists.coffee/#nikitafslstatoptions-callback",
            "text": "Retrieve file information. If path is a symbolic link, then the link itself is\nstat-ed, not the file that it refers to.",
            "title": "nikita.fs.lstat(options, callback)"
        },
        {
            "location": "/fs/exists.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.exists\", level: 'DEBUG', module: 'nikita/lib/fs/exists'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  @fs.stat\n    target: options.target\n    dereference: true\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n    relax: true\n  , (err) ->\n    callback null, not err",
            "title": "Source Code"
        },
        {
            "location": "/fs/lstat.coffee/",
            "text": "nikita.fs.lstat(options, callback)\n\n\nRetrieve file information. If path is a symbolic link, then the link itself is\nstat-ed, not the file that it refers to.\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.lstat\", level: 'DEBUG', module: 'nikita/lib/fs/lstat'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  @fs.stat\n    target: options.target\n    dereference: false\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , callback",
            "title": "Lstat.coffee"
        },
        {
            "location": "/fs/lstat.coffee/#nikitafslstatoptions-callback",
            "text": "Retrieve file information. If path is a symbolic link, then the link itself is\nstat-ed, not the file that it refers to.",
            "title": "nikita.fs.lstat(options, callback)"
        },
        {
            "location": "/fs/lstat.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.lstat\", level: 'DEBUG', module: 'nikita/lib/fs/lstat'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  @fs.stat\n    target: options.target\n    dereference: false\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , callback",
            "title": "Source Code"
        },
        {
            "location": "/fs/mkdir.coffee/",
            "text": "nikita.fs.mkdir(options, callback)\n\n\nMake directories.\n\n\nOptions\n\n\n\n\nuid\n \n\n  Unix user id.   \n\n\ngid\n \n\n  Unix group id.   \n\n\nmode\n \n\n  Default to \"0755\".   \n\n\ndirectory\n \n\n  Path or array of paths.   \n\n\ntarget\n \n\n  Alias for \ndirectory\n. \n\n\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.mkdir\", level: 'DEBUG', module: 'nikita/lib/fs/mkdir'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  # Validate parameters\n  throw Error \"Missing target: #{JSON.stringify options.target}\" unless options.target\n  cmd = if options.uid or options.gid then 'install ' else 'mkdir '\n  if options.mode\n    options.mode = options.mode.toString(8).substr(-4) if typeof options.mode is 'number'\n    cmd += \"-m '#{options.mode}' \"\n  cmd += \" --owner #{options.uid} \" if options.uid\n  cmd += \" --group #{options.gid} \" if options.gid\n  cmd +=  if options.uid or options.gid then \" -d #{options.target}\" else \"#{options.target}\"\n  @system.execute\n    cmd: cmd\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err) ->\n    callback err",
            "title": "Mkdir.coffee"
        },
        {
            "location": "/fs/mkdir.coffee/#nikitafsmkdiroptions-callback",
            "text": "Make directories.",
            "title": "nikita.fs.mkdir(options, callback)"
        },
        {
            "location": "/fs/mkdir.coffee/#options",
            "text": "uid   \n  Unix user id.     gid   \n  Unix group id.     mode   \n  Default to \"0755\".     directory   \n  Path or array of paths.     target   \n  Alias for  directory .",
            "title": "Options"
        },
        {
            "location": "/fs/mkdir.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.mkdir\", level: 'DEBUG', module: 'nikita/lib/fs/mkdir'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  # Validate parameters\n  throw Error \"Missing target: #{JSON.stringify options.target}\" unless options.target\n  cmd = if options.uid or options.gid then 'install ' else 'mkdir '\n  if options.mode\n    options.mode = options.mode.toString(8).substr(-4) if typeof options.mode is 'number'\n    cmd += \"-m '#{options.mode}' \"\n  cmd += \" --owner #{options.uid} \" if options.uid\n  cmd += \" --group #{options.gid} \" if options.gid\n  cmd +=  if options.uid or options.gid then \" -d #{options.target}\" else \"#{options.target}\"\n  @system.execute\n    cmd: cmd\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err) ->\n    callback err",
            "title": "Source Code"
        },
        {
            "location": "/fs/readFile.coffee/",
            "text": "nikita.fs.readFile(options, callback)\n\n\nOptions:\n\n\n\n\ntarget\n (string) \n\n  Path of the file to read; required.\n\n\nencoding\n (string)\n  Return a string with a particular encoding, otherwise a buffer is returned; \n  optional.\n\n\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.readFile\", level: 'DEBUG', module: 'nikita/lib/fs/readFile'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  buffers = []\n  @fs.createReadStream\n    target: options.target\n    on_readable: (rs) ->\n      while buffer = rs.read()\n        buffers.push buffer\n  , (err) ->\n    result = Buffer.concat buffers\n    result = result.toString options.encoding if options.encoding\n    callback err, result",
            "title": "readFile.coffee"
        },
        {
            "location": "/fs/readFile.coffee/#nikitafsreadfileoptions-callback",
            "text": "Options:   target  (string)  \n  Path of the file to read; required.  encoding  (string)\n  Return a string with a particular encoding, otherwise a buffer is returned; \n  optional.",
            "title": "nikita.fs.readFile(options, callback)"
        },
        {
            "location": "/fs/readFile.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.readFile\", level: 'DEBUG', module: 'nikita/lib/fs/readFile'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  buffers = []\n  @fs.createReadStream\n    target: options.target\n    on_readable: (rs) ->\n      while buffer = rs.read()\n        buffers.push buffer\n  , (err) ->\n    result = Buffer.concat buffers\n    result = result.toString options.encoding if options.encoding\n    callback err, result",
            "title": "Source Code"
        },
        {
            "location": "/fs/readlink.coffee/",
            "text": "nikita.fs.readlink(options, callback)\n\n\nDelete a name and possibly the file it refers to.\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.readlink\", level: 'DEBUG', module: 'nikita/lib/fs/readlink'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  @system.execute\n    cmd: \"readlink #{options.target}\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err, _, stdout) ->\n    callback err, stdout.trim()",
            "title": "Readlink.coffee"
        },
        {
            "location": "/fs/readlink.coffee/#nikitafsreadlinkoptions-callback",
            "text": "Delete a name and possibly the file it refers to.",
            "title": "nikita.fs.readlink(options, callback)"
        },
        {
            "location": "/fs/readlink.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.readlink\", level: 'DEBUG', module: 'nikita/lib/fs/readlink'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  @system.execute\n    cmd: \"readlink #{options.target}\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err, _, stdout) ->\n    callback err, stdout.trim()",
            "title": "Source Code"
        },
        {
            "location": "/fs/rename.coffee/",
            "text": "nikita.fs.rename(options, callback)\n\n\nChange the name or location of a file.\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.rename\", level: 'DEBUG', module: 'nikita/lib/fs/rename'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  throw Error \"Required Option: the \\\"source\\\" option is mandatory\" unless options.source\n  @system.execute\n    cmd: \"mv #{options.source} #{options.target}\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err, _, stdout) ->\n    callback err, stdout.trim()",
            "title": "Rename.coffee"
        },
        {
            "location": "/fs/rename.coffee/#nikitafsrenameoptions-callback",
            "text": "Change the name or location of a file.",
            "title": "nikita.fs.rename(options, callback)"
        },
        {
            "location": "/fs/rename.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.rename\", level: 'DEBUG', module: 'nikita/lib/fs/rename'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  throw Error \"Required Option: the \\\"source\\\" option is mandatory\" unless options.source\n  @system.execute\n    cmd: \"mv #{options.source} #{options.target}\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err, _, stdout) ->\n    callback err, stdout.trim()",
            "title": "Source Code"
        },
        {
            "location": "/fs/rmdir.coffee/",
            "text": "nikita.fs.rmdir(options, callback)\n\n\nDelete a directory.\n\n\n\n\ntarget\n (string) \n\n  Final destination path.\n\n\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options) ->\n  options.log message: \"Entering fs.rmdir\", level: 'DEBUG', module: 'nikita/lib/fs/rmdir'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  @system.execute\n    cmd: \"\"\"\n    [ ! -d '#{options.target}' ] && exit 2\n    rmdir '#{options.target}'\n    \"\"\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err, status) ->\n    if err?.code is 2\n      err = Error \"ENOENT: no such file or directory, rmdir '#{options.target}'\"\n      err.errno = -2\n      err.code = 'ENOENT'\n      err.syscall = 'rmdir'\n      err.path = \"#{options.target}\"\n    options.log unless err\n    then message: \"Directory successfully removed\", level: 'INFO', module: 'nikita/lib/fs/write'\n    else message: \"Fail to remove directory\", level: 'ERROR', module: 'nikita/lib/fs/write'\n    throw err",
            "title": "Rmdir.coffee"
        },
        {
            "location": "/fs/rmdir.coffee/#nikitafsrmdiroptions-callback",
            "text": "Delete a directory.   target  (string)  \n  Final destination path.",
            "title": "nikita.fs.rmdir(options, callback)"
        },
        {
            "location": "/fs/rmdir.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options) ->\n  options.log message: \"Entering fs.rmdir\", level: 'DEBUG', module: 'nikita/lib/fs/rmdir'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  @system.execute\n    cmd: \"\"\"\n    [ ! -d '#{options.target}' ] && exit 2\n    rmdir '#{options.target}'\n    \"\"\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err, status) ->\n    if err?.code is 2\n      err = Error \"ENOENT: no such file or directory, rmdir '#{options.target}'\"\n      err.errno = -2\n      err.code = 'ENOENT'\n      err.syscall = 'rmdir'\n      err.path = \"#{options.target}\"\n    options.log unless err\n    then message: \"Directory successfully removed\", level: 'INFO', module: 'nikita/lib/fs/write'\n    else message: \"Fail to remove directory\", level: 'ERROR', module: 'nikita/lib/fs/write'\n    throw err",
            "title": "Source Code"
        },
        {
            "location": "/fs/stat.coffee/",
            "text": "nikita.fs.stat(options, callback)\n\n\nOptions include:\n\n\n\n\ndereference\n (boolean) \n\n  Follow links, similar to \nlstat\n, default is \"true\".\n\n\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.stat\", level: 'DEBUG', module: 'nikita/lib/fs/stat'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  options.dereference ?= true\n  dereference = if options.dereference then '-L' else ''\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  @system.execute\n    cmd: \"\"\"\n    [ ! -e #{options.target} ] && exit 3\n    stat #{dereference} -c '%f|%u|%g|%s|%X|%Y' #{options.target}\n    \"\"\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err, status, stdout, stderr) ->\n    if err?.code is 3\n      err = Error \"Missing File: no file exists for target #{JSON.stringify options.target}\"\n      err.code = 'ENOENT'\n      return callback err\n    return callback err if err\n    [rawmodehex, uid, gid, size, atime, mtime] = stdout.trim().split '|'\n    stats = new Stats\n      mode: parseInt '0x' + rawmodehex, 16\n      uid: parseInt uid, 10\n      gid: parseInt gid, 10\n      size: parseInt size, 10\n      atime: parseInt atime, 10 # File Access Time\n      mtime: parseInt mtime, 10 # File Modify Time\n    callback null, stats\n\nStats = (initial) ->\n  @mode = initial && initial.mode\n  @uid = initial && initial.uid\n  @gid = initial && initial.gid\n  @size = initial && initial.size\n  @atime = initial && initial.atime\n  @mtime = initial && initial.mtime\nStats.prototype._checkModeProperty = (property) ->\n  (this.mode & constants.S_IFMT) is property\nStats.prototype.isDirectory = ->\n  @_checkModeProperty constants.S_IFDIR\nStats.prototype.isFile = ->\n  @_checkModeProperty constants.S_IFREG\nStats.prototype.isBlockDevice = ->\n  @_checkModeProperty constants.S_IFBLK\nStats.prototype.isCharacterDevice = ->\n  @_checkModeProperty constants.S_IFCHR\nStats.prototype.isSymbolicLink = ->\n  @_checkModeProperty constants.S_IFLNK\nStats.prototype.isFIFO = ->\n  @_checkModeProperty constants.S_IFIFO\nStats.prototype.isSocket = ->\n  @_checkModeProperty constants.S_IFSOCK\n\n\n\nDependencies\n\n\nconstants = require('fs').constants",
            "title": "Stat.coffee"
        },
        {
            "location": "/fs/stat.coffee/#nikitafsstatoptions-callback",
            "text": "Options include:   dereference  (boolean)  \n  Follow links, similar to  lstat , default is \"true\".",
            "title": "nikita.fs.stat(options, callback)"
        },
        {
            "location": "/fs/stat.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.stat\", level: 'DEBUG', module: 'nikita/lib/fs/stat'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  options.dereference ?= true\n  dereference = if options.dereference then '-L' else ''\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  @system.execute\n    cmd: \"\"\"\n    [ ! -e #{options.target} ] && exit 3\n    stat #{dereference} -c '%f|%u|%g|%s|%X|%Y' #{options.target}\n    \"\"\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err, status, stdout, stderr) ->\n    if err?.code is 3\n      err = Error \"Missing File: no file exists for target #{JSON.stringify options.target}\"\n      err.code = 'ENOENT'\n      return callback err\n    return callback err if err\n    [rawmodehex, uid, gid, size, atime, mtime] = stdout.trim().split '|'\n    stats = new Stats\n      mode: parseInt '0x' + rawmodehex, 16\n      uid: parseInt uid, 10\n      gid: parseInt gid, 10\n      size: parseInt size, 10\n      atime: parseInt atime, 10 # File Access Time\n      mtime: parseInt mtime, 10 # File Modify Time\n    callback null, stats\n\nStats = (initial) ->\n  @mode = initial && initial.mode\n  @uid = initial && initial.uid\n  @gid = initial && initial.gid\n  @size = initial && initial.size\n  @atime = initial && initial.atime\n  @mtime = initial && initial.mtime\nStats.prototype._checkModeProperty = (property) ->\n  (this.mode & constants.S_IFMT) is property\nStats.prototype.isDirectory = ->\n  @_checkModeProperty constants.S_IFDIR\nStats.prototype.isFile = ->\n  @_checkModeProperty constants.S_IFREG\nStats.prototype.isBlockDevice = ->\n  @_checkModeProperty constants.S_IFBLK\nStats.prototype.isCharacterDevice = ->\n  @_checkModeProperty constants.S_IFCHR\nStats.prototype.isSymbolicLink = ->\n  @_checkModeProperty constants.S_IFLNK\nStats.prototype.isFIFO = ->\n  @_checkModeProperty constants.S_IFIFO\nStats.prototype.isSocket = ->\n  @_checkModeProperty constants.S_IFSOCK",
            "title": "Source Code"
        },
        {
            "location": "/fs/stat.coffee/#dependencies",
            "text": "constants = require('fs').constants",
            "title": "Dependencies"
        },
        {
            "location": "/fs/symlink.coffee/",
            "text": "nikita.fs.symlink(options, callback)\n\n\nDelete a name and possibly the file it refers to.\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.symlink\", level: 'DEBUG', module: 'nikita/lib/fs/symlink'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  throw Error \"Required Option: the \\\"source\\\" option is mandatory\" unless options.source\n  @system.execute\n    cmd: \"ln -sf #{options.source} #{options.target}\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err) ->\n   callback err",
            "title": "Symlink.coffee"
        },
        {
            "location": "/fs/symlink.coffee/#nikitafssymlinkoptions-callback",
            "text": "Delete a name and possibly the file it refers to.",
            "title": "nikita.fs.symlink(options, callback)"
        },
        {
            "location": "/fs/symlink.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.symlink\", level: 'DEBUG', module: 'nikita/lib/fs/symlink'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  throw Error \"Required Option: the \\\"source\\\" option is mandatory\" unless options.source\n  @system.execute\n    cmd: \"ln -sf #{options.source} #{options.target}\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err) ->\n   callback err",
            "title": "Source Code"
        },
        {
            "location": "/fs/unlink.coffee/",
            "text": "nikita.fs.unlink(options, callback)\n\n\nDelete a name and possibly the file it refers to.\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.unlink\", level: 'DEBUG', module: 'nikita/lib/fs/unlink'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  @system.execute\n    cmd: \"unlink #{options.target}\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err) ->\n   callback err",
            "title": "Unlink.coffee"
        },
        {
            "location": "/fs/unlink.coffee/#nikitafsunlinkoptions-callback",
            "text": "Delete a name and possibly the file it refers to.",
            "title": "nikita.fs.unlink(options, callback)"
        },
        {
            "location": "/fs/unlink.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options, callback) ->\n  options.log message: \"Entering fs.unlink\", level: 'DEBUG', module: 'nikita/lib/fs/unlink'\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  @system.execute\n    cmd: \"unlink #{options.target}\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n  , (err) ->\n   callback err",
            "title": "Source Code"
        },
        {
            "location": "/fs/writeFile.coffee/",
            "text": "nikita.fs.writeFile(options, callback)\n\n\nOptions include\n\n\n\n\ncontent\n (string|buffer) \n\n  Content to write.\n\n\ntarget\n (string) \n\n  Final destination path.\n\n\ntarget_tmp\n (string) \n\n  Temporary file for upload before moving to final destination path.\n\n\n\n\nSource Code\n\n\nmodule.exports = status: false, handler: (options) ->\n  options.log message: \"Entering fs.writeFile\", level: 'DEBUG', module: 'nikita/lib/fs/writeFile'\n  ssh = @ssh options.ssh\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  throw Error \"Required Option: the \\\"content\\\" option is mandatory\" unless options.content?\n  options.flags ?= 'w' # Note, Node.js docs version 8 & 9 mention \"flag\" and not \"flags\"\n  options.target_tmp ?= \"/tmp/nikita_#{string.hash options.target}\" if options.sudo or options.flags[0] is 'a'\n  options.mode ?= 0o644 # Node.js default to 0o666\n  @call if: options.flags[0] is 'a', ->\n    @system.execute\n      if: options.flags[0] is 'a'\n      cmd: \"\"\"\n      [ ! -f '#{options.target}' ] && exit\n      cp '#{options.target}' '#{options.target_tmp}'\n      \"\"\"\n  , (err, status) ->\n    options.log unless err\n    then message: \"Append prepared by placing original file in temporary path\", level: 'INFO', module: 'nikita/lib/fs/write'\n    else message: \"Failed to place original file in temporary path\", level: 'ERROR', module: 'nikita/lib/fs/writeFile'\n  @call (_, callback) ->\n    options.log message: 'Writting file', level: 'DEBUG', module: 'nikita/lib/fs/writeFile'\n    fs.writeFile ssh, options.target_tmp or options.target, options.content, flags: options.flags, mode: options.mode, (err) ->\n      options.log unless err\n      then message: \"File uploaded at #{JSON.stringify options.target_tmp or options.target}\", level: 'INFO', module: 'nikita/lib/fs/writeFile'\n      else message: \"Fail to upload file at #{JSON.stringify options.target_tmp or options.target}\", level: 'ERROR', module: 'nikita/lib/fs/writeFile'\n      callback err\n  @system.execute\n    if: options.target_tmp\n    cmd: \"\"\"\n    mv '#{options.target_tmp}' '#{options.target}'\n    \"\"\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot\n\n\n\nDependencies\n\n\nfs = require 'ssh2-fs'\nstring = require '../misc/string'",
            "title": "writeFile.coffee"
        },
        {
            "location": "/fs/writeFile.coffee/#nikitafswritefileoptions-callback",
            "text": "Options include   content  (string|buffer)  \n  Content to write.  target  (string)  \n  Final destination path.  target_tmp  (string)  \n  Temporary file for upload before moving to final destination path.",
            "title": "nikita.fs.writeFile(options, callback)"
        },
        {
            "location": "/fs/writeFile.coffee/#source-code",
            "text": "module.exports = status: false, handler: (options) ->\n  options.log message: \"Entering fs.writeFile\", level: 'DEBUG', module: 'nikita/lib/fs/writeFile'\n  ssh = @ssh options.ssh\n  # Normalize options\n  options.target = options.argument if options.argument?\n  throw Error \"Required Option: the \\\"target\\\" option is mandatory\" unless options.target\n  throw Error \"Required Option: the \\\"content\\\" option is mandatory\" unless options.content?\n  options.flags ?= 'w' # Note, Node.js docs version 8 & 9 mention \"flag\" and not \"flags\"\n  options.target_tmp ?= \"/tmp/nikita_#{string.hash options.target}\" if options.sudo or options.flags[0] is 'a'\n  options.mode ?= 0o644 # Node.js default to 0o666\n  @call if: options.flags[0] is 'a', ->\n    @system.execute\n      if: options.flags[0] is 'a'\n      cmd: \"\"\"\n      [ ! -f '#{options.target}' ] && exit\n      cp '#{options.target}' '#{options.target_tmp}'\n      \"\"\"\n  , (err, status) ->\n    options.log unless err\n    then message: \"Append prepared by placing original file in temporary path\", level: 'INFO', module: 'nikita/lib/fs/write'\n    else message: \"Failed to place original file in temporary path\", level: 'ERROR', module: 'nikita/lib/fs/writeFile'\n  @call (_, callback) ->\n    options.log message: 'Writting file', level: 'DEBUG', module: 'nikita/lib/fs/writeFile'\n    fs.writeFile ssh, options.target_tmp or options.target, options.content, flags: options.flags, mode: options.mode, (err) ->\n      options.log unless err\n      then message: \"File uploaded at #{JSON.stringify options.target_tmp or options.target}\", level: 'INFO', module: 'nikita/lib/fs/writeFile'\n      else message: \"Fail to upload file at #{JSON.stringify options.target_tmp or options.target}\", level: 'ERROR', module: 'nikita/lib/fs/writeFile'\n      callback err\n  @system.execute\n    if: options.target_tmp\n    cmd: \"\"\"\n    mv '#{options.target_tmp}' '#{options.target}'\n    \"\"\"\n    sudo: options.sudo\n    bash: options.bash\n    arch_chroot: options.arch_chroot",
            "title": "Source Code"
        },
        {
            "location": "/fs/writeFile.coffee/#dependencies",
            "text": "fs = require 'ssh2-fs'\nstring = require '../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/java/keystore_add.coffee/",
            "text": "nikita.java.keystore_add(options, [callback])\n\n\nAdd certificates, private keys and certificate authorities to java keystores\nand truststores.\n\n\nOptions\n\n\n\n\nname\n (string) \n\n  Name of the certificate, required if a certificate is provided.\n\n\ncaname\n (string) \n\n  Name of the certificate authority (CA), required.\n\n\ncacert\n (string) \n\n  Path to the certificate authority (CA), required.\n\n\nlocal\n (boolean)  \n\n  treat the source file (key, cert or cacert) as a local file present on the \n  host, only apply with remote actions over SSH, default is \"false\".\n\n\nopenssl\n (string) \n\n  Path to OpenSSl command line tool, default to \"openssl\".\n\n\nparent\n (boolean|object) \n\n  Create parent directory with provided options if an object or default \n  system options if \"true\".\n\n\nstorepass\n (string) \n\n  Password to manage the keystore.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n (object|null) \n\n  Error object if any.\n\n\nstatus\n (boolean) \n\n  Indicates if the certificated was inserted.\n\n\n\n\nCA Cert Chains\n\n\nIn case the CA file reference a chain of certificates, each certificate will be\nreferenced by a unique incremented alias, starting at 0. For example if the \nalias value is \"my-alias\", the aliases will be \"my-alias-0\" then \"my-alias-1\"... \n\n\nRelevant Java properties\n\n\n\n\njavax.net.ssl.trustStore\n\n\njavax.net.ssl.trustStorePassword\n\n\njavax.net.ssl.keyStore\n\n\njavax.net.ssl.keyStoreType\n\n\njavax.net.ssl.keyStorePassword\n\n\n\n\nRelevant commands\n\n\n\n\nView the content of a Java KeyStore (JKS) and Java TrustStore: \n\n\nkeytool -list -v -keystore $keystore -storepass $storepass\n \n\n\nkeytool -list -v -keystore $keystore -storepass $storepass -alias $caname\n \n\n  Note, alias is optional and may reference a CA or a certificate\n\n\nView the content of a \".pem\" certificate: \n\n\nopenssl x509 -in cert.pem -text\n \n\n\nkeytool -printcert -file certs.pem\n   \n\n\nChange the password of a keystore: \n\n\nkeytool -storepasswd -keystore my.keystore\n\n\nChange the key's password: \n\n\nkeytool -keypasswd -alias <key_name> -keystore my.keystore\n\n\n\n\nUploading public and private keys into a keystore\n\n\nrequire('nikita').java.keystore_add([{\n  keystore: java_home + '/lib/security/cacerts',\n  storepass: 'changeit',\n  caname: 'my_ca_certificate',\n  cacert: '/tmp/cacert.pem',\n  key: \"/tmp/private_key.pem\",\n  cert: \"/tmp/public_cert.pem\",\n  keypass: 'mypassword',\n  name: 'node_1'\n}, function(err, status){ /* do sth */ });\n\n\n\n\nUploading a certificate authority\n\n\nrequire('nikita').java.keystore_add([{\n  keystore: java_home + '/lib/security/cacerts',\n  storepass: 'changeit',\n  caname: 'my_ca_certificate',\n  cacert: '/tmp/cacert.pem'\n}, function(err, status){ /* do sth */ });\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  throw Error \"Required Option: 'keystore'\" unless options.keystore\n  throw Error \"Required Option: 'storepass'\" unless options.storepass\n  throw Error \"Required Options: 'cacert' or 'cert'\" unless options.cacert or options.cert\n  throw Error \"Required Option: 'key' for certificate\" if options.cert and not options.key\n  throw Error \"Required Option: 'keypass' for certificate\" if options.cert and not options.keypass\n  throw Error \"Required Option: 'name' for certificate\" if options.cert and not options.name\n  # throw Error \"Required option 'caname'\" unless options.caname\n  # throw Error \"Required option 'cacert'\" unless options.cacert\n  options.parent ?= {}\n  options.openssl ?= 'openssl'\n  tmp_location = \"/tmp/nikita/java_keystore_#{Date.now()}\"\n  files =\n    cert: if options.cert? and options.local then  \"#{tmp_location}/#{path.basename options.cert}\" else options.cert\n    cacert: if options.cacert?  and options.local then  \"#{tmp_location}/#{path.basename options.cacert}\" else options.cacert\n    key: if options.key? and options.local then  \"#{tmp_location}/#{path.basename options.key}\" else options.key\n  @system.mkdir\n    target: \"#{tmp_location}\"\n    mode: 0o0700\n    shy: true\n  @file.download\n    if: options.local and options.cacert\n    source: options.cacert\n    target: files.cacert\n    mode: 0o0600\n    shy: true\n  @file.download\n    if: options.local and options.cert\n    source: options.cert\n    target: files.cert\n    mode: 0o0600\n    shy: true\n  @file.download\n    if: options.local and options.key\n    source: options.key\n    target: files.key\n    mode: 0o0600\n    shy: true\n  @system.mkdir options, options.parent,\n    header: null\n    unless_exists: true\n    target: path.dirname options.keystore\n  @system.execute # Deal with key and certificate\n    bash: true\n    cmd: \"\"\"\n    cleanup () {\n      [ -n \"#{if options.cacert then '1' else ''}\" ] || rm -rf #{tmp_location};\n    }\n    if ! which #{options.openssl}; then echo 'OpenSSL command line tool not detected'; cleanup; exit 4; fi\n    [ -f #{files.cert} ] || (cleanup; exit 6)\n    # mkdir -p -m 700 #{tmp_location}\n    user=`#{options.openssl} x509  -noout -in \"#{files.cert}\" -sha1 -fingerprint | sed 's/\\\\(.*\\\\)=\\\\(.*\\\\)/\\\\2/' | cat`\n    # We are only retrieving the first certificate found in the chain with `head -n 1`\n    keystore=`keytool -list -v -keystore #{options.keystore} -storepass #{options.storepass} -alias #{options.name} | grep SHA1: | head -n 1 | sed -E 's/.+SHA1: +(.*)/\\\\1/'`\n    echo \"User Certificate: $user\"\n    echo \"Keystore Certificate: $keystore\"\n    if [[ \"$user\" == \"$keystore\" ]]; then cleanup; exit 5; fi\n    # Create a PKCS12 file that contains key and certificate\n    #{options.openssl} pkcs12 -export \\\n      -in \"#{files.cert}\" -inkey \"#{files.key}\" \\\n      -out \"#{tmp_location}/pkcs12\" -name #{options.name} \\\n      -password pass:#{options.keypass}\n    # Import PKCS12 into keystore\n    keytool -noprompt -importkeystore \\\n      -destkeystore #{options.keystore} \\\n      -deststorepass #{options.storepass} \\\n      -destkeypass #{options.keypass} \\\n      -srckeystore \"#{tmp_location}/pkcs12\" -srcstoretype PKCS12 -srcstorepass #{options.keypass} \\\n      -alias #{options.name}\n    \"\"\"\n    trap: true\n    if: !!options.cert\n    code_skipped: 5 # OpenSSL exit 3 if file does not exists\n  , (err) ->\n    throw Error \"OpenSSL command line tool not detected\" if err?.code is 4\n    throw Error \"Keystore file does not exists\" if err?.code is 6\n  @system.execute # Deal with CACert\n    if: options.cacert\n    bash: true\n    cmd: \"\"\"\n    # cleanup () { rm -rf #{tmp_location}; }\n    cleanup () { echo 'clean'; }\n    # Check password\n    if [ -f #{options.keystore} ] && ! keytool -list -keystore #{options.keystore} -storepass #{options.storepass} >/dev/null; then\n      # Keystore password is invalid, change it manually with:\n      # keytool -storepasswd -keystore #{options.keystore} -storepass ${old_pasword} -new #{options.storepass}\n      cleanup; exit 2\n    fi\n    [ -f #{files.cacert} ] || (echo 'CA file doesnt not exists: #{files.cacert} 1>&2'; cleanup; exit 3)\n    # Import CACert\n    PEM_FILE=#{files.cacert}\n    CERTS=$(grep 'END CERTIFICATE' $PEM_FILE| wc -l)\n    code=5\n    for N in $(seq 0 $(($CERTS - 1))); do\n      if [[ $CERTS == '1' ]]; then\n        ALIAS=\"#{options.caname}\"\n      else\n        ALIAS=\"#{options.caname}-$N\"\n      fi\n      # Isolate cert into a file\n      CACERT_FILE=#{tmp_location}/$ALIAS\n      cat $PEM_FILE | awk \"n==$N { print }; /END CERTIFICATE/ { n++ }\" > $CACERT_FILE\n      # Read user CACert signature\n      user=`#{options.openssl} x509  -noout -in \"$CACERT_FILE\" -sha1 -fingerprint | sed 's/\\\\(.*\\\\)=\\\\(.*\\\\)/\\\\2/'`\n      # Read registered CACert signature\n      keystore=`keytool -list -v -keystore #{options.keystore} -storepass #{options.storepass} -alias $ALIAS | grep SHA1: | sed -E 's/.+SHA1: +(.*)/\\\\1/'`\n      echo \"User CA Cert: $user\"\n      echo \"Keystore CA Cert: $keystore\"\n      if [[ \"$user\" == \"$keystore\" ]]; then echo 'Identical Signature'; code=5; continue; fi\n      # Remove CACert if signature doesnt match\n      if [[ \"$keystore\" != \"\" ]]; then\n        keytool -delete \\\n          -keystore #{options.keystore} \\\n          -storepass #{options.storepass} \\\n          -alias $ALIAS\n      fi\n      keytool -noprompt -import -trustcacerts -keystore #{options.keystore} -storepass #{options.storepass} -alias $ALIAS -file #{tmp_location}/$ALIAS\n      code=0\n    done\n    cleanup\n    exit $code\n    \"\"\"\n    trap: true\n    code_skipped: 5\n  , (err) ->\n    throw Error \"CA file does not exist: #{files.cacert}\" if err?.code is 3\n  @system.chown\n    target: options.keystore\n    uid: options.uid\n    gid: options.gid\n    if: options.uid? or options.gid?\n  @system.chmod\n    target: options.keystore\n    mode: options.mode\n    if: options.mode?\n\n\n\nDependencies\n\n\npath = require('path').posix",
            "title": "Keystore add.coffee"
        },
        {
            "location": "/java/keystore_add.coffee/#nikitajavakeystore_addoptions-callback",
            "text": "Add certificates, private keys and certificate authorities to java keystores\nand truststores.",
            "title": "nikita.java.keystore_add(options, [callback])"
        },
        {
            "location": "/java/keystore_add.coffee/#options",
            "text": "name  (string)  \n  Name of the certificate, required if a certificate is provided.  caname  (string)  \n  Name of the certificate authority (CA), required.  cacert  (string)  \n  Path to the certificate authority (CA), required.  local  (boolean)   \n  treat the source file (key, cert or cacert) as a local file present on the \n  host, only apply with remote actions over SSH, default is \"false\".  openssl  (string)  \n  Path to OpenSSl command line tool, default to \"openssl\".  parent  (boolean|object)  \n  Create parent directory with provided options if an object or default \n  system options if \"true\".  storepass  (string)  \n  Password to manage the keystore.",
            "title": "Options"
        },
        {
            "location": "/java/keystore_add.coffee/#callback-parameters",
            "text": "err  (object|null)  \n  Error object if any.  status  (boolean)  \n  Indicates if the certificated was inserted.",
            "title": "Callback parameters"
        },
        {
            "location": "/java/keystore_add.coffee/#ca-cert-chains",
            "text": "In case the CA file reference a chain of certificates, each certificate will be\nreferenced by a unique incremented alias, starting at 0. For example if the \nalias value is \"my-alias\", the aliases will be \"my-alias-0\" then \"my-alias-1\"...",
            "title": "CA Cert Chains"
        },
        {
            "location": "/java/keystore_add.coffee/#relevant-java-properties",
            "text": "javax.net.ssl.trustStore  javax.net.ssl.trustStorePassword  javax.net.ssl.keyStore  javax.net.ssl.keyStoreType  javax.net.ssl.keyStorePassword",
            "title": "Relevant Java properties"
        },
        {
            "location": "/java/keystore_add.coffee/#relevant-commands",
            "text": "View the content of a Java KeyStore (JKS) and Java TrustStore:   keytool -list -v -keystore $keystore -storepass $storepass    keytool -list -v -keystore $keystore -storepass $storepass -alias $caname   \n  Note, alias is optional and may reference a CA or a certificate  View the content of a \".pem\" certificate:   openssl x509 -in cert.pem -text    keytool -printcert -file certs.pem      Change the password of a keystore:   keytool -storepasswd -keystore my.keystore  Change the key's password:   keytool -keypasswd -alias <key_name> -keystore my.keystore",
            "title": "Relevant commands"
        },
        {
            "location": "/java/keystore_add.coffee/#uploading-public-and-private-keys-into-a-keystore",
            "text": "require('nikita').java.keystore_add([{\n  keystore: java_home + '/lib/security/cacerts',\n  storepass: 'changeit',\n  caname: 'my_ca_certificate',\n  cacert: '/tmp/cacert.pem',\n  key: \"/tmp/private_key.pem\",\n  cert: \"/tmp/public_cert.pem\",\n  keypass: 'mypassword',\n  name: 'node_1'\n}, function(err, status){ /* do sth */ });",
            "title": "Uploading public and private keys into a keystore"
        },
        {
            "location": "/java/keystore_add.coffee/#uploading-a-certificate-authority",
            "text": "require('nikita').java.keystore_add([{\n  keystore: java_home + '/lib/security/cacerts',\n  storepass: 'changeit',\n  caname: 'my_ca_certificate',\n  cacert: '/tmp/cacert.pem'\n}, function(err, status){ /* do sth */ });",
            "title": "Uploading a certificate authority"
        },
        {
            "location": "/java/keystore_add.coffee/#source-code",
            "text": "module.exports = (options) ->\n  throw Error \"Required Option: 'keystore'\" unless options.keystore\n  throw Error \"Required Option: 'storepass'\" unless options.storepass\n  throw Error \"Required Options: 'cacert' or 'cert'\" unless options.cacert or options.cert\n  throw Error \"Required Option: 'key' for certificate\" if options.cert and not options.key\n  throw Error \"Required Option: 'keypass' for certificate\" if options.cert and not options.keypass\n  throw Error \"Required Option: 'name' for certificate\" if options.cert and not options.name\n  # throw Error \"Required option 'caname'\" unless options.caname\n  # throw Error \"Required option 'cacert'\" unless options.cacert\n  options.parent ?= {}\n  options.openssl ?= 'openssl'\n  tmp_location = \"/tmp/nikita/java_keystore_#{Date.now()}\"\n  files =\n    cert: if options.cert? and options.local then  \"#{tmp_location}/#{path.basename options.cert}\" else options.cert\n    cacert: if options.cacert?  and options.local then  \"#{tmp_location}/#{path.basename options.cacert}\" else options.cacert\n    key: if options.key? and options.local then  \"#{tmp_location}/#{path.basename options.key}\" else options.key\n  @system.mkdir\n    target: \"#{tmp_location}\"\n    mode: 0o0700\n    shy: true\n  @file.download\n    if: options.local and options.cacert\n    source: options.cacert\n    target: files.cacert\n    mode: 0o0600\n    shy: true\n  @file.download\n    if: options.local and options.cert\n    source: options.cert\n    target: files.cert\n    mode: 0o0600\n    shy: true\n  @file.download\n    if: options.local and options.key\n    source: options.key\n    target: files.key\n    mode: 0o0600\n    shy: true\n  @system.mkdir options, options.parent,\n    header: null\n    unless_exists: true\n    target: path.dirname options.keystore\n  @system.execute # Deal with key and certificate\n    bash: true\n    cmd: \"\"\"\n    cleanup () {\n      [ -n \"#{if options.cacert then '1' else ''}\" ] || rm -rf #{tmp_location};\n    }\n    if ! which #{options.openssl}; then echo 'OpenSSL command line tool not detected'; cleanup; exit 4; fi\n    [ -f #{files.cert} ] || (cleanup; exit 6)\n    # mkdir -p -m 700 #{tmp_location}\n    user=`#{options.openssl} x509  -noout -in \"#{files.cert}\" -sha1 -fingerprint | sed 's/\\\\(.*\\\\)=\\\\(.*\\\\)/\\\\2/' | cat`\n    # We are only retrieving the first certificate found in the chain with `head -n 1`\n    keystore=`keytool -list -v -keystore #{options.keystore} -storepass #{options.storepass} -alias #{options.name} | grep SHA1: | head -n 1 | sed -E 's/.+SHA1: +(.*)/\\\\1/'`\n    echo \"User Certificate: $user\"\n    echo \"Keystore Certificate: $keystore\"\n    if [[ \"$user\" == \"$keystore\" ]]; then cleanup; exit 5; fi\n    # Create a PKCS12 file that contains key and certificate\n    #{options.openssl} pkcs12 -export \\\n      -in \"#{files.cert}\" -inkey \"#{files.key}\" \\\n      -out \"#{tmp_location}/pkcs12\" -name #{options.name} \\\n      -password pass:#{options.keypass}\n    # Import PKCS12 into keystore\n    keytool -noprompt -importkeystore \\\n      -destkeystore #{options.keystore} \\\n      -deststorepass #{options.storepass} \\\n      -destkeypass #{options.keypass} \\\n      -srckeystore \"#{tmp_location}/pkcs12\" -srcstoretype PKCS12 -srcstorepass #{options.keypass} \\\n      -alias #{options.name}\n    \"\"\"\n    trap: true\n    if: !!options.cert\n    code_skipped: 5 # OpenSSL exit 3 if file does not exists\n  , (err) ->\n    throw Error \"OpenSSL command line tool not detected\" if err?.code is 4\n    throw Error \"Keystore file does not exists\" if err?.code is 6\n  @system.execute # Deal with CACert\n    if: options.cacert\n    bash: true\n    cmd: \"\"\"\n    # cleanup () { rm -rf #{tmp_location}; }\n    cleanup () { echo 'clean'; }\n    # Check password\n    if [ -f #{options.keystore} ] && ! keytool -list -keystore #{options.keystore} -storepass #{options.storepass} >/dev/null; then\n      # Keystore password is invalid, change it manually with:\n      # keytool -storepasswd -keystore #{options.keystore} -storepass ${old_pasword} -new #{options.storepass}\n      cleanup; exit 2\n    fi\n    [ -f #{files.cacert} ] || (echo 'CA file doesnt not exists: #{files.cacert} 1>&2'; cleanup; exit 3)\n    # Import CACert\n    PEM_FILE=#{files.cacert}\n    CERTS=$(grep 'END CERTIFICATE' $PEM_FILE| wc -l)\n    code=5\n    for N in $(seq 0 $(($CERTS - 1))); do\n      if [[ $CERTS == '1' ]]; then\n        ALIAS=\"#{options.caname}\"\n      else\n        ALIAS=\"#{options.caname}-$N\"\n      fi\n      # Isolate cert into a file\n      CACERT_FILE=#{tmp_location}/$ALIAS\n      cat $PEM_FILE | awk \"n==$N { print }; /END CERTIFICATE/ { n++ }\" > $CACERT_FILE\n      # Read user CACert signature\n      user=`#{options.openssl} x509  -noout -in \"$CACERT_FILE\" -sha1 -fingerprint | sed 's/\\\\(.*\\\\)=\\\\(.*\\\\)/\\\\2/'`\n      # Read registered CACert signature\n      keystore=`keytool -list -v -keystore #{options.keystore} -storepass #{options.storepass} -alias $ALIAS | grep SHA1: | sed -E 's/.+SHA1: +(.*)/\\\\1/'`\n      echo \"User CA Cert: $user\"\n      echo \"Keystore CA Cert: $keystore\"\n      if [[ \"$user\" == \"$keystore\" ]]; then echo 'Identical Signature'; code=5; continue; fi\n      # Remove CACert if signature doesnt match\n      if [[ \"$keystore\" != \"\" ]]; then\n        keytool -delete \\\n          -keystore #{options.keystore} \\\n          -storepass #{options.storepass} \\\n          -alias $ALIAS\n      fi\n      keytool -noprompt -import -trustcacerts -keystore #{options.keystore} -storepass #{options.storepass} -alias $ALIAS -file #{tmp_location}/$ALIAS\n      code=0\n    done\n    cleanup\n    exit $code\n    \"\"\"\n    trap: true\n    code_skipped: 5\n  , (err) ->\n    throw Error \"CA file does not exist: #{files.cacert}\" if err?.code is 3\n  @system.chown\n    target: options.keystore\n    uid: options.uid\n    gid: options.gid\n    if: options.uid? or options.gid?\n  @system.chmod\n    target: options.keystore\n    mode: options.mode\n    if: options.mode?",
            "title": "Source Code"
        },
        {
            "location": "/java/keystore_add.coffee/#dependencies",
            "text": "path = require('path').posix",
            "title": "Dependencies"
        },
        {
            "location": "/java/keystore_remove.coffee/",
            "text": "nikita.java.keystore_remove(options, [callback])\n\n\nRemove certificates, private keys and certificate authorities from java\nkeystores and truststores.\n\n\nOptions\n\n\n\n\nname\n (string|array) \n\n  Alias of the key and the certificate, required if \"caname\" isn't provided.   \n\n\ncaname\n (string|array) \n\n  Alias of the certificate authority (CA), required if \"name\" isn't provided.   \n\n\nkeystore\n (string) \n\n  Path to the keystore (doesn't need to exists).   \n\n\nstorepass\n (string) \n\n  Password to manage the keystore.   \n\n\n\n\nRemoving a key and its certificate\n\n\nrequire('nikita').java.keystore_remove([{\n  keystore: java_home + '/lib/security/cacerts',\n  storepass: 'changeit',\n  caname: 'my_ca_certificate',\n  keypass: 'mypassword',\n  name: 'node_1'\n}, function(err, status){ /* do sth */ });\n\n\n\n\nRemoving a certificate authority\n\n\nrequire('nikita').java.keystore_add([{\n  keystore: java_home + '/lib/security/cacerts',\n  storepass: 'changeit',\n  caname: 'my_ca_certificate'\n}, function(err, status){ /* do sth */ });\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  throw Error \"Required option 'keystore'\" unless options.keystore\n  throw Error \"Required option 'storepass'\" unless options.storepass\n  throw Error \"Required option 'name' or 'caname'\" unless options.name or options.caname\n  options.caname = [options.caname] unless Array.isArray options.caname\n  options.name = [options.name] unless Array.isArray options.name\n  aliases = [options.caname..., options.name...].join(' ').trim()\n  @system.execute\n    bash: true\n    cmd: \"\"\"\n    test -f \"#{options.keystore}\" || # Nothing to do if not a file\n    exit 3\n    count=0\n    for alias in #{aliases}; do\n      if keytool -list -keystore \"#{options.keystore}\" -storepass \"#{options.storepass}\" -alias \"$alias\"; then\n         keytool -delete -keystore \"#{options.keystore}\" -storepass \"#{options.storepass}\" -alias \"$alias\"\n         (( count++ ))\n      fi\n    done\n    [ $count -eq 0 ] && exit 3\n    exit 0\n    \"\"\"\n    code_skipped: 3",
            "title": "Keystore remove.coffee"
        },
        {
            "location": "/java/keystore_remove.coffee/#nikitajavakeystore_removeoptions-callback",
            "text": "Remove certificates, private keys and certificate authorities from java\nkeystores and truststores.",
            "title": "nikita.java.keystore_remove(options, [callback])"
        },
        {
            "location": "/java/keystore_remove.coffee/#options",
            "text": "name  (string|array)  \n  Alias of the key and the certificate, required if \"caname\" isn't provided.     caname  (string|array)  \n  Alias of the certificate authority (CA), required if \"name\" isn't provided.     keystore  (string)  \n  Path to the keystore (doesn't need to exists).     storepass  (string)  \n  Password to manage the keystore.",
            "title": "Options"
        },
        {
            "location": "/java/keystore_remove.coffee/#removing-a-key-and-its-certificate",
            "text": "require('nikita').java.keystore_remove([{\n  keystore: java_home + '/lib/security/cacerts',\n  storepass: 'changeit',\n  caname: 'my_ca_certificate',\n  keypass: 'mypassword',\n  name: 'node_1'\n}, function(err, status){ /* do sth */ });",
            "title": "Removing a key and its certificate"
        },
        {
            "location": "/java/keystore_remove.coffee/#removing-a-certificate-authority",
            "text": "require('nikita').java.keystore_add([{\n  keystore: java_home + '/lib/security/cacerts',\n  storepass: 'changeit',\n  caname: 'my_ca_certificate'\n}, function(err, status){ /* do sth */ });",
            "title": "Removing a certificate authority"
        },
        {
            "location": "/java/keystore_remove.coffee/#source-code",
            "text": "module.exports = (options) ->\n  throw Error \"Required option 'keystore'\" unless options.keystore\n  throw Error \"Required option 'storepass'\" unless options.storepass\n  throw Error \"Required option 'name' or 'caname'\" unless options.name or options.caname\n  options.caname = [options.caname] unless Array.isArray options.caname\n  options.name = [options.name] unless Array.isArray options.name\n  aliases = [options.caname..., options.name...].join(' ').trim()\n  @system.execute\n    bash: true\n    cmd: \"\"\"\n    test -f \"#{options.keystore}\" || # Nothing to do if not a file\n    exit 3\n    count=0\n    for alias in #{aliases}; do\n      if keytool -list -keystore \"#{options.keystore}\" -storepass \"#{options.storepass}\" -alias \"$alias\"; then\n         keytool -delete -keystore \"#{options.keystore}\" -storepass \"#{options.storepass}\" -alias \"$alias\"\n         (( count++ ))\n      fi\n    done\n    [ $count -eq 0 ] && exit 3\n    exit 0\n    \"\"\"\n    code_skipped: 3",
            "title": "Source Code"
        },
        {
            "location": "/krb5/addprinc.coffee/",
            "text": "nikita.krb5.addprinc(options, [callback])\n\n\nCreate a new Kerberos principal with a password or an optional keytab.\n\n\nOptions\n\n\n\n\nkadmin_server\n, \nadmin_server\n \n\n  Address of the kadmin server; optional, use \"kadmin.local\" if missing.   \n\n\nkadmin_principal\n \n\n  KAdmin principal name unless \nkadmin.local\n is used.   \n\n\nkadmin_password\n \n\n  Password associated to the KAdmin principal.   \n\n\nprincipal\n \n\n  Principal to be created.   \n\n\npassword\n \n\n  Password associated to this principal; required if no randkey is\n  provided.   \n\n\npassword_sync\n \n\n  Wether the password should be created if the principal already exists,\n  default to \"false\".   \n\n\nrandkey\n \n\n  Generate a random key; required if no password is provided.   \n\n\nkeytab\n \n\n  Path to the file storing key entries.   \n\n\n\n\nKeytab example\n\n\nrequire('nikita').krb5.addprinc({\n  principal: 'myservice/my.fqdn@MY.REALM',\n  randkey: true,\n  keytab: '/etc/security/keytabs/my.service.keytab',\n  uid: 'myservice',\n  gid: 'myservice',\n  kadmin_principal: 'me/admin@MY_REALM',\n  kadmin_password: 'pass',\n  kadmin_server: 'localhost'\n}, function(err, modified){\n  console.log(err ? err.message : 'Principal created or modified: ' + !!modified);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  return throw Error 'Property principal is required' unless options.principal\n  return throw Error 'Password or randkey missing' if not options.password and not options.randkey\n  # Normalize realm and principal for later usage of options\n  options.realm ?= options.kadmin_principal.split('@')[1] if /.*@.*/.test options.kadmin_principal\n  options.principal = \"#{options.principal}@#{options.realm}\" unless /^\\S+@\\S+$/.test options.principal\n  options.password_sync ?= false\n  options.kadmin_server ?= options.admin_server # Might deprecated kadmin_server in favor of admin_server\n  # Prepare commands\n  cmd_getprinc = misc.kadmin options, \"getprinc #{options.principal}\"\n  cmd_addprinc = misc.kadmin options, if options.password\n  then \"addprinc -pw #{options.password} #{options.principal}\"\n  else \"addprinc -randkey #{options.principal}\"\n  # todo, could be removed once actions acception multiple options arguments\n  # such ash `.krb5.ktadd options, if: options.keytab\n  ktadd_options = {}\n  for k, v of options then ktadd_options[k] = v\n  ktadd_options.if = options.keytab\n  delete ktadd_options.header\n  # Ticket cache location\n  cache_name = \"/tmp/nikita_#{Math.random()}\"\n  @system.execute\n    retry: 3\n    cmd: cmd_addprinc\n    unless_exec: \"#{cmd_getprinc} | grep '#{options.principal}'\"\n  @system.execute\n    retry: 3\n    cmd: misc.kadmin options, \"cpw -pw #{options.password} #{options.principal}\"\n    if: options.password and options.password_sync\n    unless_exec: \"\"\"\n    if ! echo #{options.password} | kinit '#{options.principal}' -c '#{cache_name}'; then exit 1; else kdestroy -c '#{cache_name}'; fi\n    \"\"\"\n  @krb5.ktadd ktadd_options\n\n\n\nDependencies\n\n\nmisc = require '../misc'",
            "title": "Addprinc.coffee"
        },
        {
            "location": "/krb5/addprinc.coffee/#nikitakrb5addprincoptions-callback",
            "text": "Create a new Kerberos principal with a password or an optional keytab.",
            "title": "nikita.krb5.addprinc(options, [callback])"
        },
        {
            "location": "/krb5/addprinc.coffee/#options",
            "text": "kadmin_server ,  admin_server   \n  Address of the kadmin server; optional, use \"kadmin.local\" if missing.     kadmin_principal   \n  KAdmin principal name unless  kadmin.local  is used.     kadmin_password   \n  Password associated to the KAdmin principal.     principal   \n  Principal to be created.     password   \n  Password associated to this principal; required if no randkey is\n  provided.     password_sync   \n  Wether the password should be created if the principal already exists,\n  default to \"false\".     randkey   \n  Generate a random key; required if no password is provided.     keytab   \n  Path to the file storing key entries.",
            "title": "Options"
        },
        {
            "location": "/krb5/addprinc.coffee/#keytab-example",
            "text": "require('nikita').krb5.addprinc({\n  principal: 'myservice/my.fqdn@MY.REALM',\n  randkey: true,\n  keytab: '/etc/security/keytabs/my.service.keytab',\n  uid: 'myservice',\n  gid: 'myservice',\n  kadmin_principal: 'me/admin@MY_REALM',\n  kadmin_password: 'pass',\n  kadmin_server: 'localhost'\n}, function(err, modified){\n  console.log(err ? err.message : 'Principal created or modified: ' + !!modified);\n});",
            "title": "Keytab example"
        },
        {
            "location": "/krb5/addprinc.coffee/#source-code",
            "text": "module.exports = (options) ->\n  return throw Error 'Property principal is required' unless options.principal\n  return throw Error 'Password or randkey missing' if not options.password and not options.randkey\n  # Normalize realm and principal for later usage of options\n  options.realm ?= options.kadmin_principal.split('@')[1] if /.*@.*/.test options.kadmin_principal\n  options.principal = \"#{options.principal}@#{options.realm}\" unless /^\\S+@\\S+$/.test options.principal\n  options.password_sync ?= false\n  options.kadmin_server ?= options.admin_server # Might deprecated kadmin_server in favor of admin_server\n  # Prepare commands\n  cmd_getprinc = misc.kadmin options, \"getprinc #{options.principal}\"\n  cmd_addprinc = misc.kadmin options, if options.password\n  then \"addprinc -pw #{options.password} #{options.principal}\"\n  else \"addprinc -randkey #{options.principal}\"\n  # todo, could be removed once actions acception multiple options arguments\n  # such ash `.krb5.ktadd options, if: options.keytab\n  ktadd_options = {}\n  for k, v of options then ktadd_options[k] = v\n  ktadd_options.if = options.keytab\n  delete ktadd_options.header\n  # Ticket cache location\n  cache_name = \"/tmp/nikita_#{Math.random()}\"\n  @system.execute\n    retry: 3\n    cmd: cmd_addprinc\n    unless_exec: \"#{cmd_getprinc} | grep '#{options.principal}'\"\n  @system.execute\n    retry: 3\n    cmd: misc.kadmin options, \"cpw -pw #{options.password} #{options.principal}\"\n    if: options.password and options.password_sync\n    unless_exec: \"\"\"\n    if ! echo #{options.password} | kinit '#{options.principal}' -c '#{cache_name}'; then exit 1; else kdestroy -c '#{cache_name}'; fi\n    \"\"\"\n  @krb5.ktadd ktadd_options",
            "title": "Source Code"
        },
        {
            "location": "/krb5/addprinc.coffee/#dependencies",
            "text": "misc = require '../misc'",
            "title": "Dependencies"
        },
        {
            "location": "/krb5/delprinc.coffee/",
            "text": "nikita.krb5.delprinc(options, [callback])\n\n\nRemove a Kerberos principal and optionally its keytab.\n\n\nOptions\n\n\n\n\nprincipal\n \n\n  Principal to be created.   \n\n\nkadmin_server\n \n\n  Address of the kadmin server; optional, use \"kadmin.local\" if missing.   \n\n\nkadmin_principal\n \n\n  KAdmin principal name unless \nkadmin.local\n is used.   \n\n\nkadmin_password\n \n\n  Password associated to the KAdmin principal.   \n\n\nkeytab\n \n\n  Path to the file storing key entries.   \n\n\n\n\nExample\n\n\nrequire('nikita').krb5_delrinc({\n  principal: 'myservice/my.fqdn@MY.REALM',\n  keytab: '/etc/security/keytabs/my.service.keytab',\n  kadmin_principal: 'me/admin@MY_REALM',\n  kadmin_password: 'pass',\n  kadmin_server: 'localhost'\n}, function(err, removed){\n  console.log(err ? err.message : 'Principal removed: ' + !!removed);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  return throw Error 'Property principal is required' unless options.principal\n  # Normalize realm and principal for later usage of options\n  options.realm ?= options.kadmin_principal.split('@')[1] if /.*@.*/.test options.kadmin_principal\n  options.principal = \"#{options.principal}@#{options.realm}\" unless /^\\S+@\\S+$/.test options.principal\n  # Prepare commands\n  cmd_getprinc = misc.kadmin options, \"getprinc #{options.principal}\"\n  cmd_delprinc = misc.kadmin options, \"delprinc -force #{options.principal}\"\n  @system.execute\n    cmd: cmd_delprinc\n    if_exec: \"#{cmd_getprinc} | grep '#{options.principal}'\"\n  @system.remove\n    target: options.keytab\n    if: options.keytab\n\n\n\nDependencies\n\n\nmisc = require '../misc'",
            "title": "Delprinc.coffee"
        },
        {
            "location": "/krb5/delprinc.coffee/#nikitakrb5delprincoptions-callback",
            "text": "Remove a Kerberos principal and optionally its keytab.",
            "title": "nikita.krb5.delprinc(options, [callback])"
        },
        {
            "location": "/krb5/delprinc.coffee/#options",
            "text": "principal   \n  Principal to be created.     kadmin_server   \n  Address of the kadmin server; optional, use \"kadmin.local\" if missing.     kadmin_principal   \n  KAdmin principal name unless  kadmin.local  is used.     kadmin_password   \n  Password associated to the KAdmin principal.     keytab   \n  Path to the file storing key entries.",
            "title": "Options"
        },
        {
            "location": "/krb5/delprinc.coffee/#example",
            "text": "require('nikita').krb5_delrinc({\n  principal: 'myservice/my.fqdn@MY.REALM',\n  keytab: '/etc/security/keytabs/my.service.keytab',\n  kadmin_principal: 'me/admin@MY_REALM',\n  kadmin_password: 'pass',\n  kadmin_server: 'localhost'\n}, function(err, removed){\n  console.log(err ? err.message : 'Principal removed: ' + !!removed);\n});",
            "title": "Example"
        },
        {
            "location": "/krb5/delprinc.coffee/#source-code",
            "text": "module.exports = (options) ->\n  return throw Error 'Property principal is required' unless options.principal\n  # Normalize realm and principal for later usage of options\n  options.realm ?= options.kadmin_principal.split('@')[1] if /.*@.*/.test options.kadmin_principal\n  options.principal = \"#{options.principal}@#{options.realm}\" unless /^\\S+@\\S+$/.test options.principal\n  # Prepare commands\n  cmd_getprinc = misc.kadmin options, \"getprinc #{options.principal}\"\n  cmd_delprinc = misc.kadmin options, \"delprinc -force #{options.principal}\"\n  @system.execute\n    cmd: cmd_delprinc\n    if_exec: \"#{cmd_getprinc} | grep '#{options.principal}'\"\n  @system.remove\n    target: options.keytab\n    if: options.keytab",
            "title": "Source Code"
        },
        {
            "location": "/krb5/delprinc.coffee/#dependencies",
            "text": "misc = require '../misc'",
            "title": "Dependencies"
        },
        {
            "location": "/krb5/ktadd.coffee/",
            "text": "nikita.krb5.ktadd(options, [callback])\n\n\nCreate and manage a keytab. This function is usually not used directly but instead\ncalled by the \nkrb5.addprinc\n function.\n\n\nOptions\n\n\n\n\nkadmin_server\n \n\n  Address of the kadmin server; optional, use \"kadmin.local\" if missing.   \n\n\nkadmin_principal\n \n\n  KAdmin principal name unless \nkadmin.local\n is used.   \n\n\nkadmin_password\n \n\n  Password associated to the KAdmin principal.   \n\n\nprincipal\n \n\n  Principal to be created.   \n\n\nkeytab\n \n\n  Path to the file storing key entries.   \n\n\n\n\nExample\n\n\nrequire('nikita').krb5_delrinc({\n  principal: 'myservice/my.fqdn@MY.REALM',\n  keytab: '/etc/security/keytabs/my.service.keytab',\n  kadmin_principal: 'me/admin@MY_REALM',\n  kadmin_password: 'pass',\n  kadmin_server: 'localhost'\n}, function(err, removed){\n  console.log(err ? err.message : 'Principal removed: ' + !!removed);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  throw Error 'Property principal is required' unless options.principal\n  throw Error 'Property keytab is required' unless options.keytab\n  if /^\\S+@\\S+$/.test options.kadmin_principal\n    options.realm ?= options.kadmin_principal.split('@')[1]\n  else\n    throw Error 'Property \"realm\" is required unless present in principal' unless options.realm\n    options.principal = \"#{options.principal}@#{options.realm}\"\n  keytab = {} # keytab[principal] ?= {kvno: null, mdate: null}\n  princ = {} # {kvno: null, mdate: null}\n  # Get keytab information\n  @system.execute\n    cmd: \"export TZ=GMT; klist -kt #{options.keytab}\"\n    code_skipped: 1\n    shy: true\n  , (err, exists, stdout, stderr) ->\n    throw err if err\n    # unless exists\n    #   options.log message: \"Keytab does not yet exists\", level: 'INFO', module: 'nikita/krb5/ktadd'\n    #   return do_ktadd()\n    return unless exists\n    options.log message: \"Keytab exists, check kvno validity\", level: 'DEBUG', module: 'nikita/krb5/ktadd'\n    for line in string.lines stdout\n      continue unless match = /^\\s*(\\d+)\\s+([\\d\\/:]+\\s+[\\d\\/:]+)\\s+(.*)\\s*$/.exec line\n      [_, kvno, mdate, principal] = match\n      kvno = parseInt kvno, 10\n      mdate = Date.parse \"#{mdate} GMT\"\n      # keytab[principal] ?= {kvno: null, mdate: null}\n      if not keytab[principal] or keytab[principal].kvno < kvno\n        keytab[principal] = kvno: kvno, mdate: mdate\n  # Get principal information\n  @system.execute\n    cmd: misc.kadmin options, \"getprinc -terse #{options.principal}\"\n    shy: true\n    if: -> keytab[options.principal]?\n  , (err, executed, stdout, stderr) ->\n    return err if err\n    return unless executed\n    # return do_ktadd() unless -1 is stdout.indexOf 'does not exist'\n    values = string.lines(stdout)[1]\n    # Check if a ticket exists for this\n    throw Error \"Principal does not exist: '#{options.principal}'\" unless values\n    values = values.split '\\t'\n    mdate = parseInt(values[2], 10) * 1000\n    kvno = parseInt values[8], 10\n    princ = mdate: mdate, kvno: kvno\n    options.log message: \"Keytab kvno '#{keytab[options.principal]?.kvno}', principal kvno '#{princ.kvno}'\", level: 'INFO', module: 'nikita/krb5/ktadd'\n    options.log message: \"Keytab mdate '#{new Date keytab[options.principal]?.mdate}', principal mdate '#{new Date princ.mdate}'\", level: 'INFO', module: 'nikita/krb5/ktadd'\n  # Remove principal from keytab\n  @system.execute\n    cmd: misc.kadmin options, \"ktremove -k #{options.keytab} #{options.principal}\"\n    if: ->\n      keytab[options.principal]? and (keytab[options.principal]?.kvno isnt princ.kvno or keytab[options.principal].mdate isnt princ.mdate)\n  # Create keytab and add principal\n  @system.mkdir\n    target: \"#{path.dirname options.keytab}\"\n    if: -> not keytab[options.principal]? or (keytab[options.principal]?.kvno isnt princ.kvno or keytab[options.principal].mdate isnt princ.mdate)\n  @system.execute\n    cmd: misc.kadmin options, \"ktadd -k #{options.keytab} #{options.principal}\"\n    if: -> not keytab[options.principal]? or (keytab[options.principal]?.kvno isnt princ.kvno or keytab[options.principal].mdate isnt princ.mdate)\n  # Keytab ownership and permissions\n  @system.chown\n    target: options.keytab\n    uid: options.uid\n    gid: options.gid\n    if:  options.uid? or options.gid?\n  @system.chmod\n    target: options.keytab\n    mode: options.mode\n    if: options.mode?\n\n\n\nFields in 'getprinc -terse' output\n\n\nprinc-canonical-name\nprinc-exp-time\nlast-pw-change\npw-exp-time\nprinc-max-life\nmodifying-princ-canonical-name\nprinc-mod-date\nprinc-attributes <=== This is the field you want\nprinc-kvno\nprinc-mkvno\nprinc-policy (or 'None')\nprinc-max-renewable-life\nprinc-last-success\nprinc-last-failed\nprinc-fail-auth-count\nprinc-n-key-data\nver\nkvno\ndata-type[0]\ndata-type[1]\n\n\nDependencies\n\n\npath = require 'path'\nmisc = require '../misc'\nstring = require '../misc/string'",
            "title": "Ktadd.coffee"
        },
        {
            "location": "/krb5/ktadd.coffee/#nikitakrb5ktaddoptions-callback",
            "text": "Create and manage a keytab. This function is usually not used directly but instead\ncalled by the  krb5.addprinc  function.",
            "title": "nikita.krb5.ktadd(options, [callback])"
        },
        {
            "location": "/krb5/ktadd.coffee/#options",
            "text": "kadmin_server   \n  Address of the kadmin server; optional, use \"kadmin.local\" if missing.     kadmin_principal   \n  KAdmin principal name unless  kadmin.local  is used.     kadmin_password   \n  Password associated to the KAdmin principal.     principal   \n  Principal to be created.     keytab   \n  Path to the file storing key entries.",
            "title": "Options"
        },
        {
            "location": "/krb5/ktadd.coffee/#example",
            "text": "require('nikita').krb5_delrinc({\n  principal: 'myservice/my.fqdn@MY.REALM',\n  keytab: '/etc/security/keytabs/my.service.keytab',\n  kadmin_principal: 'me/admin@MY_REALM',\n  kadmin_password: 'pass',\n  kadmin_server: 'localhost'\n}, function(err, removed){\n  console.log(err ? err.message : 'Principal removed: ' + !!removed);\n});",
            "title": "Example"
        },
        {
            "location": "/krb5/ktadd.coffee/#source-code",
            "text": "module.exports = (options) ->\n  throw Error 'Property principal is required' unless options.principal\n  throw Error 'Property keytab is required' unless options.keytab\n  if /^\\S+@\\S+$/.test options.kadmin_principal\n    options.realm ?= options.kadmin_principal.split('@')[1]\n  else\n    throw Error 'Property \"realm\" is required unless present in principal' unless options.realm\n    options.principal = \"#{options.principal}@#{options.realm}\"\n  keytab = {} # keytab[principal] ?= {kvno: null, mdate: null}\n  princ = {} # {kvno: null, mdate: null}\n  # Get keytab information\n  @system.execute\n    cmd: \"export TZ=GMT; klist -kt #{options.keytab}\"\n    code_skipped: 1\n    shy: true\n  , (err, exists, stdout, stderr) ->\n    throw err if err\n    # unless exists\n    #   options.log message: \"Keytab does not yet exists\", level: 'INFO', module: 'nikita/krb5/ktadd'\n    #   return do_ktadd()\n    return unless exists\n    options.log message: \"Keytab exists, check kvno validity\", level: 'DEBUG', module: 'nikita/krb5/ktadd'\n    for line in string.lines stdout\n      continue unless match = /^\\s*(\\d+)\\s+([\\d\\/:]+\\s+[\\d\\/:]+)\\s+(.*)\\s*$/.exec line\n      [_, kvno, mdate, principal] = match\n      kvno = parseInt kvno, 10\n      mdate = Date.parse \"#{mdate} GMT\"\n      # keytab[principal] ?= {kvno: null, mdate: null}\n      if not keytab[principal] or keytab[principal].kvno < kvno\n        keytab[principal] = kvno: kvno, mdate: mdate\n  # Get principal information\n  @system.execute\n    cmd: misc.kadmin options, \"getprinc -terse #{options.principal}\"\n    shy: true\n    if: -> keytab[options.principal]?\n  , (err, executed, stdout, stderr) ->\n    return err if err\n    return unless executed\n    # return do_ktadd() unless -1 is stdout.indexOf 'does not exist'\n    values = string.lines(stdout)[1]\n    # Check if a ticket exists for this\n    throw Error \"Principal does not exist: '#{options.principal}'\" unless values\n    values = values.split '\\t'\n    mdate = parseInt(values[2], 10) * 1000\n    kvno = parseInt values[8], 10\n    princ = mdate: mdate, kvno: kvno\n    options.log message: \"Keytab kvno '#{keytab[options.principal]?.kvno}', principal kvno '#{princ.kvno}'\", level: 'INFO', module: 'nikita/krb5/ktadd'\n    options.log message: \"Keytab mdate '#{new Date keytab[options.principal]?.mdate}', principal mdate '#{new Date princ.mdate}'\", level: 'INFO', module: 'nikita/krb5/ktadd'\n  # Remove principal from keytab\n  @system.execute\n    cmd: misc.kadmin options, \"ktremove -k #{options.keytab} #{options.principal}\"\n    if: ->\n      keytab[options.principal]? and (keytab[options.principal]?.kvno isnt princ.kvno or keytab[options.principal].mdate isnt princ.mdate)\n  # Create keytab and add principal\n  @system.mkdir\n    target: \"#{path.dirname options.keytab}\"\n    if: -> not keytab[options.principal]? or (keytab[options.principal]?.kvno isnt princ.kvno or keytab[options.principal].mdate isnt princ.mdate)\n  @system.execute\n    cmd: misc.kadmin options, \"ktadd -k #{options.keytab} #{options.principal}\"\n    if: -> not keytab[options.principal]? or (keytab[options.principal]?.kvno isnt princ.kvno or keytab[options.principal].mdate isnt princ.mdate)\n  # Keytab ownership and permissions\n  @system.chown\n    target: options.keytab\n    uid: options.uid\n    gid: options.gid\n    if:  options.uid? or options.gid?\n  @system.chmod\n    target: options.keytab\n    mode: options.mode\n    if: options.mode?",
            "title": "Source Code"
        },
        {
            "location": "/krb5/ktadd.coffee/#fields-in-getprinc-terse-output",
            "text": "princ-canonical-name\nprinc-exp-time\nlast-pw-change\npw-exp-time\nprinc-max-life\nmodifying-princ-canonical-name\nprinc-mod-date\nprinc-attributes <=== This is the field you want\nprinc-kvno\nprinc-mkvno\nprinc-policy (or 'None')\nprinc-max-renewable-life\nprinc-last-success\nprinc-last-failed\nprinc-fail-auth-count\nprinc-n-key-data\nver\nkvno\ndata-type[0]\ndata-type[1]",
            "title": "Fields in 'getprinc -terse' output"
        },
        {
            "location": "/krb5/ktadd.coffee/#dependencies",
            "text": "path = require 'path'\nmisc = require '../misc'\nstring = require '../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/krb5/ticket.coffee/",
            "text": "nikita.krb5.ticket(options, [callback])\n\n\nRenew the Kerberos ticket of a user principal inside a Unix session.\n\n\nOptions\n\n\n\n\nprincipal\n \n\n  Principal to be created.   \n\n\npassword\n \n\n  Password associated to this principal; required if no randkey is\n  provided.   \n\n\nkeytab\n \n\n  Path to the file storing key entries.   \n\n\ncache_name\n (string)  \n\n  Path to Kerberos cache file.    \n\n\nuid\n \n\n  Unix uid or username of the Unix session   \n\n\n\n\nKeytab example\n\n\nrequire('nikita').krb5.ticket({\n  principal: 'myservice/my.fqdn@MY.REALM',\n  keytab: '/etc/security/keytabs/my.service.keytab',\n}, function(err, status){\n  console.log(err ? err.message : 'Is ticket renewed: ' + !!status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  throw Error \"Incoherent options: expects one of keytab or password\" if not options.keytab and not options.password\n  # SSH connection\n  ssh = @ssh options.ssh\n  @system.uid_gid\n    uid: options.uid\n    gid: options.gid\n    shy: true\n  , (err, status, {uid, gid, default_gid}) ->\n    options.uid = uid\n    options.gid = gid\n  @system.execute\n    cmd: \"\"\"\n    if #{krb5.su options, 'klist -s'}; then exit 3; fi\n    #{krb5.kinit options}\n    \"\"\"\n    code_skipped: 3\n  @system.chown\n    if: options.uid? or options.gid?\n    uid: options.uid\n    gid: options.gid\n    target: options.target\n\n\n\nDependencies\n\n\nkrb5 = require '../misc/krb5'",
            "title": "Ticket.coffee"
        },
        {
            "location": "/krb5/ticket.coffee/#nikitakrb5ticketoptions-callback",
            "text": "Renew the Kerberos ticket of a user principal inside a Unix session.",
            "title": "nikita.krb5.ticket(options, [callback])"
        },
        {
            "location": "/krb5/ticket.coffee/#options",
            "text": "principal   \n  Principal to be created.     password   \n  Password associated to this principal; required if no randkey is\n  provided.     keytab   \n  Path to the file storing key entries.     cache_name  (string)   \n  Path to Kerberos cache file.      uid   \n  Unix uid or username of the Unix session",
            "title": "Options"
        },
        {
            "location": "/krb5/ticket.coffee/#keytab-example",
            "text": "require('nikita').krb5.ticket({\n  principal: 'myservice/my.fqdn@MY.REALM',\n  keytab: '/etc/security/keytabs/my.service.keytab',\n}, function(err, status){\n  console.log(err ? err.message : 'Is ticket renewed: ' + !!status);\n});",
            "title": "Keytab example"
        },
        {
            "location": "/krb5/ticket.coffee/#source-code",
            "text": "module.exports = (options) ->\n  throw Error \"Incoherent options: expects one of keytab or password\" if not options.keytab and not options.password\n  # SSH connection\n  ssh = @ssh options.ssh\n  @system.uid_gid\n    uid: options.uid\n    gid: options.gid\n    shy: true\n  , (err, status, {uid, gid, default_gid}) ->\n    options.uid = uid\n    options.gid = gid\n  @system.execute\n    cmd: \"\"\"\n    if #{krb5.su options, 'klist -s'}; then exit 3; fi\n    #{krb5.kinit options}\n    \"\"\"\n    code_skipped: 3\n  @system.chown\n    if: options.uid? or options.gid?\n    uid: options.uid\n    gid: options.gid\n    target: options.target",
            "title": "Source Code"
        },
        {
            "location": "/krb5/ticket.coffee/#dependencies",
            "text": "krb5 = require '../misc/krb5'",
            "title": "Dependencies"
        },
        {
            "location": "/krb5/ktutil/add.coffee/",
            "text": "nikita.krb5.ktutil(options, [callback])\n\n\nCreate and manage a keytab for an existing principal. It's different than ktadd\nin the way it can manage several principal on one keytab.\n\n\nOptions\n\n\n\n\nkadmin_server\n \n\n  Address of the kadmin server; optional, use \"kadmin.local\" if missing.   \n\n\nkadmin_principal\n \n\n  KAdmin principal name unless \nkadmin.local\n is used.   \n\n\nkadmin_password\n \n\n  Password associated to the KAdmin principal.   \n\n\nprincipal\n \n\n  Principal to be inserted.   \n\n\npassword\n \n\n  Password of the principal.   \n\n\nkeytab\n  \n\n  Path to the file storing key entries.   \n\n\nrealm\n \n\n  The realm the principal belongs to. optional\n\n\nenctypes\n \n\n  the enctypes used by krb5_server. optional\n\n\n\n\nExample\n\n\nrequire('nikita').krb5.ktutil.add({\n  principal: 'myservice/my.fqdn@MY.REALM',\n  keytab: '/etc/security/keytabs/my.service.keytab',\n  password: 'password'\n}, function(err, created){\n  console.log(err ? err.message : 'Keytab created: ' + !!created);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  throw Error 'Property principal is required' unless options.principal\n  throw Error 'Property keytab is required' unless options.keytab\n  throw Error 'Property password is required' unless options.password\n  if /^\\S+@\\S+$/.test options.principal\n    options.realm ?= options.principal.split('@')[1]\n  else\n    throw Error 'Property \"realm\" is required in principal' unless options.realm\n    options.principal = \"#{options.principal}@#{options.realm}\"\n  entries = []\n  princ_entries = []\n  princ = {}\n  options.enctypes ?= ['aes256-cts-hmac-sha1-96','aes128-cts-hmac-sha1-96','des3-cbc-sha1','arcfour-hmac']\n  cmd = null\n  # Get keytab entries\n  @system.execute\n    cmd: \"echo -e 'rkt #{options.keytab}\\nlist -e -t \\n' | ktutil\"\n    code_skipped: 1\n    shy: true\n  , (err, exists, stdout, stderr) ->\n    throw err if err\n    # unless exists\n    #   options.log message: \"Keytab does not yet exists\", level: 'INFO', module: 'nikita/krb5/ktadd'\n    #   return do_ktadd()\n    return unless exists\n    options.log message: \"Principal exist in Keytab, check kvno validity\", level: 'DEBUG', module: 'nikita/krb5/ktutil/add'\n    for line in string.lines stdout\n      continue unless match = /^\\s*(\\d+)\\s*(\\d+)\\s+([\\d\\/:]+\\s+[\\d\\/:]+)\\s+(.*)\\s*\\(([\\w|-]*)\\)\\s*$/.exec line\n      [_, slot, kvno, timestamp, principal, enctype] = match\n      kvno = parseInt kvno, 10\n      entries.push\n        slot: slot\n        kvno: kvno\n        timestamps: timestamp\n        principal: principal.trim()\n        enctype: enctype\n    princ_entries = entries.filter((e) -> \"#{e.principal}\" is \"#{options.principal}\").reverse()\n  # Get principal information and compare to keytab entries kvnos\n  @system.execute\n    cmd: misc.kadmin options, \"getprinc -terse #{options.principal}\"\n    shy: true\n  , (err, executed, stdout, stderr) ->\n    return err if err\n    return unless executed\n    values = string.lines(stdout)[1]\n    # Check if a ticket exists for this\n    throw Error \"Principal does not exist: '#{options.principal}'\" unless values\n    values = values.split '\\t'\n    mdate = parseInt(values[2], 10) * 1000\n    kvno = parseInt values[8], 10\n    princ = mdate: mdate, kvno: kvno\n  # read keytab and check kvno validities\n  @call ->\n    cmd = null\n    tmp_keytab = \"#{options.keytab}.tmp_nikita_#{Date.now()}\"\n    for enctype in options.enctypes\n      entry = if princ_entries.filter( (entry) -> entry.enctype is enctype).length is 1 then entries.filter( (entry) -> entry.enctype is enctype)[0] else null\n      #entries.filter( (entry) -> entry.enctype is enctype).length is 1\n      # add_entry_cmd = \"add_entry -password -p #{options.principal} -k #{princ.kvno} -e #{enctype}\\n#{options.password}\\n\"\n      if entry? and (entry?.kvno isnt princ.kvno)\n        cmd ?= \"echo -e 'rkt #{options.keytab}\\n\"\n        # remove entry if kvno not identical\n        options.log message: \"Remove from Keytab kvno '#{entry.kvno}', principal kvno '#{princ.kvno}'\", level: 'INFO', module: 'nikita/krb5/ktutil/add'\n        cmd += \"delete_entry #{entry?.slot}\\n\"\n    @call\n      if: entries.length > princ_entries.length\n    , ->\n      @system.execute\n        if: -> cmd?\n        cmd: cmd + \"wkt #{tmp_keytab}\\nquit\\n' | ktutil\"\n      @system.move\n        if: -> cmd?\n        source: tmp_keytab\n        target: options.keytab\n    @system.remove\n      if: (entries.length is princ_entries.length) and cmd?\n      target: options.keytab\n  # write entries in keytab\n  @call ->\n    cmd = null\n    for enctype in options.enctypes\n      entry = if princ_entries.filter( (entry) -> entry.enctype is enctype).length is 1 then entries.filter( (entry) -> entry.enctype is enctype)[0] else null\n      if (entry?.kvno isnt princ.kvno) or !entry?\n        cmd ?= \"echo -e '\"\n        cmd += \"add_entry -password -p #{options.principal} -k #{princ.kvno} -e #{enctype}\\n#{options.password}\\n\"\n    @system.execute\n      if: -> cmd?\n      cmd: cmd + \"wkt #{options.keytab}\\n' | ktutil\"\n  # Keytab ownership and permissions\n  @system.chown\n    target: options.keytab\n    uid: options.uid\n    gid: options.gid\n    if:  options.uid? or options.gid?\n  @system.chmod\n    target: options.keytab\n    mode: options.mode\n    if: options.mode?\n\n\n\nFields in 'getprinc -terse' output\n\n\nprinc-canonical-name\nprinc-exp-time\nlast-pw-change\npw-exp-time\nprinc-max-life\nmodifying-princ-canonical-name\nprinc-mod-date\nprinc-attributes <=== This is the field you want\nprinc-kvno\nprinc-mkvno\nprinc-policy (or 'None')\nprinc-max-renewable-life\nprinc-last-success\nprinc-last-failed\nprinc-fail-auth-count\nprinc-n-key-data\nver\nkvno\ndata-type[0]\ndata-type[1]\n\n\nDependencies\n\n\npath = require 'path'\nmisc = require '../../misc'\nstring = require '../../misc/string'",
            "title": "Add.coffee"
        },
        {
            "location": "/krb5/ktutil/add.coffee/#nikitakrb5ktutiloptions-callback",
            "text": "Create and manage a keytab for an existing principal. It's different than ktadd\nin the way it can manage several principal on one keytab.",
            "title": "nikita.krb5.ktutil(options, [callback])"
        },
        {
            "location": "/krb5/ktutil/add.coffee/#options",
            "text": "kadmin_server   \n  Address of the kadmin server; optional, use \"kadmin.local\" if missing.     kadmin_principal   \n  KAdmin principal name unless  kadmin.local  is used.     kadmin_password   \n  Password associated to the KAdmin principal.     principal   \n  Principal to be inserted.     password   \n  Password of the principal.     keytab    \n  Path to the file storing key entries.     realm   \n  The realm the principal belongs to. optional  enctypes   \n  the enctypes used by krb5_server. optional",
            "title": "Options"
        },
        {
            "location": "/krb5/ktutil/add.coffee/#example",
            "text": "require('nikita').krb5.ktutil.add({\n  principal: 'myservice/my.fqdn@MY.REALM',\n  keytab: '/etc/security/keytabs/my.service.keytab',\n  password: 'password'\n}, function(err, created){\n  console.log(err ? err.message : 'Keytab created: ' + !!created);\n});",
            "title": "Example"
        },
        {
            "location": "/krb5/ktutil/add.coffee/#source-code",
            "text": "module.exports = (options) ->\n  throw Error 'Property principal is required' unless options.principal\n  throw Error 'Property keytab is required' unless options.keytab\n  throw Error 'Property password is required' unless options.password\n  if /^\\S+@\\S+$/.test options.principal\n    options.realm ?= options.principal.split('@')[1]\n  else\n    throw Error 'Property \"realm\" is required in principal' unless options.realm\n    options.principal = \"#{options.principal}@#{options.realm}\"\n  entries = []\n  princ_entries = []\n  princ = {}\n  options.enctypes ?= ['aes256-cts-hmac-sha1-96','aes128-cts-hmac-sha1-96','des3-cbc-sha1','arcfour-hmac']\n  cmd = null\n  # Get keytab entries\n  @system.execute\n    cmd: \"echo -e 'rkt #{options.keytab}\\nlist -e -t \\n' | ktutil\"\n    code_skipped: 1\n    shy: true\n  , (err, exists, stdout, stderr) ->\n    throw err if err\n    # unless exists\n    #   options.log message: \"Keytab does not yet exists\", level: 'INFO', module: 'nikita/krb5/ktadd'\n    #   return do_ktadd()\n    return unless exists\n    options.log message: \"Principal exist in Keytab, check kvno validity\", level: 'DEBUG', module: 'nikita/krb5/ktutil/add'\n    for line in string.lines stdout\n      continue unless match = /^\\s*(\\d+)\\s*(\\d+)\\s+([\\d\\/:]+\\s+[\\d\\/:]+)\\s+(.*)\\s*\\(([\\w|-]*)\\)\\s*$/.exec line\n      [_, slot, kvno, timestamp, principal, enctype] = match\n      kvno = parseInt kvno, 10\n      entries.push\n        slot: slot\n        kvno: kvno\n        timestamps: timestamp\n        principal: principal.trim()\n        enctype: enctype\n    princ_entries = entries.filter((e) -> \"#{e.principal}\" is \"#{options.principal}\").reverse()\n  # Get principal information and compare to keytab entries kvnos\n  @system.execute\n    cmd: misc.kadmin options, \"getprinc -terse #{options.principal}\"\n    shy: true\n  , (err, executed, stdout, stderr) ->\n    return err if err\n    return unless executed\n    values = string.lines(stdout)[1]\n    # Check if a ticket exists for this\n    throw Error \"Principal does not exist: '#{options.principal}'\" unless values\n    values = values.split '\\t'\n    mdate = parseInt(values[2], 10) * 1000\n    kvno = parseInt values[8], 10\n    princ = mdate: mdate, kvno: kvno\n  # read keytab and check kvno validities\n  @call ->\n    cmd = null\n    tmp_keytab = \"#{options.keytab}.tmp_nikita_#{Date.now()}\"\n    for enctype in options.enctypes\n      entry = if princ_entries.filter( (entry) -> entry.enctype is enctype).length is 1 then entries.filter( (entry) -> entry.enctype is enctype)[0] else null\n      #entries.filter( (entry) -> entry.enctype is enctype).length is 1\n      # add_entry_cmd = \"add_entry -password -p #{options.principal} -k #{princ.kvno} -e #{enctype}\\n#{options.password}\\n\"\n      if entry? and (entry?.kvno isnt princ.kvno)\n        cmd ?= \"echo -e 'rkt #{options.keytab}\\n\"\n        # remove entry if kvno not identical\n        options.log message: \"Remove from Keytab kvno '#{entry.kvno}', principal kvno '#{princ.kvno}'\", level: 'INFO', module: 'nikita/krb5/ktutil/add'\n        cmd += \"delete_entry #{entry?.slot}\\n\"\n    @call\n      if: entries.length > princ_entries.length\n    , ->\n      @system.execute\n        if: -> cmd?\n        cmd: cmd + \"wkt #{tmp_keytab}\\nquit\\n' | ktutil\"\n      @system.move\n        if: -> cmd?\n        source: tmp_keytab\n        target: options.keytab\n    @system.remove\n      if: (entries.length is princ_entries.length) and cmd?\n      target: options.keytab\n  # write entries in keytab\n  @call ->\n    cmd = null\n    for enctype in options.enctypes\n      entry = if princ_entries.filter( (entry) -> entry.enctype is enctype).length is 1 then entries.filter( (entry) -> entry.enctype is enctype)[0] else null\n      if (entry?.kvno isnt princ.kvno) or !entry?\n        cmd ?= \"echo -e '\"\n        cmd += \"add_entry -password -p #{options.principal} -k #{princ.kvno} -e #{enctype}\\n#{options.password}\\n\"\n    @system.execute\n      if: -> cmd?\n      cmd: cmd + \"wkt #{options.keytab}\\n' | ktutil\"\n  # Keytab ownership and permissions\n  @system.chown\n    target: options.keytab\n    uid: options.uid\n    gid: options.gid\n    if:  options.uid? or options.gid?\n  @system.chmod\n    target: options.keytab\n    mode: options.mode\n    if: options.mode?",
            "title": "Source Code"
        },
        {
            "location": "/krb5/ktutil/add.coffee/#fields-in-getprinc-terse-output",
            "text": "princ-canonical-name\nprinc-exp-time\nlast-pw-change\npw-exp-time\nprinc-max-life\nmodifying-princ-canonical-name\nprinc-mod-date\nprinc-attributes <=== This is the field you want\nprinc-kvno\nprinc-mkvno\nprinc-policy (or 'None')\nprinc-max-renewable-life\nprinc-last-success\nprinc-last-failed\nprinc-fail-auth-count\nprinc-n-key-data\nver\nkvno\ndata-type[0]\ndata-type[1]",
            "title": "Fields in 'getprinc -terse' output"
        },
        {
            "location": "/krb5/ktutil/add.coffee/#dependencies",
            "text": "path = require 'path'\nmisc = require '../../misc'\nstring = require '../../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/ldap/acl.coffee/",
            "text": "nikita.ldap.acl(options, [callback])\n\n\nCreate new \nACLs\n for the OpenLDAP server.\n\n\nOptions\n\n\n\n\nto\n \n\n  What to control access to as a string.   \n\n\nplace_before\n \n\n  Place before another rule defined by \"to\".   \n\n\nby\n \n\n  Who to grant access to and the access to grant as an array\n  (eg: \n{..., by:[\"ssf=64 anonymous auth\"]}\n).   \n\n\nfirst\n   \n\n\nurl\n \n\n  Specify URI referring to the ldap server.   \n\n\nbinddn\n \n\n  Distinguished Name to bind to the LDAP directory.   \n\n\npasswd\n \n\n  Password for simple authentication.   \n\n\nname\n \n\n  Distinguish name storing the \"olcAccess\" property, using the database adress\n  (eg: \"olcDatabase={2}bdb,cn=config\").   \n\n\noverwrite\n \n\n  Overwrite existing \"olcAccess\", default is to merge.   \n\n\nlog\n \n\n  Function called with a log related messages.   \n\n\nacl\n \n\n  In case of multiple acls, regroup \"place_before\", \"to\" and \"by\" as an array.   \n\n\n\n\nExample\n\n\nrequire('nikita').ldap.acl({\n  url: 'ldap://openldap.server/',\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  name: 'olcDatabase={2}bdb,cn=config',\n  acls: [{\n    place_before: 'dn.subtree=\"dc=domain,dc=com\"',\n    to: 'dn.subtree=\"ou=users,dc=domain,dc=com\"',\n    by: [\n      'dn.exact=\"ou=users,dc=domain,dc=com\" write',\n      'dn.base=\"gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth\" read',\n      '* none'\n    ]\n  },{\n    to: 'dn.subtree=\"dc=domain,dc=com\"',\n    by: [\n      'dn.exact=\"ou=kerberos,dc=domain,dc=com\" write'\n    ]\n  }]\n}, function(err, modified){\n  console.log(err ? err.message : 'ACL modified: ' + !!modified);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  # # Auth related options\n  # binddn = if options.binddn then \"-D #{options.binddn}\" else ''\n  # passwd = if options.passwd then \"-w #{options.passwd}\" else ''\n  # options.uri = 'ldapi:///' if options.uri is true\n  # uri = if options.uri then \"-H #{options.uri}\" else '' # URI is obtained from local openldap conf unless provided\n  # Acl related options\n  options.acls ?= [{}]\n  modified = false\n  each(options.acls)\n  .call (acl, callback) =>\n    do_getdn = =>\n      return do_getacls() if options.hdb_dn\n      options.log message: \"Get DN of the HDB to modify\", level: 'DEBUG', module: 'nikita/ldap/acl'\n      @system.execute\n        cmd: \"\"\"\n        ldapsearch -LLL -Y EXTERNAL -H ldapi:/// \\\n          -b cn=config \\\n          \"(olcSuffix= #{options.suffix})\" dn \\\n          2>/dev/null \\\n          | egrep '^dn' \\\n          | sed -e 's/^dn:\\\\s*olcDatabase=\\\\(.*\\\\)$/\\\\1/g'\n        \"\"\"\n      , (err, _, hdb_dn) ->\n        return callback err if err\n        options.hdb_dn = hdb_dn.trim()\n        do_getacls()\n    do_getacls = =>\n      options.log message: \"List all ACL of the directory\", level: 'DEBUG', module: 'nikita/ldap/acl'\n      @system.execute\n        cmd: \"\"\"\n        ldapsearch -LLL -Y EXTERNAL -H ldapi:/// \\\n          -b olcDatabase=#{options.hdb_dn} \\\n          \"(olcAccess=*)\" olcAccess\n        \"\"\"\n      , (err, _, stdout) ->\n        return callback err if err\n        current = null\n        olcAccesses = []\n        for line in string.lines stdout\n          if match = /^olcAccess: (.*)$/.exec line\n            olcAccesses.push current if current? # Push previous rule\n            current = match[1] # Create new rule\n          else if current?\n            if /^ /.test line # Append to existing rule\n              current += line.substr 1\n            else # Close the rule\n              olcAccesses.push current\n              current = null\n        do_diff ldap.acl.parse olcAccesses\n    do_diff = (olcAccesses) ->\n      olcAccess = null\n      # Find match \"to\" property\n      for access, i in olcAccesses\n        if acl.to is access.to\n          olcAccess = misc.object.clone access\n          olcAccess.old = access\n          break\n      if olcAccess # Modify rule or bypass perfect match\n        is_perfect_match = true\n        not_found_acl = []\n        if acl.by.length isnt olcAccess.by.length\n          is_perfect_match = false\n        else\n          for acl_by, i in acl.by\n            is_perfect_match = false if acl_by isnt olcAccess.by[i]\n            found = true\n            for access_by in olcAccess.by\n              found = false if acl_by isnt access_by\n            not_found_acl.push acl_by unless found\n        if is_perfect_match\n          options.log message: \"No modification to apply\", level: 'INFO', module: 'nikita/ldap/acl'\n          return do_end()\n        if not_found_acl.length\n          options.log message: \"Modify access after undefined acl\", level: 'INFO', module: 'nikita/ldap/acl'\n          for access_by in olcAccess.by\n            not_found_acl.push access_by\n          olcAccess.by = not_found_acl\n        else\n          options.log message: \"Modify access after reorder\", level: 'INFO', module: 'nikita/ldap/acl'\n          options.log? 'nikita `ldap.acl`: m'\n          olcAccess.by = acl.by\n      else\n        options.log message: \"Insert a new access\", level: 'INFO', module: 'nikita/ldap/acl'\n        index = olcAccesses.length\n        if acl.first # not tested\n          index = 0\n        if acl.place_before\n          for access, i in olcAccesses\n            index = i if access.to is acl.place_before\n        else if acl.after\n          for access, i in olcAccesses\n            index = i+1 if access.to is options.after\n        olcAccess = index: index, to: acl.to, by: acl.by, add: true\n      do_save olcAccess\n    do_save = (olcAccess) =>\n      old = ldap.acl.stringify olcAccess.old if olcAccess.old\n      olcAccess = ldap.acl.stringify olcAccess\n      if old\n        cmd = \"\"\"\n        ldapadd -Y EXTERNAL -H ldapi:/// <<-EOF\n        dn: olcDatabase=#{options.hdb_dn}\n        changetype: modify\n        delete: olcAccess\n        olcAccess: #{old}\n        -\n        add: olcAccess\n        olcAccess: #{olcAccess}\n        EOF\n        \"\"\"\n      else\n        cmd = \"\"\"\n        ldapadd -Y EXTERNAL -H ldapi:/// <<-EOF\n        dn: olcDatabase=#{options.hdb_dn}\n        changetype: modify\n        add: olcAccess\n        olcAccess: #{olcAccess}\n        EOF\n        \"\"\"\n      @system.execute\n        cmd: cmd\n      , (err, _, hdb_dn) ->\n        return callback err if err\n        modified = true\n        do_end()\n    do_end = ->\n      callback()\n    do_getdn()\n  .next (err) ->\n    callback err, modified\n\n\n\nDependencies\n\n\neach = require 'each'\nmisc = require '../misc'\nldap = require '../misc/ldap'\nstring = require '../misc/string'",
            "title": "Acl.coffee"
        },
        {
            "location": "/ldap/acl.coffee/#nikitaldapacloptions-callback",
            "text": "Create new  ACLs  for the OpenLDAP server.",
            "title": "nikita.ldap.acl(options, [callback])"
        },
        {
            "location": "/ldap/acl.coffee/#options",
            "text": "to   \n  What to control access to as a string.     place_before   \n  Place before another rule defined by \"to\".     by   \n  Who to grant access to and the access to grant as an array\n  (eg:  {..., by:[\"ssf=64 anonymous auth\"]} ).     first      url   \n  Specify URI referring to the ldap server.     binddn   \n  Distinguished Name to bind to the LDAP directory.     passwd   \n  Password for simple authentication.     name   \n  Distinguish name storing the \"olcAccess\" property, using the database adress\n  (eg: \"olcDatabase={2}bdb,cn=config\").     overwrite   \n  Overwrite existing \"olcAccess\", default is to merge.     log   \n  Function called with a log related messages.     acl   \n  In case of multiple acls, regroup \"place_before\", \"to\" and \"by\" as an array.",
            "title": "Options"
        },
        {
            "location": "/ldap/acl.coffee/#example",
            "text": "require('nikita').ldap.acl({\n  url: 'ldap://openldap.server/',\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  name: 'olcDatabase={2}bdb,cn=config',\n  acls: [{\n    place_before: 'dn.subtree=\"dc=domain,dc=com\"',\n    to: 'dn.subtree=\"ou=users,dc=domain,dc=com\"',\n    by: [\n      'dn.exact=\"ou=users,dc=domain,dc=com\" write',\n      'dn.base=\"gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth\" read',\n      '* none'\n    ]\n  },{\n    to: 'dn.subtree=\"dc=domain,dc=com\"',\n    by: [\n      'dn.exact=\"ou=kerberos,dc=domain,dc=com\" write'\n    ]\n  }]\n}, function(err, modified){\n  console.log(err ? err.message : 'ACL modified: ' + !!modified);\n});",
            "title": "Example"
        },
        {
            "location": "/ldap/acl.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  # # Auth related options\n  # binddn = if options.binddn then \"-D #{options.binddn}\" else ''\n  # passwd = if options.passwd then \"-w #{options.passwd}\" else ''\n  # options.uri = 'ldapi:///' if options.uri is true\n  # uri = if options.uri then \"-H #{options.uri}\" else '' # URI is obtained from local openldap conf unless provided\n  # Acl related options\n  options.acls ?= [{}]\n  modified = false\n  each(options.acls)\n  .call (acl, callback) =>\n    do_getdn = =>\n      return do_getacls() if options.hdb_dn\n      options.log message: \"Get DN of the HDB to modify\", level: 'DEBUG', module: 'nikita/ldap/acl'\n      @system.execute\n        cmd: \"\"\"\n        ldapsearch -LLL -Y EXTERNAL -H ldapi:/// \\\n          -b cn=config \\\n          \"(olcSuffix= #{options.suffix})\" dn \\\n          2>/dev/null \\\n          | egrep '^dn' \\\n          | sed -e 's/^dn:\\\\s*olcDatabase=\\\\(.*\\\\)$/\\\\1/g'\n        \"\"\"\n      , (err, _, hdb_dn) ->\n        return callback err if err\n        options.hdb_dn = hdb_dn.trim()\n        do_getacls()\n    do_getacls = =>\n      options.log message: \"List all ACL of the directory\", level: 'DEBUG', module: 'nikita/ldap/acl'\n      @system.execute\n        cmd: \"\"\"\n        ldapsearch -LLL -Y EXTERNAL -H ldapi:/// \\\n          -b olcDatabase=#{options.hdb_dn} \\\n          \"(olcAccess=*)\" olcAccess\n        \"\"\"\n      , (err, _, stdout) ->\n        return callback err if err\n        current = null\n        olcAccesses = []\n        for line in string.lines stdout\n          if match = /^olcAccess: (.*)$/.exec line\n            olcAccesses.push current if current? # Push previous rule\n            current = match[1] # Create new rule\n          else if current?\n            if /^ /.test line # Append to existing rule\n              current += line.substr 1\n            else # Close the rule\n              olcAccesses.push current\n              current = null\n        do_diff ldap.acl.parse olcAccesses\n    do_diff = (olcAccesses) ->\n      olcAccess = null\n      # Find match \"to\" property\n      for access, i in olcAccesses\n        if acl.to is access.to\n          olcAccess = misc.object.clone access\n          olcAccess.old = access\n          break\n      if olcAccess # Modify rule or bypass perfect match\n        is_perfect_match = true\n        not_found_acl = []\n        if acl.by.length isnt olcAccess.by.length\n          is_perfect_match = false\n        else\n          for acl_by, i in acl.by\n            is_perfect_match = false if acl_by isnt olcAccess.by[i]\n            found = true\n            for access_by in olcAccess.by\n              found = false if acl_by isnt access_by\n            not_found_acl.push acl_by unless found\n        if is_perfect_match\n          options.log message: \"No modification to apply\", level: 'INFO', module: 'nikita/ldap/acl'\n          return do_end()\n        if not_found_acl.length\n          options.log message: \"Modify access after undefined acl\", level: 'INFO', module: 'nikita/ldap/acl'\n          for access_by in olcAccess.by\n            not_found_acl.push access_by\n          olcAccess.by = not_found_acl\n        else\n          options.log message: \"Modify access after reorder\", level: 'INFO', module: 'nikita/ldap/acl'\n          options.log? 'nikita `ldap.acl`: m'\n          olcAccess.by = acl.by\n      else\n        options.log message: \"Insert a new access\", level: 'INFO', module: 'nikita/ldap/acl'\n        index = olcAccesses.length\n        if acl.first # not tested\n          index = 0\n        if acl.place_before\n          for access, i in olcAccesses\n            index = i if access.to is acl.place_before\n        else if acl.after\n          for access, i in olcAccesses\n            index = i+1 if access.to is options.after\n        olcAccess = index: index, to: acl.to, by: acl.by, add: true\n      do_save olcAccess\n    do_save = (olcAccess) =>\n      old = ldap.acl.stringify olcAccess.old if olcAccess.old\n      olcAccess = ldap.acl.stringify olcAccess\n      if old\n        cmd = \"\"\"\n        ldapadd -Y EXTERNAL -H ldapi:/// <<-EOF\n        dn: olcDatabase=#{options.hdb_dn}\n        changetype: modify\n        delete: olcAccess\n        olcAccess: #{old}\n        -\n        add: olcAccess\n        olcAccess: #{olcAccess}\n        EOF\n        \"\"\"\n      else\n        cmd = \"\"\"\n        ldapadd -Y EXTERNAL -H ldapi:/// <<-EOF\n        dn: olcDatabase=#{options.hdb_dn}\n        changetype: modify\n        add: olcAccess\n        olcAccess: #{olcAccess}\n        EOF\n        \"\"\"\n      @system.execute\n        cmd: cmd\n      , (err, _, hdb_dn) ->\n        return callback err if err\n        modified = true\n        do_end()\n    do_end = ->\n      callback()\n    do_getdn()\n  .next (err) ->\n    callback err, modified",
            "title": "Source Code"
        },
        {
            "location": "/ldap/acl.coffee/#dependencies",
            "text": "each = require 'each'\nmisc = require '../misc'\nldap = require '../misc/ldap'\nstring = require '../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/ldap/add.coffee/",
            "text": "nikita.ldap.add(options, [callback])\n\n\nInsert or modify an entry inside an OpenLDAP server.   \n\n\nOptions\n\n\n\n\nentry\n (object | array) \n\n  Object to be inserted or modified.   \n\n\nuri\n \n\n  Specify URI referring to the ldap server.   \n\n\nbinddn\n \n\n  Distinguished Name to bind to the LDAP directory.   \n\n\npasswd\n \n\n  Password for simple authentication.   \n\n\nname\n \n\n  Distinguish name storing the \"olcAccess\" property, using the database adress\n  (eg: \"olcDatabase={2}bdb,cn=config\").   \n\n\noverwrite\n \n\n  Overwrite existing \"olcAccess\", default is to merge.   \n\n\n\n\nExample\n\n\nrequire('nikita').ldap.index({\n  url: 'ldap://openldap.server/',\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  entry: {\n    dn: 'cn=group1,ou=groups,dc=company,dc=com'\n    cn: 'group1'\n    objectClass: 'top'\n    objectClass: 'posixGroup'\n    gidNumber: 9601\n  }\n}, function(err, modified){\n  console.log(err ? err.message : 'Entry modified: ' + !!modified);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  # Auth related options\n  binddn = if options.binddn then \"-D #{options.binddn}\" else ''\n  passwd = if options.passwd then \"-w #{options.passwd}\" else ''\n  if options.url\n    console.log \"Nikita: option 'options.url' is deprecated, use 'options.uri'\"\n    options.uri ?= options.url\n  options.uri = 'ldapi:///' if options.uri is true\n  uri = if options.uri then \"-H #{options.uri}\" else '' # URI is obtained from local openldap conf unless provided\n  # Add related options\n  return callback Error \"Nikita `ldap.add`: required property 'entry'\" unless options.entry\n  options.entry = [options.entry] unless Array.isArray options.entry\n  ldif = ''\n  for entry in options.entry\n    return callback Error \"Nikita `ldap.add`: required property 'dn'\" unless entry.dn\n    ldif += '\\n'\n    ldif += \"dn: #{entry.dn}\\n\"\n    [_, k, v] = /^(.*?)=(.+?),.*$/.exec entry.dn\n    ldif += \"#{k}: #{v}\\n\"\n    if entry[k]\n      throw Error \"Inconsistent value: #{entry[k]} is not #{v} for attribute #{k}\" if entry[k] isnt v\n      delete entry[k]\n    for k, v of entry\n      continue if k is 'dn'\n      v = [v] unless Array.isArray v\n      for vv in v\n        ldif += \"#{k}: #{vv}\\n\"\n  modified = false\n  # We keep -c for now because we accept multiple entries. In the future, \n  # we shall detect modification and be more strict.\n  # -c  Continuous operation mode.  Errors are reported, but ldapmodify will\n  # continue with modifications.  The default is to exit after reporting an\n  # error.\n  @system.execute\n    cmd: \"\"\"\n    ldapadd -c #{binddn} #{passwd} #{uri} \\\n    <<-EOF\n    #{ldif}\n    EOF\n    \"\"\"\n    code_skipped: 68\n  , (err, executed, stdout, stderr) ->\n    return callback err if err\n    modified = stderr.match(/Already exists/g)?.length isnt stdout.match(/adding new entry/g).length\n    added = modified # For now, we dont modify\n    callback err, modified, added",
            "title": "Add.coffee"
        },
        {
            "location": "/ldap/add.coffee/#nikitaldapaddoptions-callback",
            "text": "Insert or modify an entry inside an OpenLDAP server.",
            "title": "nikita.ldap.add(options, [callback])"
        },
        {
            "location": "/ldap/add.coffee/#options",
            "text": "entry  (object | array)  \n  Object to be inserted or modified.     uri   \n  Specify URI referring to the ldap server.     binddn   \n  Distinguished Name to bind to the LDAP directory.     passwd   \n  Password for simple authentication.     name   \n  Distinguish name storing the \"olcAccess\" property, using the database adress\n  (eg: \"olcDatabase={2}bdb,cn=config\").     overwrite   \n  Overwrite existing \"olcAccess\", default is to merge.",
            "title": "Options"
        },
        {
            "location": "/ldap/add.coffee/#example",
            "text": "require('nikita').ldap.index({\n  url: 'ldap://openldap.server/',\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  entry: {\n    dn: 'cn=group1,ou=groups,dc=company,dc=com'\n    cn: 'group1'\n    objectClass: 'top'\n    objectClass: 'posixGroup'\n    gidNumber: 9601\n  }\n}, function(err, modified){\n  console.log(err ? err.message : 'Entry modified: ' + !!modified);\n});",
            "title": "Example"
        },
        {
            "location": "/ldap/add.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  # Auth related options\n  binddn = if options.binddn then \"-D #{options.binddn}\" else ''\n  passwd = if options.passwd then \"-w #{options.passwd}\" else ''\n  if options.url\n    console.log \"Nikita: option 'options.url' is deprecated, use 'options.uri'\"\n    options.uri ?= options.url\n  options.uri = 'ldapi:///' if options.uri is true\n  uri = if options.uri then \"-H #{options.uri}\" else '' # URI is obtained from local openldap conf unless provided\n  # Add related options\n  return callback Error \"Nikita `ldap.add`: required property 'entry'\" unless options.entry\n  options.entry = [options.entry] unless Array.isArray options.entry\n  ldif = ''\n  for entry in options.entry\n    return callback Error \"Nikita `ldap.add`: required property 'dn'\" unless entry.dn\n    ldif += '\\n'\n    ldif += \"dn: #{entry.dn}\\n\"\n    [_, k, v] = /^(.*?)=(.+?),.*$/.exec entry.dn\n    ldif += \"#{k}: #{v}\\n\"\n    if entry[k]\n      throw Error \"Inconsistent value: #{entry[k]} is not #{v} for attribute #{k}\" if entry[k] isnt v\n      delete entry[k]\n    for k, v of entry\n      continue if k is 'dn'\n      v = [v] unless Array.isArray v\n      for vv in v\n        ldif += \"#{k}: #{vv}\\n\"\n  modified = false\n  # We keep -c for now because we accept multiple entries. In the future, \n  # we shall detect modification and be more strict.\n  # -c  Continuous operation mode.  Errors are reported, but ldapmodify will\n  # continue with modifications.  The default is to exit after reporting an\n  # error.\n  @system.execute\n    cmd: \"\"\"\n    ldapadd -c #{binddn} #{passwd} #{uri} \\\n    <<-EOF\n    #{ldif}\n    EOF\n    \"\"\"\n    code_skipped: 68\n  , (err, executed, stdout, stderr) ->\n    return callback err if err\n    modified = stderr.match(/Already exists/g)?.length isnt stdout.match(/adding new entry/g).length\n    added = modified # For now, we dont modify\n    callback err, modified, added",
            "title": "Source Code"
        },
        {
            "location": "/ldap/delete.coffee/",
            "text": "nikita.ldap.delete(options, [callback])\n\n\nInsert or modify an entry inside an OpenLDAP server.   \n\n\nOptions\n\n\n\n\ndn\n (string | array) \n\n  One or multiple DN to remove.   \n\n\nuri\n \n\n  Specify URI referring to the ldap server.   \n\n\nbinddn\n \n\n  Distinguished Name to bind to the LDAP directory.   \n\n\npasswd\n \n\n  Password for simple authentication.   \n\n\nname\n \n\n  Distinguish name storing the \"olcAccess\" property, using the database adress\n  (eg: \"olcDatabase={2}bdb,cn=config\").   \n\n\noverwrite\n \n\n  Overwrite existing \"olcAccess\", default is to merge.   \n\n\n\n\nExample\n\n\nrequire('nikita').ldap.delete({\n  url: 'ldap://openldap.server/',\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  dn: 'cn=group1,ou=groups,dc=company,dc=com'\n}, function(err, deleted){\n  console.log(err ? err.message : 'Entry deleted: ' + deleted);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  # Auth related options\n  binddn = if options.binddn then \"-D #{options.binddn}\" else ''\n  passwd = if options.passwd then \"-w #{options.passwd}\" else ''\n  if options.url\n    console.log \"Nikita: option 'options.url' is deprecated, use 'options.uri'\"\n    options.uri ?= options.url\n  options.uri = 'ldapi:///' if options.uri is true\n  uri = if options.uri then \"-H #{options.uri}\" else '' # URI is obtained from local openldap conf unless provided\n  # Add related options\n  return callback Error \"Nikita `ldap.delete`: required property 'dn'\" unless options.dn\n  options.dn = [options.dn] unless Array.isArray options.dn\n  dn = options.dn.map( (dn) -> \"'#{dn}'\").join(' ')\n  # ldapdelete -D cn=Manager,dc=ryba -w test -H ldaps://master3.ryba:636 'cn=nikita,ou=users,dc=ryba' \n  @system.execute\n    cmd: \"ldapdelete #{binddn} #{passwd} #{uri} #{dn}\"\n    # code_skipped: 68\n  , (err, executed, stdout, stderr) ->\n    return callback err if err\n    callback err, executed\n    # modified = stderr.match(/Already exists/g)?.length isnt stdout.match(/adding new entry/g).length\n    # added = modified # For now, we dont modify\n    # callback err, modified, added",
            "title": "Delete.coffee"
        },
        {
            "location": "/ldap/delete.coffee/#nikitaldapdeleteoptions-callback",
            "text": "Insert or modify an entry inside an OpenLDAP server.",
            "title": "nikita.ldap.delete(options, [callback])"
        },
        {
            "location": "/ldap/delete.coffee/#options",
            "text": "dn  (string | array)  \n  One or multiple DN to remove.     uri   \n  Specify URI referring to the ldap server.     binddn   \n  Distinguished Name to bind to the LDAP directory.     passwd   \n  Password for simple authentication.     name   \n  Distinguish name storing the \"olcAccess\" property, using the database adress\n  (eg: \"olcDatabase={2}bdb,cn=config\").     overwrite   \n  Overwrite existing \"olcAccess\", default is to merge.",
            "title": "Options"
        },
        {
            "location": "/ldap/delete.coffee/#example",
            "text": "require('nikita').ldap.delete({\n  url: 'ldap://openldap.server/',\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  dn: 'cn=group1,ou=groups,dc=company,dc=com'\n}, function(err, deleted){\n  console.log(err ? err.message : 'Entry deleted: ' + deleted);\n});",
            "title": "Example"
        },
        {
            "location": "/ldap/delete.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  # Auth related options\n  binddn = if options.binddn then \"-D #{options.binddn}\" else ''\n  passwd = if options.passwd then \"-w #{options.passwd}\" else ''\n  if options.url\n    console.log \"Nikita: option 'options.url' is deprecated, use 'options.uri'\"\n    options.uri ?= options.url\n  options.uri = 'ldapi:///' if options.uri is true\n  uri = if options.uri then \"-H #{options.uri}\" else '' # URI is obtained from local openldap conf unless provided\n  # Add related options\n  return callback Error \"Nikita `ldap.delete`: required property 'dn'\" unless options.dn\n  options.dn = [options.dn] unless Array.isArray options.dn\n  dn = options.dn.map( (dn) -> \"'#{dn}'\").join(' ')\n  # ldapdelete -D cn=Manager,dc=ryba -w test -H ldaps://master3.ryba:636 'cn=nikita,ou=users,dc=ryba' \n  @system.execute\n    cmd: \"ldapdelete #{binddn} #{passwd} #{uri} #{dn}\"\n    # code_skipped: 68\n  , (err, executed, stdout, stderr) ->\n    return callback err if err\n    callback err, executed\n    # modified = stderr.match(/Already exists/g)?.length isnt stdout.match(/adding new entry/g).length\n    # added = modified # For now, we dont modify\n    # callback err, modified, added",
            "title": "Source Code"
        },
        {
            "location": "/ldap/index.coffee/",
            "text": "nikita.ldap.index(options, [callback])\n\n\nCreate new \nindex\n for the OpenLDAP server.\n\n\nOptions\n\n\n\n\nindexes\n \n\n  Object with keys mapping to indexed attributes and values mapping to indices\n  (\"pres\", \"approx\", \"eq\", \"sub\" and 'special').   \n\n\nurl\n \n\n  Specify URI referring to the ldap server.   \n\n\nbinddn\n \n\n  Distinguished Name to bind to the LDAP directory.   \n\n\npasswd\n \n\n  Password for simple authentication.   \n\n\nname\n \n\n  Distinguish name storing the \"olcAccess\" property, using the database adress\n  (eg: \"olcDatabase={2}bdb,cn=config\").   \n\n\noverwrite\n \n\n  Overwrite existing \"olcAccess\", default is to merge.   \n\n\n\n\nExample\n\n\nrequire('nikita').ldap.index({\n  url: 'ldap://openldap.server/',\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  name: 'olcDatabase={2}bdb,cn=config',\n  indexes: {\n    krbPrincipalName: 'sub,eq'\n  }\n}, function(err, modified){\n  console.log(err ? err.message : 'Index modified: ' + !!modified);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  modified = false\n  indexes = {}\n  add = {}\n  modify = {}\n  @call unless: options.hdb_dn, ->\n    options.log message: \"Get DN of the HDB to modify\", level: 'DEBUG', module: 'nikita/ldap/index'\n    @system.execute\n      shy: true\n      cmd: \"\"\"\n      ldapsearch -LLL -Y EXTERNAL -H ldapi:/// \\\n        -b cn=config \\\n        \"(olcSuffix= #{options.suffix})\" dn \\\n        2>/dev/null \\\n        | egrep '^dn' \\\n        | sed -e 's/^dn:\\\\s*olcDatabase=\\\\(.*\\\\)$/\\\\1/g'\n      \"\"\"\n      shy: true\n    , (err, _, hdb_dn) ->\n      throw err if err\n      options.log message: \"HDB is #{hdb_dn.trim()}\", level: 'INFO', module: 'nikita/ldap/index'\n      options.hdb_dn = hdb_dn.trim()\n  @call ->\n    options.log message: \"List all indexes of the directory\", level: 'DEBUG', module: 'nikita/ldap/index'\n    @system.execute\n      shy: true\n      cmd: \"\"\"\n      ldapsearch -LLL -Y EXTERNAL -H ldapi:/// \\\n        -b olcDatabase=#{options.hdb_dn} \\\n        \"(olcDbIndex=*)\" olcDbIndex\n      \"\"\"\n    , (err, _, stdout) ->\n      throw err if err\n      for line in string.lines stdout\n        continue unless match = /^olcDbIndex:\\s+(.*)\\s+(.*)/.exec line\n        [_, attrlist, indices] = match\n        indexes[attrlist] = indices\n  @call (_, callback) ->\n    for k, v of options.indexes\n      if not indexes[k]?\n        add[k] = v\n      else if v != indexes[k]\n        modify[k] = [v, indexes[k]]\n    callback null, Object.keys(add).length or Object.keys(modify).length\n  @call if: (-> @status -1), ->\n    cmd = []\n    for k, v of add\n      cmd.push \"\"\"\n      add: olcDbIndex\n      olcDbIndex: #{k} #{v}\n      \"\"\"\n    for k, v of modify\n      cmd.push \"\"\"\n      delete: olcDbIndex\n      olcDbIndex: #{k} #{v[1]}\n      -\n      add: olcDbIndex\n      olcDbIndex: #{k} #{v[0]}\n      \"\"\"\n    @system.execute\n      cmd: \"\"\"\n      ldapmodify -Y EXTERNAL -H ldapi:/// <<-EOF\n      dn: olcDatabase=#{options.hdb_dn}\n      changetype: modify\n      #{cmd.join '\\n-\\n'}\n      EOF\n      \"\"\"\n\n\n\nDependencies\n\n\nmisc = require '../misc'\nstring = require '../misc/string'",
            "title": "Index.coffee"
        },
        {
            "location": "/ldap/index.coffee/#nikitaldapindexoptions-callback",
            "text": "Create new  index  for the OpenLDAP server.",
            "title": "nikita.ldap.index(options, [callback])"
        },
        {
            "location": "/ldap/index.coffee/#options",
            "text": "indexes   \n  Object with keys mapping to indexed attributes and values mapping to indices\n  (\"pres\", \"approx\", \"eq\", \"sub\" and 'special').     url   \n  Specify URI referring to the ldap server.     binddn   \n  Distinguished Name to bind to the LDAP directory.     passwd   \n  Password for simple authentication.     name   \n  Distinguish name storing the \"olcAccess\" property, using the database adress\n  (eg: \"olcDatabase={2}bdb,cn=config\").     overwrite   \n  Overwrite existing \"olcAccess\", default is to merge.",
            "title": "Options"
        },
        {
            "location": "/ldap/index.coffee/#example",
            "text": "require('nikita').ldap.index({\n  url: 'ldap://openldap.server/',\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  name: 'olcDatabase={2}bdb,cn=config',\n  indexes: {\n    krbPrincipalName: 'sub,eq'\n  }\n}, function(err, modified){\n  console.log(err ? err.message : 'Index modified: ' + !!modified);\n});",
            "title": "Example"
        },
        {
            "location": "/ldap/index.coffee/#source-code",
            "text": "module.exports = (options) ->\n  modified = false\n  indexes = {}\n  add = {}\n  modify = {}\n  @call unless: options.hdb_dn, ->\n    options.log message: \"Get DN of the HDB to modify\", level: 'DEBUG', module: 'nikita/ldap/index'\n    @system.execute\n      shy: true\n      cmd: \"\"\"\n      ldapsearch -LLL -Y EXTERNAL -H ldapi:/// \\\n        -b cn=config \\\n        \"(olcSuffix= #{options.suffix})\" dn \\\n        2>/dev/null \\\n        | egrep '^dn' \\\n        | sed -e 's/^dn:\\\\s*olcDatabase=\\\\(.*\\\\)$/\\\\1/g'\n      \"\"\"\n      shy: true\n    , (err, _, hdb_dn) ->\n      throw err if err\n      options.log message: \"HDB is #{hdb_dn.trim()}\", level: 'INFO', module: 'nikita/ldap/index'\n      options.hdb_dn = hdb_dn.trim()\n  @call ->\n    options.log message: \"List all indexes of the directory\", level: 'DEBUG', module: 'nikita/ldap/index'\n    @system.execute\n      shy: true\n      cmd: \"\"\"\n      ldapsearch -LLL -Y EXTERNAL -H ldapi:/// \\\n        -b olcDatabase=#{options.hdb_dn} \\\n        \"(olcDbIndex=*)\" olcDbIndex\n      \"\"\"\n    , (err, _, stdout) ->\n      throw err if err\n      for line in string.lines stdout\n        continue unless match = /^olcDbIndex:\\s+(.*)\\s+(.*)/.exec line\n        [_, attrlist, indices] = match\n        indexes[attrlist] = indices\n  @call (_, callback) ->\n    for k, v of options.indexes\n      if not indexes[k]?\n        add[k] = v\n      else if v != indexes[k]\n        modify[k] = [v, indexes[k]]\n    callback null, Object.keys(add).length or Object.keys(modify).length\n  @call if: (-> @status -1), ->\n    cmd = []\n    for k, v of add\n      cmd.push \"\"\"\n      add: olcDbIndex\n      olcDbIndex: #{k} #{v}\n      \"\"\"\n    for k, v of modify\n      cmd.push \"\"\"\n      delete: olcDbIndex\n      olcDbIndex: #{k} #{v[1]}\n      -\n      add: olcDbIndex\n      olcDbIndex: #{k} #{v[0]}\n      \"\"\"\n    @system.execute\n      cmd: \"\"\"\n      ldapmodify -Y EXTERNAL -H ldapi:/// <<-EOF\n      dn: olcDatabase=#{options.hdb_dn}\n      changetype: modify\n      #{cmd.join '\\n-\\n'}\n      EOF\n      \"\"\"",
            "title": "Source Code"
        },
        {
            "location": "/ldap/index.coffee/#dependencies",
            "text": "misc = require '../misc'\nstring = require '../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/ldap/schema.coffee/",
            "text": "nikita.ldap.schema(options, [callback])\n\n\nRegister a new ldap schema.\n\n\nOptions\n\n\n\n\nbinddn\n \n\n  Distinguished Name to bind to the LDAP directory.   \n\n\npasswd\n \n\n  Password for simple authentication.   \n\n\nuri\n \n\n  LDAP Uniform Resource Identifier(s), \"ldapi:///\" if true, default to false\n  in which case it will use your openldap client environment configuration.   \n\n\nname\n \n\n  Common name of the schema.   \n\n\nschema\n \n\n  Path to the schema definition.   \n\n\noverwrite\n \n\n  Overwrite existing \"olcAccess\", default is to merge.   \n\n\nlog\n \n\n  Function called with a log related messages.   \n\n\nssh\n (object|ssh2) \n\n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.   \n\n\nstdout\n (stream.Writable) \n\n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.   \n\n\nstderr\n (stream.Writable) \n\n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.   \n\n\n\n\nExample\n\n\nrequire('nikita').ldap.schema({\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  name: 'kerberos',\n  schema: '/usr/share/doc/krb5-server-ldap-1.10.3/kerberos.schema'\n}, function(err, modified){\n  console.log(err ? err.message : 'Index modified: ' + !!modified);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering ldap.schema\", level: 'DEBUG', module: 'nikita/lib/ldap/schema'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Auth related options\n  binddn = if options.binddn then \"-D #{options.binddn}\" else ''\n  passwd = if options.passwd then \"-w #{options.passwd}\" else ''\n  if options.url\n    console.log \"Nikita: option 'options.url' is deprecated, use 'options.uri'\"\n    options.uri ?= options.url\n  options.uri = 'ldapi:///' if options.uri is true\n  uri = if options.uri then \"-H #{options.uri}\" else '' # URI is obtained from local openldap conf unless provided\n  # Schema related options\n  throw Error \"Missing name\" unless options.name\n  throw Error \"Missing schema\" unless options.schema\n  options.schema = options.schema.trim()\n  tempdir = options.tempdir or \"/tmp/nikita_ldap.schema_#{Date.now()}\"\n  schema = \"#{tempdir}/#{options.name}.schema\"\n  conf = \"#{tempdir}/schema.conf\"\n  ldif = \"#{tempdir}/ldif\"\n  @system.execute\n    # shy: true\n    cmd: \"\"\"\n    ldapsearch -LLL #{binddn} #{passwd} #{uri} -b \\\"cn=schema,cn=config\\\" \\\n    | grep -E cn=\\\\{[0-9]+\\\\}#{options.name},cn=schema,cn=config\n    \"\"\"\n    code: 1\n    code_skipped: 0\n  @call if: (-> @status -1), ->\n    @system.mkdir\n      target: ldif\n      ssh: ssh\n    , (err) ->\n      options.log 'Directory ldif created'\n    @system.copy\n      source: options.schema\n      target: schema\n      ssh: ssh\n    , (err) ->\n      options.log 'Schema copied'\n    @file\n      content: \"include #{schema}\"\n      target: conf\n      ssh: ssh\n      log: options.log\n    , (err) ->\n      options.log 'Configuration generated'\n    @system.execute\n      cmd: \"slaptest -f #{conf} -F #{ldif}\"\n    , (err) ->\n      options.log 'Configuration validated' unless err\n    @system.move\n      source: \"#{ldif}/cn=config/cn=schema/cn={0}#{options.name}.ldif\"\n      target: \"#{ldif}/cn=config/cn=schema/cn=#{options.name}.ldif\"\n      force: true\n    , (err, status) ->\n      throw Error 'No generated schema' unless status\n      options.log 'Configuration renamed'\n    @file\n      target: \"#{ldif}/cn=config/cn=schema/cn=#{options.name}.ldif\"\n      write: [\n        match: /^dn: cn.*$/mg\n        replace: \"dn: cn=#{options.name},cn=schema,cn=config\"\n      ,\n        match: /^cn: {\\d+}(.*)$/mg\n        replace: 'cn: $1'\n      ,\n        match: /^structuralObjectClass.*/mg\n        replace: ''\n      ,\n        match: /^entryUUID.*/mg\n        replace: ''\n      ,\n        match: /^creatorsName.*/mg\n        replace: ''\n      ,\n        match: /^createTimestamp.*/mg\n        replace: ''\n      ,\n        match: /^entryCSN.*/mg\n        replace: ''\n      ,\n        match: /^modifiersName.*/mg\n        replace: ''\n      ,\n        match: /^modifyTimestamp.*/mg\n        replace: ''\n      ]\n    , (err) ->\n      options.log \"File ldif ready\" unless err\n    @system.execute\n      cmd: \"ldapadd #{uri} #{binddn} #{passwd} -f #{ldif}/cn=config/cn=schema/cn=#{options.name}.ldif\"\n    , (err) ->\n      throw err if err\n      options.log \"Schema added: #{options.name}\"\n  @system.remove\n    if: -> @status -1\n    target: tempdir",
            "title": "Schema.coffee"
        },
        {
            "location": "/ldap/schema.coffee/#nikitaldapschemaoptions-callback",
            "text": "Register a new ldap schema.",
            "title": "nikita.ldap.schema(options, [callback])"
        },
        {
            "location": "/ldap/schema.coffee/#options",
            "text": "binddn   \n  Distinguished Name to bind to the LDAP directory.     passwd   \n  Password for simple authentication.     uri   \n  LDAP Uniform Resource Identifier(s), \"ldapi:///\" if true, default to false\n  in which case it will use your openldap client environment configuration.     name   \n  Common name of the schema.     schema   \n  Path to the schema definition.     overwrite   \n  Overwrite existing \"olcAccess\", default is to merge.     log   \n  Function called with a log related messages.     ssh  (object|ssh2)  \n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.     stdout  (stream.Writable)  \n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.     stderr  (stream.Writable)  \n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.",
            "title": "Options"
        },
        {
            "location": "/ldap/schema.coffee/#example",
            "text": "require('nikita').ldap.schema({\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  name: 'kerberos',\n  schema: '/usr/share/doc/krb5-server-ldap-1.10.3/kerberos.schema'\n}, function(err, modified){\n  console.log(err ? err.message : 'Index modified: ' + !!modified);\n});",
            "title": "Example"
        },
        {
            "location": "/ldap/schema.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering ldap.schema\", level: 'DEBUG', module: 'nikita/lib/ldap/schema'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Auth related options\n  binddn = if options.binddn then \"-D #{options.binddn}\" else ''\n  passwd = if options.passwd then \"-w #{options.passwd}\" else ''\n  if options.url\n    console.log \"Nikita: option 'options.url' is deprecated, use 'options.uri'\"\n    options.uri ?= options.url\n  options.uri = 'ldapi:///' if options.uri is true\n  uri = if options.uri then \"-H #{options.uri}\" else '' # URI is obtained from local openldap conf unless provided\n  # Schema related options\n  throw Error \"Missing name\" unless options.name\n  throw Error \"Missing schema\" unless options.schema\n  options.schema = options.schema.trim()\n  tempdir = options.tempdir or \"/tmp/nikita_ldap.schema_#{Date.now()}\"\n  schema = \"#{tempdir}/#{options.name}.schema\"\n  conf = \"#{tempdir}/schema.conf\"\n  ldif = \"#{tempdir}/ldif\"\n  @system.execute\n    # shy: true\n    cmd: \"\"\"\n    ldapsearch -LLL #{binddn} #{passwd} #{uri} -b \\\"cn=schema,cn=config\\\" \\\n    | grep -E cn=\\\\{[0-9]+\\\\}#{options.name},cn=schema,cn=config\n    \"\"\"\n    code: 1\n    code_skipped: 0\n  @call if: (-> @status -1), ->\n    @system.mkdir\n      target: ldif\n      ssh: ssh\n    , (err) ->\n      options.log 'Directory ldif created'\n    @system.copy\n      source: options.schema\n      target: schema\n      ssh: ssh\n    , (err) ->\n      options.log 'Schema copied'\n    @file\n      content: \"include #{schema}\"\n      target: conf\n      ssh: ssh\n      log: options.log\n    , (err) ->\n      options.log 'Configuration generated'\n    @system.execute\n      cmd: \"slaptest -f #{conf} -F #{ldif}\"\n    , (err) ->\n      options.log 'Configuration validated' unless err\n    @system.move\n      source: \"#{ldif}/cn=config/cn=schema/cn={0}#{options.name}.ldif\"\n      target: \"#{ldif}/cn=config/cn=schema/cn=#{options.name}.ldif\"\n      force: true\n    , (err, status) ->\n      throw Error 'No generated schema' unless status\n      options.log 'Configuration renamed'\n    @file\n      target: \"#{ldif}/cn=config/cn=schema/cn=#{options.name}.ldif\"\n      write: [\n        match: /^dn: cn.*$/mg\n        replace: \"dn: cn=#{options.name},cn=schema,cn=config\"\n      ,\n        match: /^cn: {\\d+}(.*)$/mg\n        replace: 'cn: $1'\n      ,\n        match: /^structuralObjectClass.*/mg\n        replace: ''\n      ,\n        match: /^entryUUID.*/mg\n        replace: ''\n      ,\n        match: /^creatorsName.*/mg\n        replace: ''\n      ,\n        match: /^createTimestamp.*/mg\n        replace: ''\n      ,\n        match: /^entryCSN.*/mg\n        replace: ''\n      ,\n        match: /^modifiersName.*/mg\n        replace: ''\n      ,\n        match: /^modifyTimestamp.*/mg\n        replace: ''\n      ]\n    , (err) ->\n      options.log \"File ldif ready\" unless err\n    @system.execute\n      cmd: \"ldapadd #{uri} #{binddn} #{passwd} -f #{ldif}/cn=config/cn=schema/cn=#{options.name}.ldif\"\n    , (err) ->\n      throw err if err\n      options.log \"Schema added: #{options.name}\"\n  @system.remove\n    if: -> @status -1\n    target: tempdir",
            "title": "Source Code"
        },
        {
            "location": "/ldap/user.coffee/",
            "text": "nikita.ldap.user(options, [callback])\n\n\nCreate and modify a user store inside an OpenLDAP server.   \n\n\nOptions\n\n\n\n\nbinddn\n \n\n  Distinguished Name to bind to the LDAP directory.   \n\n\npasswd\n \n\n  Password for simple authentication.   \n\n\nname\n \n\n  Distinguish name storing the \"olcAccess\" property, using the database adress\n  (eg: \"olcDatabase={2}bdb,cn=config\").   \n\n\noverwrite\n \n\n  Overwrite existing \"olcAccess\", default is to merge.   \n\n\nuri\n \n\n  Specify URI referring to the ldap server.   \n\n\nuser\n \n\n  User object.   \n\n\n\n\nExample\n\n\nrequire('nikita').ldap.user({\n  url: 'ldap://openldap.server/',\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  user: {\n  }\n}, function(err, modified){\n  console.log(err ? err.message : 'Index modified: ' + !!modified);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  # Auth related options\n  binddn = if options.binddn then \"-D #{options.binddn}\" else ''\n  passwd = if options.passwd then \"-w #{options.passwd}\" else ''\n  if options.url\n    console.log \"Nikita: option 'options.url' is deprecated, use 'options.uri'\"\n    options.uri ?= options.url\n  options.uri = 'ldapi:///' if options.uri is true\n  uri = if options.uri then \"-H #{options.uri}\" else '' # URI is obtained from local openldap conf unless provided\n  # User related options\n  return callback Error \"Nikita `ldap.user`: required property 'user'\" unless options.user\n  options.user = [options.user] unless Array.isArray options.user\n  modified = false\n  each(options.user)\n  .call (user, callback) =>\n    do_user = =>\n      entry = {}\n      for k, v of user\n        continue if k is 'userPassword' and not /^\\{SASL\\}/.test user.userPassword\n        entry[k] = v\n      @ldap.add\n        entry: entry\n        uri: options.uri\n        binddn: options.binddn\n        passwd: options.passwd\n      , (err, updated, added) ->\n        return callback err if err\n        if added then options.log message: \"User added\", level: 'WARN', module: 'nikita/ldap/user'\n        else if updated then options.log message: \"User updated\", level: 'WARN', module: 'nikita/ldap/user'\n        modified = true if updated or added\n        if added\n        then do_ldappass()\n        else do_checkpass()\n    do_checkpass = =>\n      return do_end() unless user.userPassword or /^\\{SASL\\}/.test user.userPassword\n      @system.execute\n        # See https://onemoretech.wordpress.com/2011/09/22/verifying-ldap-passwords/\n        cmd: \"\"\"\n        ldapsearch -D #{user.dn} -w #{user.userPassword} #{uri} -b \"\" -s base \"objectclass=*\"\n        \"\"\"\n        code_skipped: 49\n      , (err, identical, stdout) ->\n        return callback err if err\n        if identical then do_end() else do_ldappass()\n    do_ldappass = =>\n      return do_end() unless user.userPassword or /^\\{SASL\\}/.test user.userPassword\n      @system.execute\n        cmd: \"\"\"\n        ldappasswd #{binddn} #{passwd} #{uri} \\\n          -s #{user.userPassword} \\\n          '#{user.dn}'\n        \"\"\"\n      , (err) ->\n        return callback err if err\n        options.log message: \"Password modified\", level: 'WARN', module: 'nikita/ldap/user'\n        modified = true\n        do_end()\n    do_end = ->\n      callback()\n    do_user()\n  .next (err) ->\n    callback err, modified\n\n\n\nNote\n\n\nA user can modify it's own password with the \"ldappasswd\" command if ACL allows\nit. Here's an example:\n\n\nldappasswd -D cn=myself,ou=users,dc=ryba -w oldpassword \\\n  -H ldaps://master3.ryba:636 \\\n  -s newpassword 'cn=myself,ou=users,dc=ryba'\n\n\n\n\nDependencies\n\n\neach = require 'each'",
            "title": "User.coffee"
        },
        {
            "location": "/ldap/user.coffee/#nikitaldapuseroptions-callback",
            "text": "Create and modify a user store inside an OpenLDAP server.",
            "title": "nikita.ldap.user(options, [callback])"
        },
        {
            "location": "/ldap/user.coffee/#options",
            "text": "binddn   \n  Distinguished Name to bind to the LDAP directory.     passwd   \n  Password for simple authentication.     name   \n  Distinguish name storing the \"olcAccess\" property, using the database adress\n  (eg: \"olcDatabase={2}bdb,cn=config\").     overwrite   \n  Overwrite existing \"olcAccess\", default is to merge.     uri   \n  Specify URI referring to the ldap server.     user   \n  User object.",
            "title": "Options"
        },
        {
            "location": "/ldap/user.coffee/#example",
            "text": "require('nikita').ldap.user({\n  url: 'ldap://openldap.server/',\n  binddn: 'cn=admin,cn=config',\n  passwd: 'password',\n  user: {\n  }\n}, function(err, modified){\n  console.log(err ? err.message : 'Index modified: ' + !!modified);\n});",
            "title": "Example"
        },
        {
            "location": "/ldap/user.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  # Auth related options\n  binddn = if options.binddn then \"-D #{options.binddn}\" else ''\n  passwd = if options.passwd then \"-w #{options.passwd}\" else ''\n  if options.url\n    console.log \"Nikita: option 'options.url' is deprecated, use 'options.uri'\"\n    options.uri ?= options.url\n  options.uri = 'ldapi:///' if options.uri is true\n  uri = if options.uri then \"-H #{options.uri}\" else '' # URI is obtained from local openldap conf unless provided\n  # User related options\n  return callback Error \"Nikita `ldap.user`: required property 'user'\" unless options.user\n  options.user = [options.user] unless Array.isArray options.user\n  modified = false\n  each(options.user)\n  .call (user, callback) =>\n    do_user = =>\n      entry = {}\n      for k, v of user\n        continue if k is 'userPassword' and not /^\\{SASL\\}/.test user.userPassword\n        entry[k] = v\n      @ldap.add\n        entry: entry\n        uri: options.uri\n        binddn: options.binddn\n        passwd: options.passwd\n      , (err, updated, added) ->\n        return callback err if err\n        if added then options.log message: \"User added\", level: 'WARN', module: 'nikita/ldap/user'\n        else if updated then options.log message: \"User updated\", level: 'WARN', module: 'nikita/ldap/user'\n        modified = true if updated or added\n        if added\n        then do_ldappass()\n        else do_checkpass()\n    do_checkpass = =>\n      return do_end() unless user.userPassword or /^\\{SASL\\}/.test user.userPassword\n      @system.execute\n        # See https://onemoretech.wordpress.com/2011/09/22/verifying-ldap-passwords/\n        cmd: \"\"\"\n        ldapsearch -D #{user.dn} -w #{user.userPassword} #{uri} -b \"\" -s base \"objectclass=*\"\n        \"\"\"\n        code_skipped: 49\n      , (err, identical, stdout) ->\n        return callback err if err\n        if identical then do_end() else do_ldappass()\n    do_ldappass = =>\n      return do_end() unless user.userPassword or /^\\{SASL\\}/.test user.userPassword\n      @system.execute\n        cmd: \"\"\"\n        ldappasswd #{binddn} #{passwd} #{uri} \\\n          -s #{user.userPassword} \\\n          '#{user.dn}'\n        \"\"\"\n      , (err) ->\n        return callback err if err\n        options.log message: \"Password modified\", level: 'WARN', module: 'nikita/ldap/user'\n        modified = true\n        do_end()\n    do_end = ->\n      callback()\n    do_user()\n  .next (err) ->\n    callback err, modified",
            "title": "Source Code"
        },
        {
            "location": "/ldap/user.coffee/#note",
            "text": "A user can modify it's own password with the \"ldappasswd\" command if ACL allows\nit. Here's an example:  ldappasswd -D cn=myself,ou=users,dc=ryba -w oldpassword \\\n  -H ldaps://master3.ryba:636 \\\n  -s newpassword 'cn=myself,ou=users,dc=ryba'",
            "title": "Note"
        },
        {
            "location": "/ldap/user.coffee/#dependencies",
            "text": "each = require 'each'",
            "title": "Dependencies"
        },
        {
            "location": "/log/cli.coffee/",
            "text": "nikita.log.cli(options, [callback])\n\n\nWrite log to the host filesystem in a user provided format.\n\n\nOptions\n\n\n\n\ndepth\n (number|boolean)    \n\n\ndivider\n (string)    \n\n\nend\n (boolean)    \n\n\nenabled\n (boolean)    \n\n\nhost\n (string)    \n\n\npad\n (string)    \n\n\ntime\n (boolean)  \n\n  Print time.   \n\n\nseparator\n (string|object)    \n\n\nstream\n (stream.Writable)  \n\n\n\n\nGlobal options can be alternatively set with the \"log_cli\" property.\n\n\nExemple with the depth option\n\n\nrequire('nikita')(\n  log: { cli: { colors: true } }\n)\n.log.cli({ depth: 2 })\n.call({\n  header: 'Print my header'\n}, function(){\n  @call({\n    header: 'Print sub header'\n  }, function(){\n    @call({\n      header: 'Header not printed'\n    }, function(){\n      // do sth\n    });\n  });\n});\n\n\n\n\nExemple with global options\n\n\nrequire('nikita')(\n  log_cli: { colors: true }\n)\n.log.cli()\n.call({\n  header: 'Print my header'\n}, function(){\n  // do sth\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = ssh: false, handler: (options) ->\n  options.log message: \"Entering log.cli\", level: 'DEBUG', module: 'nikita/lib/log/cli'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Obtains options from \"log_cli\" namespace\n  options.log_cli ?= {}\n  options[k] = v for k, v of options.log_cli\n  # Normalize\n  options.enabled ?= options.argument if options.argument?\n  options.enabled ?= true\n  options.stream ?= process.stdout\n  options.end ?= false\n  options.divider ?= ' : '\n  options.depth ?= false\n  options.pad ?= {}\n  options.time ?= true\n  options.separator = host: options.separator, header: options.separator if typeof options.separator is 'string'\n  options.separator ?= {}\n  options.separator.host ?= unless options.pad.host? then '   ' else ' '\n  options.separator.header ?= unless options.pad.header? then '   ' else ' '\n  options.separator.time ?= unless options.pad.time? then '  ' else ' '\n  options.host ?= if ssh then ssh.config.host else 'localhost'\n  options.colors ?= process.stdout.isTTY\n  options.colors = {\n    # host: colors.cyan.dim\n    # header: colors.cyan.dim\n    # final_status_error: colors.red\n    # final_status_success: colors.blue\n    # final_host_error: colors.red\n    # final_host_success: colors.blue\n    status_true: colors.green\n    status_false: colors.cyan.dim\n    status_error: colors.red\n    # time: colors.cyan.dim\n  } if options.colors is true\n  # Events\n  ids = {}\n  @call options, stream, serializer:\n    'diff': null\n    'end': ->\n      \"FINISH\\n\"\n    'error': (err) ->\n      \"ERROR\"\n    'header': (log) ->\n      return unless options.enabled\n      return if options.depth and options.depth < log.headers.length\n      ids[log.index] = log\n      null\n    \"lifecycle\": (log) ->\n      return unless ids[log.index]\n      ids[log.index].disabled = true if log.message in ['conditions_failed', 'disabled_true']\n      null\n    \"handled\": (log) ->\n      status = if log.error then '\u2718' else if log.status and not log.shy then '\u2714' else '-'\n      color = false\n      if options.colors\n        color = if log.error then options.colors.status_error\n        else if log.status then options.colors.status_true\n        else options.colors.status_false\n      log = ids[log.index]\n      return null unless log\n      return null if log.disabled\n      delete ids[log.index]\n      time = if options.time then string.print_time Date.now() - log.time else ''\n      host = options.host\n      host_separator = options.separator.host\n      header = log.headers.join(options.divider)\n      header_separator = options.separator.header\n      time_separator = if options.time then options.separator.time else ''\n      # Padding\n      host = pad host, options.pad.host if options.pad.host\n      header = pad header, options.pad.header if options.pad.header\n      time = pad time, options.pad.time if options.pad.time\n      line = \"#{host}#{host_separator}#{header}#{header_separator}#{status}#{time_separator}#{time}\\n\"\n      return if color then color line else line\n    'stdin': null\n    'stderr': null\n    'stdout': null\n    'text': null\n\n\n\nDependencies\n\n\ncolors = require 'colors/safe'\npad = require 'pad'\nstream = require './stream'\nstring = require '../misc/string'",
            "title": "Cli.coffee"
        },
        {
            "location": "/log/cli.coffee/#nikitalogclioptions-callback",
            "text": "Write log to the host filesystem in a user provided format.",
            "title": "nikita.log.cli(options, [callback])"
        },
        {
            "location": "/log/cli.coffee/#options",
            "text": "depth  (number|boolean)      divider  (string)      end  (boolean)      enabled  (boolean)      host  (string)      pad  (string)      time  (boolean)   \n  Print time.     separator  (string|object)      stream  (stream.Writable)     Global options can be alternatively set with the \"log_cli\" property.",
            "title": "Options"
        },
        {
            "location": "/log/cli.coffee/#exemple-with-the-depth-option",
            "text": "require('nikita')(\n  log: { cli: { colors: true } }\n)\n.log.cli({ depth: 2 })\n.call({\n  header: 'Print my header'\n}, function(){\n  @call({\n    header: 'Print sub header'\n  }, function(){\n    @call({\n      header: 'Header not printed'\n    }, function(){\n      // do sth\n    });\n  });\n});",
            "title": "Exemple with the depth option"
        },
        {
            "location": "/log/cli.coffee/#exemple-with-global-options",
            "text": "require('nikita')(\n  log_cli: { colors: true }\n)\n.log.cli()\n.call({\n  header: 'Print my header'\n}, function(){\n  // do sth\n});",
            "title": "Exemple with global options"
        },
        {
            "location": "/log/cli.coffee/#source-code",
            "text": "module.exports = ssh: false, handler: (options) ->\n  options.log message: \"Entering log.cli\", level: 'DEBUG', module: 'nikita/lib/log/cli'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Obtains options from \"log_cli\" namespace\n  options.log_cli ?= {}\n  options[k] = v for k, v of options.log_cli\n  # Normalize\n  options.enabled ?= options.argument if options.argument?\n  options.enabled ?= true\n  options.stream ?= process.stdout\n  options.end ?= false\n  options.divider ?= ' : '\n  options.depth ?= false\n  options.pad ?= {}\n  options.time ?= true\n  options.separator = host: options.separator, header: options.separator if typeof options.separator is 'string'\n  options.separator ?= {}\n  options.separator.host ?= unless options.pad.host? then '   ' else ' '\n  options.separator.header ?= unless options.pad.header? then '   ' else ' '\n  options.separator.time ?= unless options.pad.time? then '  ' else ' '\n  options.host ?= if ssh then ssh.config.host else 'localhost'\n  options.colors ?= process.stdout.isTTY\n  options.colors = {\n    # host: colors.cyan.dim\n    # header: colors.cyan.dim\n    # final_status_error: colors.red\n    # final_status_success: colors.blue\n    # final_host_error: colors.red\n    # final_host_success: colors.blue\n    status_true: colors.green\n    status_false: colors.cyan.dim\n    status_error: colors.red\n    # time: colors.cyan.dim\n  } if options.colors is true\n  # Events\n  ids = {}\n  @call options, stream, serializer:\n    'diff': null\n    'end': ->\n      \"FINISH\\n\"\n    'error': (err) ->\n      \"ERROR\"\n    'header': (log) ->\n      return unless options.enabled\n      return if options.depth and options.depth < log.headers.length\n      ids[log.index] = log\n      null\n    \"lifecycle\": (log) ->\n      return unless ids[log.index]\n      ids[log.index].disabled = true if log.message in ['conditions_failed', 'disabled_true']\n      null\n    \"handled\": (log) ->\n      status = if log.error then '\u2718' else if log.status and not log.shy then '\u2714' else '-'\n      color = false\n      if options.colors\n        color = if log.error then options.colors.status_error\n        else if log.status then options.colors.status_true\n        else options.colors.status_false\n      log = ids[log.index]\n      return null unless log\n      return null if log.disabled\n      delete ids[log.index]\n      time = if options.time then string.print_time Date.now() - log.time else ''\n      host = options.host\n      host_separator = options.separator.host\n      header = log.headers.join(options.divider)\n      header_separator = options.separator.header\n      time_separator = if options.time then options.separator.time else ''\n      # Padding\n      host = pad host, options.pad.host if options.pad.host\n      header = pad header, options.pad.header if options.pad.header\n      time = pad time, options.pad.time if options.pad.time\n      line = \"#{host}#{host_separator}#{header}#{header_separator}#{status}#{time_separator}#{time}\\n\"\n      return if color then color line else line\n    'stdin': null\n    'stderr': null\n    'stdout': null\n    'text': null",
            "title": "Source Code"
        },
        {
            "location": "/log/cli.coffee/#dependencies",
            "text": "colors = require 'colors/safe'\npad = require 'pad'\nstream = require './stream'\nstring = require '../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/log/csv.coffee/",
            "text": "nikita.log.csv(options, [callback])\n\n\nWrite log to the host filesystem in CSV.\n\n\nOptions\n\n\n\n\narchive\n (boolean) \n\n  Save a copy of the previous logs inside a dedicated directory, default is\n  \"false\".   \n\n\nbasedir\n (string)  \n\n  Directory where to store logs relative to the process working directory.\n  Default to the \"log\" directory. Note, if the \"archive\" option is activated\n  log file will be stored accessible from \"./log/latest\".   \n\n\nfilename\n (string) \n\n  Name of the log file, contextually rendered with all options passed to\n  the mustache templating engine. Default to \"{{shortname}}.log\", where \n  \"shortname\" is the ssh host or localhost.   \n\n\n\n\nGlobal options can be alternatively set with the \"log_csv\" property.\n\n\nSource Code\n\n\nmodule.exports = ssh: false, handler: (options) ->\n  # Obtains options from \"log_csv\" namespace\n  options.log_csv ?= {}\n  options[k] = v for k, v of options.log_csv\n  stdouting = 0\n  @call options, log_fs, serializer:\n    'diff': (log) ->\n      \"#{log.type},#{log.level},#{JSON.stringify log.message},\\n\"\n    'end': ->\n      \"lifecycle,INFO,Finished with success,\\n\"\n    'error': (err) ->\n      content = []\n      content.push \"lifecycle,ERROR,Finished with error,\\n\"\n      print = (err) ->\n        content.push \"lifecycle,ERROR,#{err.stack or err.message},\\n\"\n      unless err.errors\n      then print err\n      else if err.errors then for error in err.errors then print error\n      content.join()\n    'header': (log) ->\n      \"#{log.type},,,#{log.header}\\n\"\n    'stdin': (log) ->\n      \"#{log.type},#{log.level},#{JSON.stringify log.message}\\n\"\n    'stderr': (log) ->\n      \"#{log.type},#{log.level},#{JSON.stringify log.message}\\n\"\n    'stdout': (log) ->\n      \"#{log.type},#{log.level},#{JSON.stringify log.message}\\n\"\n    'text': (log) ->\n      \"#{log.type},#{log.level},#{JSON.stringify log.message}\\n\"\n\n\n\nDependencies\n\n\nlog_fs = require './fs'",
            "title": "Csv.coffee"
        },
        {
            "location": "/log/csv.coffee/#nikitalogcsvoptions-callback",
            "text": "Write log to the host filesystem in CSV.",
            "title": "nikita.log.csv(options, [callback])"
        },
        {
            "location": "/log/csv.coffee/#options",
            "text": "archive  (boolean)  \n  Save a copy of the previous logs inside a dedicated directory, default is\n  \"false\".     basedir  (string)   \n  Directory where to store logs relative to the process working directory.\n  Default to the \"log\" directory. Note, if the \"archive\" option is activated\n  log file will be stored accessible from \"./log/latest\".     filename  (string)  \n  Name of the log file, contextually rendered with all options passed to\n  the mustache templating engine. Default to \"{{shortname}}.log\", where \n  \"shortname\" is the ssh host or localhost.      Global options can be alternatively set with the \"log_csv\" property.",
            "title": "Options"
        },
        {
            "location": "/log/csv.coffee/#source-code",
            "text": "module.exports = ssh: false, handler: (options) ->\n  # Obtains options from \"log_csv\" namespace\n  options.log_csv ?= {}\n  options[k] = v for k, v of options.log_csv\n  stdouting = 0\n  @call options, log_fs, serializer:\n    'diff': (log) ->\n      \"#{log.type},#{log.level},#{JSON.stringify log.message},\\n\"\n    'end': ->\n      \"lifecycle,INFO,Finished with success,\\n\"\n    'error': (err) ->\n      content = []\n      content.push \"lifecycle,ERROR,Finished with error,\\n\"\n      print = (err) ->\n        content.push \"lifecycle,ERROR,#{err.stack or err.message},\\n\"\n      unless err.errors\n      then print err\n      else if err.errors then for error in err.errors then print error\n      content.join()\n    'header': (log) ->\n      \"#{log.type},,,#{log.header}\\n\"\n    'stdin': (log) ->\n      \"#{log.type},#{log.level},#{JSON.stringify log.message}\\n\"\n    'stderr': (log) ->\n      \"#{log.type},#{log.level},#{JSON.stringify log.message}\\n\"\n    'stdout': (log) ->\n      \"#{log.type},#{log.level},#{JSON.stringify log.message}\\n\"\n    'text': (log) ->\n      \"#{log.type},#{log.level},#{JSON.stringify log.message}\\n\"",
            "title": "Source Code"
        },
        {
            "location": "/log/csv.coffee/#dependencies",
            "text": "log_fs = require './fs'",
            "title": "Dependencies"
        },
        {
            "location": "/log/fs.coffee/",
            "text": "nikita.log.fs(options, [callback])\n\n\nWrite log to the host filesystem in a user provided format.\n\n\nOptions\n\n\n\n\narchive\n (boolean) \n\n  Save a copy of the previous logs inside a dedicated directory, default is\n  \"false\".   \n\n\nbasedir\n (string)  \n\n  Directory where to store logs relative to the process working directory.\n  Default to the \"log\" directory. Note, if the \"archive\" option is activated\n  log file will be stored accessible from \"./log/latest\".   \n\n\nfilename\n (string) \n\n  Name of the log file, contextually rendered with all options passed to\n  the mustache templating engine. Default to \"{{basename}}.log\"   \n\n\nbasename\n (string) \n\n  Default variable used by the filename rendering. Default to \"localhost\"   \n\n\nserializer\n (object) \n\n  TODO...\n\n\n\n\nGlobal options can be alternatively set with the \"log_fs\" property.\n\n\nLayout\n\n\nBy default, a file name \"{{basename}}.log\" will be created inside the base\ndirectory defined by the option \"basedir\". \nThe path looks like \"{options.basedir}/{hostname}.log\".\n\n\nIf the option \"archive\" is activated, a folder named after the current time is\ncreated inside the base directory. A symbolic link named as \"latest\" will point\nthis is direction. The paths look like \"{options.basedir}/{time}/{hostname}.log\"\nand \"{options.basedir}/latest\".\n\n\nSource Code\n\n\nmodule.exports = ssh: false, handler: (options) ->\n  # Obtains options from \"log_fs\" namespace\n  options.log_fs ?= {}\n  options[k] = v for k, v of options.log_fs\n  # Validate options\n  throw Error \"Missing option: serializer\" unless options.serializer\n  # Normalize\n  options.archive ?= false\n  options.basedir ?= './log'\n  options.basedir = path.resolve options.basedir\n  options.basename ?= 'localhost'\n  options.filename ?= \"{{basename}}.log\"\n  # Render\n  options.basedir = mustache.render options.basedir, options\n  options.filename = mustache.render options.filename, options\n  # Archive options\n  unless options.archive\n    logdir = path.resolve options.basedir\n  else\n    latestdir = path.resolve options.basedir, 'latest'\n    now = new Date()\n    options.archive = \"#{now.getFullYear()}\".slice(-2) + \"0#{now.getFullYear()}\".slice(-2) + \"0#{now.getDate()}\".slice(-2) if options.archive is true\n    # dateformat = \"#{now.getFullYear()}-#{('0'+now.getMonth()).slice -2}-#{('0'+now.getDate()).slice -2}\"\n    # dateformat += \" #{('0'+now.getHours()).slice -2}-#{('0'+now.getMinutes()).slice -2}-#{('0'+now.getSeconds()).slice -2}\"\n    logdir = path.resolve options.basedir, options.archive      \n  @system.mkdir shy: true, logdir\n  # Events\n  @call ->\n    options.stream ?= fs.createWriteStream path.resolve logdir, options.filename\n    @call options, stream\n  @system.link\n    if: latestdir\n    shy: true\n    source: logdir\n    target: latestdir\n\n\n\nDependencies\n\n\nfs = require 'fs'\npath = require 'path'\nmustache = require 'mustache'\nstream = require './stream'",
            "title": "Fs.coffee"
        },
        {
            "location": "/log/fs.coffee/#nikitalogfsoptions-callback",
            "text": "Write log to the host filesystem in a user provided format.",
            "title": "nikita.log.fs(options, [callback])"
        },
        {
            "location": "/log/fs.coffee/#options",
            "text": "archive  (boolean)  \n  Save a copy of the previous logs inside a dedicated directory, default is\n  \"false\".     basedir  (string)   \n  Directory where to store logs relative to the process working directory.\n  Default to the \"log\" directory. Note, if the \"archive\" option is activated\n  log file will be stored accessible from \"./log/latest\".     filename  (string)  \n  Name of the log file, contextually rendered with all options passed to\n  the mustache templating engine. Default to \"{{basename}}.log\"     basename  (string)  \n  Default variable used by the filename rendering. Default to \"localhost\"     serializer  (object)  \n  TODO...   Global options can be alternatively set with the \"log_fs\" property.",
            "title": "Options"
        },
        {
            "location": "/log/fs.coffee/#layout",
            "text": "By default, a file name \"{{basename}}.log\" will be created inside the base\ndirectory defined by the option \"basedir\". \nThe path looks like \"{options.basedir}/{hostname}.log\".  If the option \"archive\" is activated, a folder named after the current time is\ncreated inside the base directory. A symbolic link named as \"latest\" will point\nthis is direction. The paths look like \"{options.basedir}/{time}/{hostname}.log\"\nand \"{options.basedir}/latest\".",
            "title": "Layout"
        },
        {
            "location": "/log/fs.coffee/#source-code",
            "text": "module.exports = ssh: false, handler: (options) ->\n  # Obtains options from \"log_fs\" namespace\n  options.log_fs ?= {}\n  options[k] = v for k, v of options.log_fs\n  # Validate options\n  throw Error \"Missing option: serializer\" unless options.serializer\n  # Normalize\n  options.archive ?= false\n  options.basedir ?= './log'\n  options.basedir = path.resolve options.basedir\n  options.basename ?= 'localhost'\n  options.filename ?= \"{{basename}}.log\"\n  # Render\n  options.basedir = mustache.render options.basedir, options\n  options.filename = mustache.render options.filename, options\n  # Archive options\n  unless options.archive\n    logdir = path.resolve options.basedir\n  else\n    latestdir = path.resolve options.basedir, 'latest'\n    now = new Date()\n    options.archive = \"#{now.getFullYear()}\".slice(-2) + \"0#{now.getFullYear()}\".slice(-2) + \"0#{now.getDate()}\".slice(-2) if options.archive is true\n    # dateformat = \"#{now.getFullYear()}-#{('0'+now.getMonth()).slice -2}-#{('0'+now.getDate()).slice -2}\"\n    # dateformat += \" #{('0'+now.getHours()).slice -2}-#{('0'+now.getMinutes()).slice -2}-#{('0'+now.getSeconds()).slice -2}\"\n    logdir = path.resolve options.basedir, options.archive      \n  @system.mkdir shy: true, logdir\n  # Events\n  @call ->\n    options.stream ?= fs.createWriteStream path.resolve logdir, options.filename\n    @call options, stream\n  @system.link\n    if: latestdir\n    shy: true\n    source: logdir\n    target: latestdir",
            "title": "Source Code"
        },
        {
            "location": "/log/fs.coffee/#dependencies",
            "text": "fs = require 'fs'\npath = require 'path'\nmustache = require 'mustache'\nstream = require './stream'",
            "title": "Dependencies"
        },
        {
            "location": "/log/md.coffee/",
            "text": "nikita.log.md(options, [callback])\n\n\nWrite log to the host filesystem in Markdown.\n\n\nOptions\n\n\n\n\narchive\n (boolean) \n\n  Save a copy of the previous logs inside a dedicated directory, default is\n  \"false\".   \n\n\nbasedir\n (string)  \n\n  Directory where to store logs relative to the process working directory.\n  Default to the \"log\" directory. Note, if the \"archive\" option is activated\n  log file will be stored accessible from \"./log/latest\".   \n\n\nfilename\n (string) \n\n  Name of the log file, contextually rendered with all options passed to\n  the mustache templating engine. Default to \"{{shortname}}.log\", where \n  \"shortname\" is the ssh host or localhost.   \n\n\n\n\nGlobal options can be alternatively set with the \"log_md\" property.\n\n\nSource Code\n\n\nmodule.exports = ssh: false, handler: (options) ->\n  # Obtains options from \"log_md\" namespace\n  options.log_md ?= {}\n  options[k] = v for k, v of options.log_md\n  # Normalize\n  options.divider ?= ' : '\n  # State\n  stdouting = 0\n  @call options, log_fs, serializer:\n    'diff': (log) ->\n      \"\\n```diff\\n#{log.message}```\\n\\n\" unless log.message\n    'end': ->\n      '\\nFINISHED WITH SUCCESS\\n'\n    'error': (err) ->\n      content = []\n      content.push '\\nFINISHED WITH ERROR\\n'\n      print = (err) ->\n        content.push err.stack or err.message + '\\n'\n      unless err.errors\n        print err\n      else if err.errors\n        content.push err.message + '\\n'\n        for error in err.errors then content.push error\n      content.join ''\n    'header': (log) ->\n      header = log.headers.join(options.divider)\n      \"\\n#{'#'.repeat log.headers.length} #{header}\\n\\n\"\n    'stdin': (log) ->\n      out = []\n      if log.message.indexOf('\\n') is -1\n      then out.push \"\\nRunning Command: `#{log.message}`\\n\\n\"\n      else out.push \"\\n```stdin\\n#{log.message}\\n```\\n\\n\"\n      # stdining = log.message isnt null\n      out.join ''\n    'stderr': (log) ->\n      \"\\n```stderr\\n#{log.message}```\\n\\n\"\n    'stdout_stream': (log) ->\n      # return if log.message is null and stdouting is 0\n      if log.message is null\n      then stdouting = 0\n      else stdouting++\n      out = []\n      out.push '\\n```stdout\\n' if stdouting is 1\n      out.push log.message if stdouting > 0\n      out.push '\\n```\\n\\n' if stdouting is 0\n      out.join ''\n    'text': (log) ->\n      content = []\n      content.push \"#{log.message}\"\n      content.push \" (#{log.total_depth}.#{log.level}, written by #{log.module})\" if log.module\n      content.push \"\\n\"\n      content.join ''\n\n\n\nDependencies\n\n\nlog_fs = require './fs'",
            "title": "Md.coffee"
        },
        {
            "location": "/log/md.coffee/#nikitalogmdoptions-callback",
            "text": "Write log to the host filesystem in Markdown.",
            "title": "nikita.log.md(options, [callback])"
        },
        {
            "location": "/log/md.coffee/#options",
            "text": "archive  (boolean)  \n  Save a copy of the previous logs inside a dedicated directory, default is\n  \"false\".     basedir  (string)   \n  Directory where to store logs relative to the process working directory.\n  Default to the \"log\" directory. Note, if the \"archive\" option is activated\n  log file will be stored accessible from \"./log/latest\".     filename  (string)  \n  Name of the log file, contextually rendered with all options passed to\n  the mustache templating engine. Default to \"{{shortname}}.log\", where \n  \"shortname\" is the ssh host or localhost.      Global options can be alternatively set with the \"log_md\" property.",
            "title": "Options"
        },
        {
            "location": "/log/md.coffee/#source-code",
            "text": "module.exports = ssh: false, handler: (options) ->\n  # Obtains options from \"log_md\" namespace\n  options.log_md ?= {}\n  options[k] = v for k, v of options.log_md\n  # Normalize\n  options.divider ?= ' : '\n  # State\n  stdouting = 0\n  @call options, log_fs, serializer:\n    'diff': (log) ->\n      \"\\n```diff\\n#{log.message}```\\n\\n\" unless log.message\n    'end': ->\n      '\\nFINISHED WITH SUCCESS\\n'\n    'error': (err) ->\n      content = []\n      content.push '\\nFINISHED WITH ERROR\\n'\n      print = (err) ->\n        content.push err.stack or err.message + '\\n'\n      unless err.errors\n        print err\n      else if err.errors\n        content.push err.message + '\\n'\n        for error in err.errors then content.push error\n      content.join ''\n    'header': (log) ->\n      header = log.headers.join(options.divider)\n      \"\\n#{'#'.repeat log.headers.length} #{header}\\n\\n\"\n    'stdin': (log) ->\n      out = []\n      if log.message.indexOf('\\n') is -1\n      then out.push \"\\nRunning Command: `#{log.message}`\\n\\n\"\n      else out.push \"\\n```stdin\\n#{log.message}\\n```\\n\\n\"\n      # stdining = log.message isnt null\n      out.join ''\n    'stderr': (log) ->\n      \"\\n```stderr\\n#{log.message}```\\n\\n\"\n    'stdout_stream': (log) ->\n      # return if log.message is null and stdouting is 0\n      if log.message is null\n      then stdouting = 0\n      else stdouting++\n      out = []\n      out.push '\\n```stdout\\n' if stdouting is 1\n      out.push log.message if stdouting > 0\n      out.push '\\n```\\n\\n' if stdouting is 0\n      out.join ''\n    'text': (log) ->\n      content = []\n      content.push \"#{log.message}\"\n      content.push \" (#{log.total_depth}.#{log.level}, written by #{log.module})\" if log.module\n      content.push \"\\n\"\n      content.join ''",
            "title": "Source Code"
        },
        {
            "location": "/log/md.coffee/#dependencies",
            "text": "log_fs = require './fs'",
            "title": "Dependencies"
        },
        {
            "location": "/log/stream.coffee/",
            "text": "nikita.log.stream(options, [callback])\n\n\nWrite log to the host filesystem in a user provided format.\n\n\nOptions\n\n\n\n\narchive\n (boolean) \n\n  Save a copy of the previous logs inside a dedicated directory, default is\n  \"false\".   \n\n\nbasedir\n (string)  \n\n  Directory where to store logs relative to the process working directory.\n  Default to the \"log\" directory. Note, if the \"archive\" option is activated\n  log file will be stored accessible from \"./log/latest\".   \n\n\nfilename\n (string) \n\n  Name of the log file, contextually rendered with all options passed to\n  the mustache templating engine. Default to \"{{shortname}}.log\", where \n  \"shortname\" is the ssh host or localhost.   \n\n\nserializer\n (object) \n\n  TODO...\n\n\n\n\nGlobal options can be alternatively set with the \"log_stream\" property.\n\n\nSource Code\n\n\nmodule.exports = ssh: false, handler: (options) ->\n  # Obtains options from \"log_stream\" namespace\n  options.log_stream ?= {}\n  options[k] = v for k, v of options.log_stream\n  # Validate options\n  throw Error 'Missing option: \"stream\"' unless options.stream\n  throw Error 'Missing option: \"serializer\"' unless options.serializer\n  # Normalize\n  options.end ?= true\n  # Events\n  @call ->\n    close = -> setTimeout ->\n      options.stream.close() if options.end\n    , 100\n    @on 'lifecycle', (log) ->\n      return unless options.serializer.lifecycle\n      data = options.serializer.lifecycle log\n      options.stream.write data if data?\n    @on 'text', (log) ->\n      return unless options.serializer.text\n      data = options.serializer.text log\n      options.stream.write data if data?\n    @on 'header', (log) ->\n      return unless options.serializer.header\n      data = options.serializer.header log\n      options.stream.write data if data?\n    @on 'stdin', (log) ->\n      return unless options.serializer.stdin\n      data = options.serializer.stdin log\n      options.stream.write data if data?\n    @on 'diff', (log) ->\n      return unless options.serializer.diff\n      data = options.serializer.diff log\n      options.stream.write data if data?\n    @on 'handled', (log) ->\n      return unless options.serializer.handled\n      data = options.serializer.handled log\n      options.stream.write data if data?\n    @on 'stdout_stream', (log) ->\n      return unless options.serializer.stdout_stream\n      data = options.serializer.stdout_stream log\n      options.stream.write data if data?\n    @on 'stderr', (log) ->\n      return unless options.serializer.stderr\n      data = options.serializer.stderr log\n      options.stream.write data if data?\n    @on 'end', ->\n      return unless options.serializer.end\n      data = options.serializer.end log\n      options.stream.write data if data?\n      close()\n    @on 'error', (err) ->\n      return unless options.serializer.error\n      data = options.serializer.error log\n      options.stream.write data if data?\n      close()\n\n\n\nDependencies\n\n\nfs = require 'fs'\npath = require 'path'\nmustache = require 'mustache'",
            "title": "Stream.coffee"
        },
        {
            "location": "/log/stream.coffee/#nikitalogstreamoptions-callback",
            "text": "Write log to the host filesystem in a user provided format.",
            "title": "nikita.log.stream(options, [callback])"
        },
        {
            "location": "/log/stream.coffee/#options",
            "text": "archive  (boolean)  \n  Save a copy of the previous logs inside a dedicated directory, default is\n  \"false\".     basedir  (string)   \n  Directory where to store logs relative to the process working directory.\n  Default to the \"log\" directory. Note, if the \"archive\" option is activated\n  log file will be stored accessible from \"./log/latest\".     filename  (string)  \n  Name of the log file, contextually rendered with all options passed to\n  the mustache templating engine. Default to \"{{shortname}}.log\", where \n  \"shortname\" is the ssh host or localhost.     serializer  (object)  \n  TODO...   Global options can be alternatively set with the \"log_stream\" property.",
            "title": "Options"
        },
        {
            "location": "/log/stream.coffee/#source-code",
            "text": "module.exports = ssh: false, handler: (options) ->\n  # Obtains options from \"log_stream\" namespace\n  options.log_stream ?= {}\n  options[k] = v for k, v of options.log_stream\n  # Validate options\n  throw Error 'Missing option: \"stream\"' unless options.stream\n  throw Error 'Missing option: \"serializer\"' unless options.serializer\n  # Normalize\n  options.end ?= true\n  # Events\n  @call ->\n    close = -> setTimeout ->\n      options.stream.close() if options.end\n    , 100\n    @on 'lifecycle', (log) ->\n      return unless options.serializer.lifecycle\n      data = options.serializer.lifecycle log\n      options.stream.write data if data?\n    @on 'text', (log) ->\n      return unless options.serializer.text\n      data = options.serializer.text log\n      options.stream.write data if data?\n    @on 'header', (log) ->\n      return unless options.serializer.header\n      data = options.serializer.header log\n      options.stream.write data if data?\n    @on 'stdin', (log) ->\n      return unless options.serializer.stdin\n      data = options.serializer.stdin log\n      options.stream.write data if data?\n    @on 'diff', (log) ->\n      return unless options.serializer.diff\n      data = options.serializer.diff log\n      options.stream.write data if data?\n    @on 'handled', (log) ->\n      return unless options.serializer.handled\n      data = options.serializer.handled log\n      options.stream.write data if data?\n    @on 'stdout_stream', (log) ->\n      return unless options.serializer.stdout_stream\n      data = options.serializer.stdout_stream log\n      options.stream.write data if data?\n    @on 'stderr', (log) ->\n      return unless options.serializer.stderr\n      data = options.serializer.stderr log\n      options.stream.write data if data?\n    @on 'end', ->\n      return unless options.serializer.end\n      data = options.serializer.end log\n      options.stream.write data if data?\n      close()\n    @on 'error', (err) ->\n      return unless options.serializer.error\n      data = options.serializer.error log\n      options.stream.write data if data?\n      close()",
            "title": "Source Code"
        },
        {
            "location": "/log/stream.coffee/#dependencies",
            "text": "fs = require 'fs'\npath = require 'path'\nmustache = require 'mustache'",
            "title": "Dependencies"
        },
        {
            "location": "/misc/conditions.coffee/",
            "text": "Conditions\n\n\nConditions are a set of properties you may add to the options of the Nikita\nfunctions. They apply to all functions and control their execution.\n\n\nA Nikita action will be executed if all the positive conditions are \"true\" and\nnone of the negative conditions are \"true\".\n\n\nmodule.exports =\n\n\n\nRun an action for a user defined condition: \nif\n\n\nWork on the property \nif\n in \noptions\n.\n\n\nWhen \nif\n is a boolean, a string, a number or null, its value determine the\noutput.\n\n\nIf it's a function, the arguments vary depending on the callback signature. With\n1 argument, the argument is an options object and the handler is run\nsynchronously. With 2 arguments, the arguments are an options object plus a\ncallback and the handler is run asynchronously.\n\n\nIf it's an array, all its element must positively resolve for the condition to\npass.\n\n\nUpdating the content of a file if we are the owner\n\n\nnikita.file.render({\n  source:'./file',\n  if: function(options, callback){\n    fs.stat(options.source, function(err, stat){\n      # Render the file if we own it\n      callback(err, stat.uid == process.getuid())\n    });\n  }\n}, fonction(err, rendered){});\n\n\n\n\n  if: (options, succeed, skip) ->\n    options.if = [options.if] unless Array.isArray options.if\n    ok = true\n    each(options.if)\n    .call (si, next) =>\n      return next() unless ok\n      type = typeof si\n      if si is null or type is 'undefined'\n        ok = false\n        next()\n      else if type is 'boolean' or type is 'number'\n        ok = false unless si\n        next()\n      else if type is 'function'\n        if si.length < 2\n          try\n            ok = false unless si.call @, options\n            next()\n          catch err then next err\n        else if si.length is 2\n          si.call @, options, (err, is_ok) ->\n            return next err if err\n            ok = false unless is_ok\n            next()\n        else next Error \"Invalid argument length, expecting 2 or less, got #{si.length}\"\n      else if type is 'string' or (type is 'object' and Buffer.isBuffer si)\n        si = template si.toString(), options\n        ok = false if si.length is 0\n        next()\n      else\n        next Error \"Invalid condition \\\"if\\\": #{JSON.stringify si}\"\n    .next (err) ->\n      if err or not ok then skip(err) else succeed()\n\n\n\nRun an action if false: \nunless\n\n\nWork on the property \nunless\n in \noptions\n.\n\n\nWhen \nif\n is a boolean, a string, a number or null, its value determine the\noutput.\n\n\nIf it's a function, the arguments vary depending on the callback signature. With\n1 argument, the argument is an options object and the handler is run\nsynchronously. With 2 arguments, the arguments are an options object plus a\ncallback and the handler is run asynchronously.\n\n\nIf it's an array, all its element must negatively resolve for the condition to\npass.\n\n\n  unless: (options, succeed, skip) ->\n    options.unless = [options.unless] unless Array.isArray options.unless\n    ok = true\n    each(options.unless)\n    .call (not_if, next) =>\n      return next() unless ok\n      type = typeof not_if\n      if not_if is null or type is 'undefined'\n        ok = true\n        next()\n      else if type is 'boolean' or type is 'number'\n        ok = false if not_if\n        next()\n      else if type is 'function'\n        if not_if.length < 2\n          try\n            ok = false if not_if.call @, options\n            next()\n          catch err then next err\n        else if not_if.length is 2\n          not_if.call @, options, (err, is_ok) ->\n            return next err if err\n            ok = false if is_ok\n            next()\n        else next Error \"Invalid callback\"\n      else if type is 'string' or (type is 'object' and Buffer.isBuffer not_if)\n        not_if = template not_if.toString(), options\n        ok = false if not_if.length isnt 0\n        next()\n      else\n        next Error \"Invalid condition \\\"unless\\\": #{JSON.stringify not_if}\"\n    .next (err) ->\n      if err or not ok then skip(err) else succeed()\n\n\n\nRun an action if a command succeed: \nif_exec\n\n\nWork on the property \nif_exec\n in \noptions\n. The value may \nbe a single shell command or an array of commands.   \n\n\nThe callback \nsucceed\n is called if all the provided command \nwere executed successfully otherwise the callback \nskip\n is called.\n\n\n  if_exec: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    each(options.if_exec)\n    .call (cmd, next) ->\n      options.log? message: \"Nikita `if_exec`: #{cmd}\", level: 'DEBUG', module: 'nikita/misc/conditions'\n      run = exec ssh: ssh, cmd: cmd\n      # if options.stdout\n      #   run.stdout.pipe options.stdout, end: false\n      # if options.stderr\n      #   run.stderr.pipe options.stderr, end: false\n      run.on \"exit\", (code) ->\n        options.log? message: \"Nikita `if_exec`: code is \\\"#{code}\\\"\", level: 'INFO', module: 'nikita/misc/conditions'\n        if code is 0 then next() else skip()\n    .next succeed\n\n\n\nRun an action unless a command succeed: \nunless_exec\n\n\nWork on the property \nunless_exec\n in \noptions\n. The value may \nbe a single shell command or an array of commands.   \n\n\nThe callback \nsucceed\n is called if all the provided command \nwere executed with failure otherwise the callback \nskip\n is called.\n\n\n  unless_exec: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    each(options.unless_exec)\n    .call (cmd, next) ->\n      options.log? message: \"Nikita `unless_exec`: #{cmd}\", level: 'DEBUG', module: 'nikita/misc/conditions'\n      run = exec ssh: ssh, cmd: cmd\n      # if options.stdout\n      #   run.stdout.pipe options.stdout, end: false\n      # if options.stderr\n      #   run.stderr.pipe options.stderr, end: false\n      run.on \"exit\", (code) ->\n        options.log? message: \"Nikita `unless_exec`: code is \\\"#{code}\\\"\", level: 'INFO', module: 'nikita/misc/conditions'\n        if code is 0 then skip() else next()\n    .next succeed\n\n\n\nRun an action if OS match: \nif_os\n\n\nWork on the property \nif_os\n in \noptions\n. The value may \nbe a single condition command or an array of conditions.   \n\n\nThe callback \nsucceed\n is called if any of the provided filter passed otherwise\nthe callback \nskip\n is called.\n\n\n  if_os: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    options.if_os = [options.if_os] unless Array.isArray options.if_os\n    for rule in options.if_os\n      rule.name ?= []\n      rule.name = [rule.name] unless Array.isArray rule.name\n      rule.version ?= []\n      rule.version = [rule.version] unless Array.isArray rule.version\n      rule.version = semver.sanitize rule.version, 'x'\n      rule.arch ?= []\n      rule.arch = [rule.arch] unless Array.isArray rule.arch\n    options.log? message: \"Nikita `if_os`: #{JSON.stringify options.if_os}\", level: 'DEBUG', module: 'nikita/misc/conditions'\n    exec ssh, os, (err, stdout, stderr) ->\n      return skip err if err\n      [arch, name, version] = stdout.split '|'\n      name = 'redhat' if name.toLowerCase() is 'red hat'\n      # Remove minor version (eg centos 7)\n      version = \"#{match[0]}\" if match = /^(\\d+)\\.(\\d+)/.exec version\n      match = options.if_os.some (rule) ->\n        n = !rule.name.length || rule.name.some (value) ->\n          return true if typeof value is 'string' and value is name\n          return true if value instanceof RegExp and value.test name\n        v = !rule.version.length || rule.version.some (value) ->\n          version = semver.sanitize version, '0'\n          return true if typeof value is 'string' and semver.satisfies version, value\n          return true if value instanceof RegExp and value.test version\n        return n and v\n      if match then succeed() else skip()\n\n\n\nRun an action unless OS match: \nunless_os\n\n\nWork on the property \nunless_os\n in \noptions\n. The value may \nbe a single condition command or an array of conditions.   \n\n\nThe callback \nsucceed\n is called if none of the provided filter passed otherwise\nthe callback \nskip\n is called.\n\n\n  unless_os: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    options.unless_os = [options.unless_os] unless Array.isArray options.unless_os\n    for rule in options.unless_os\n      rule.name ?= []\n      rule.name = [rule.name] unless Array.isArray rule.name\n      rule.version ?= []\n      rule.version = [rule.version] unless Array.isArray rule.version\n      rule.version = semver.sanitize rule.version, 'x'\n      rule.arch ?= []\n      rule.arch = [rule.arch] unless Array.isArray rule.arch\n    options.log? message: \"Nikita `unless_os`: #{JSON.stringify options.unless_os}\", level: 'DEBUG', module: 'nikita/misc/conditions'\n    exec ssh, os, (err, stdout, stderr) ->\n      return skip err if err\n      [arch, name, version] = stdout.split '|'\n      name = 'redhat' if name.toLowerCase() is 'red hat'\n      # Remove minor version (eg centos 7)\n      version = \"#{match[0]}\" if match = /^(\\d+)\\.(\\d+)/.exec version\n      match = options.unless_os.some (rule) ->\n        n = !rule.name.length || rule.name.some (value) ->\n          return true if typeof value is 'string' and value is name\n          return true if value instanceof RegExp and value.test name\n        v = !rule.version.length || rule.version.some (value) ->\n          version = semver.sanitize version, '0'\n          return true if typeof value is 'string' and semver.satisfies version, value\n          return true if value instanceof RegExp and value.test version\n        return n and v\n      if match then skip() else succeed()\n\n\n\nRun an action if a file exists: \nif_exists\n\n\nWork on the property \nif_exists\n in \noptions\n. The value may \nbe a file path or an array of file paths. You could also set the\nvalue to \ntrue\n, in which case it will be set with the \ntarget\n\noption.\n\n\nThe callback \nsucceed\n is called if all the provided paths \nexists otherwise the callback \nskip\n is called.\n\n\n  if_exists: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    if typeof options.if_exists is 'boolean' and options.target\n      options.if_exists = if options.if_exists then [options.target] else null\n    each(options.if_exists)\n    .call (if_exists, next) ->\n      fs.exists ssh, if_exists, (err, exists) ->\n        if exists\n          options.log? message: \"File exists #{if_exists}, continuing\", level: 'DEBUG', module: 'nikita/misc/conditions'\n          next()\n        else\n          options.log? message: \"File doesnt exists #{if_exists}, skipping\", level: 'INFO', module: 'nikita/misc/conditions'\n          skip()\n    .next succeed\n\n\n\nSkip an action if a file exists: \nunless_exists\n\n\nWork on the property \nunless_exists\n in \noptions\n. The value may \nbe a file path or an array of file paths. You could also set the\nvalue to \ntrue\n, in which case it will be set with the \ntarget\n\noption.\n\n\nThe callback \nsucceed\n is called if none of the provided paths \nexists otherwise the callback \nskip\n is called.\n\n\n  unless_exists: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    if typeof options.unless_exists is 'boolean' and options.target\n      options.unless_exists = if options.unless_exists then [options.target] else null\n    each(options.unless_exists)\n    .call (unless_exists, next) ->\n      fs.exists ssh, unless_exists, (err, exists) ->\n        if exists\n          options.log? message: \"File exists #{unless_exists}, skipping\", level: 'INFO', module: 'nikita/misc/conditions'\n          skip()\n        else\n          options.log? message: \"File doesnt exists #{unless_exists}, continuing\", level: 'DEBUG', module: 'nikita/misc/conditions'\n          next()\n    .next succeed\n\n\n\nEnsure a file exist: \nshould_exist\n\n\nEnsure that an action run if all the files present in the \noption \"should_exist\" exist. The value may \nbe a file path or an array of file paths.\n\n\nThe callback \nsucceed\n is called if all of the provided paths \nexists otherwise the callback \nskip\n is called with an error.\n\n\n  should_exist: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    each(options.should_exist)\n    .call (should_exist, next) ->\n      fs.exists ssh, should_exist, (err, exists) ->\n        if exists\n        then next()\n        else next Error \"File does not exist: #{should_exist}\"\n    .error skip\n    .next succeed\n\n\n\nEnsure a file already exist: \nshould_not_exist\n\n\nEnsure that an action run if none of the files present in the \noption \"should_exist\" exist. The value may \nbe a file path or an array of file paths.\n\n\nThe callback \nsucceed\n is called if none of the provided paths \nexists otherwise the callback \nskip\n is called with an error.\n\n\n  should_not_exist: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    each(options.should_not_exist)\n    .call (should_not_exist, next) ->\n      fs.exists ssh, should_not_exist, (err, exists) ->\n        if exists\n        then next Error \"File does not exist: #{should_not_exist}\"\n        else next()\n    .error skip\n    .next -> succeed()\n\n\n\nRun all conditions: \nall(options, skip, succeed)\n\n\nThis is the function run internally to execute all the conditions.\n\n\n\n\nopts\n\n    Command options\n\n\nsucceed\n\n    Succeed callback, only called if all the condition succeed\n\n\nskip\n\n    Skip callback, called when a condition is not fulfill. May also be called with on error on failure\n\n\n\n\nExample:\n\n\nconditions.all({\n  if: true\n}, function(){\n  console.info('Conditions succeed')\n}, function(err){\n  console.info('Conditins failed or pass an error')\n})\n\n\n\n\n  all: (context, options, succeed, failed) ->\n    return succeed() unless options? and (typeof options is 'object' and not Array.isArray options)\n    keys = Object.keys options\n    i = 0\n    next = ->\n      key = keys[i++]\n      return succeed() unless key?\n      return next() if key is 'all'\n      return next() unless module.exports[key]?\n      module.exports[key].call context, options, next, (err) ->\n        # options.log? \"Nikita `#{key}`: skipping action\"\n        failed err\n    next()\n    null\n\n\n\nDependencies\n\n\neach = require 'each'\nexec = require 'ssh2-exec'\nfs = require 'ssh2-fs'\nos = require './os'\nsemver = require './semver'\ntemplate = require './template'",
            "title": "Conditions.coffee"
        },
        {
            "location": "/misc/conditions.coffee/#conditions",
            "text": "Conditions are a set of properties you may add to the options of the Nikita\nfunctions. They apply to all functions and control their execution.  A Nikita action will be executed if all the positive conditions are \"true\" and\nnone of the negative conditions are \"true\".  module.exports =",
            "title": "Conditions"
        },
        {
            "location": "/misc/conditions.coffee/#run-an-action-for-a-user-defined-condition-if",
            "text": "Work on the property  if  in  options .  When  if  is a boolean, a string, a number or null, its value determine the\noutput.  If it's a function, the arguments vary depending on the callback signature. With\n1 argument, the argument is an options object and the handler is run\nsynchronously. With 2 arguments, the arguments are an options object plus a\ncallback and the handler is run asynchronously.  If it's an array, all its element must positively resolve for the condition to\npass.  Updating the content of a file if we are the owner  nikita.file.render({\n  source:'./file',\n  if: function(options, callback){\n    fs.stat(options.source, function(err, stat){\n      # Render the file if we own it\n      callback(err, stat.uid == process.getuid())\n    });\n  }\n}, fonction(err, rendered){});    if: (options, succeed, skip) ->\n    options.if = [options.if] unless Array.isArray options.if\n    ok = true\n    each(options.if)\n    .call (si, next) =>\n      return next() unless ok\n      type = typeof si\n      if si is null or type is 'undefined'\n        ok = false\n        next()\n      else if type is 'boolean' or type is 'number'\n        ok = false unless si\n        next()\n      else if type is 'function'\n        if si.length < 2\n          try\n            ok = false unless si.call @, options\n            next()\n          catch err then next err\n        else if si.length is 2\n          si.call @, options, (err, is_ok) ->\n            return next err if err\n            ok = false unless is_ok\n            next()\n        else next Error \"Invalid argument length, expecting 2 or less, got #{si.length}\"\n      else if type is 'string' or (type is 'object' and Buffer.isBuffer si)\n        si = template si.toString(), options\n        ok = false if si.length is 0\n        next()\n      else\n        next Error \"Invalid condition \\\"if\\\": #{JSON.stringify si}\"\n    .next (err) ->\n      if err or not ok then skip(err) else succeed()",
            "title": "Run an action for a user defined condition: if"
        },
        {
            "location": "/misc/conditions.coffee/#run-an-action-if-false-unless",
            "text": "Work on the property  unless  in  options .  When  if  is a boolean, a string, a number or null, its value determine the\noutput.  If it's a function, the arguments vary depending on the callback signature. With\n1 argument, the argument is an options object and the handler is run\nsynchronously. With 2 arguments, the arguments are an options object plus a\ncallback and the handler is run asynchronously.  If it's an array, all its element must negatively resolve for the condition to\npass.    unless: (options, succeed, skip) ->\n    options.unless = [options.unless] unless Array.isArray options.unless\n    ok = true\n    each(options.unless)\n    .call (not_if, next) =>\n      return next() unless ok\n      type = typeof not_if\n      if not_if is null or type is 'undefined'\n        ok = true\n        next()\n      else if type is 'boolean' or type is 'number'\n        ok = false if not_if\n        next()\n      else if type is 'function'\n        if not_if.length < 2\n          try\n            ok = false if not_if.call @, options\n            next()\n          catch err then next err\n        else if not_if.length is 2\n          not_if.call @, options, (err, is_ok) ->\n            return next err if err\n            ok = false if is_ok\n            next()\n        else next Error \"Invalid callback\"\n      else if type is 'string' or (type is 'object' and Buffer.isBuffer not_if)\n        not_if = template not_if.toString(), options\n        ok = false if not_if.length isnt 0\n        next()\n      else\n        next Error \"Invalid condition \\\"unless\\\": #{JSON.stringify not_if}\"\n    .next (err) ->\n      if err or not ok then skip(err) else succeed()",
            "title": "Run an action if false: unless"
        },
        {
            "location": "/misc/conditions.coffee/#run-an-action-if-a-command-succeed-if_exec",
            "text": "Work on the property  if_exec  in  options . The value may \nbe a single shell command or an array of commands.     The callback  succeed  is called if all the provided command \nwere executed successfully otherwise the callback  skip  is called.    if_exec: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    each(options.if_exec)\n    .call (cmd, next) ->\n      options.log? message: \"Nikita `if_exec`: #{cmd}\", level: 'DEBUG', module: 'nikita/misc/conditions'\n      run = exec ssh: ssh, cmd: cmd\n      # if options.stdout\n      #   run.stdout.pipe options.stdout, end: false\n      # if options.stderr\n      #   run.stderr.pipe options.stderr, end: false\n      run.on \"exit\", (code) ->\n        options.log? message: \"Nikita `if_exec`: code is \\\"#{code}\\\"\", level: 'INFO', module: 'nikita/misc/conditions'\n        if code is 0 then next() else skip()\n    .next succeed",
            "title": "Run an action if a command succeed: if_exec"
        },
        {
            "location": "/misc/conditions.coffee/#run-an-action-unless-a-command-succeed-unless_exec",
            "text": "Work on the property  unless_exec  in  options . The value may \nbe a single shell command or an array of commands.     The callback  succeed  is called if all the provided command \nwere executed with failure otherwise the callback  skip  is called.    unless_exec: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    each(options.unless_exec)\n    .call (cmd, next) ->\n      options.log? message: \"Nikita `unless_exec`: #{cmd}\", level: 'DEBUG', module: 'nikita/misc/conditions'\n      run = exec ssh: ssh, cmd: cmd\n      # if options.stdout\n      #   run.stdout.pipe options.stdout, end: false\n      # if options.stderr\n      #   run.stderr.pipe options.stderr, end: false\n      run.on \"exit\", (code) ->\n        options.log? message: \"Nikita `unless_exec`: code is \\\"#{code}\\\"\", level: 'INFO', module: 'nikita/misc/conditions'\n        if code is 0 then skip() else next()\n    .next succeed",
            "title": "Run an action unless a command succeed: unless_exec"
        },
        {
            "location": "/misc/conditions.coffee/#run-an-action-if-os-match-if_os",
            "text": "Work on the property  if_os  in  options . The value may \nbe a single condition command or an array of conditions.     The callback  succeed  is called if any of the provided filter passed otherwise\nthe callback  skip  is called.    if_os: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    options.if_os = [options.if_os] unless Array.isArray options.if_os\n    for rule in options.if_os\n      rule.name ?= []\n      rule.name = [rule.name] unless Array.isArray rule.name\n      rule.version ?= []\n      rule.version = [rule.version] unless Array.isArray rule.version\n      rule.version = semver.sanitize rule.version, 'x'\n      rule.arch ?= []\n      rule.arch = [rule.arch] unless Array.isArray rule.arch\n    options.log? message: \"Nikita `if_os`: #{JSON.stringify options.if_os}\", level: 'DEBUG', module: 'nikita/misc/conditions'\n    exec ssh, os, (err, stdout, stderr) ->\n      return skip err if err\n      [arch, name, version] = stdout.split '|'\n      name = 'redhat' if name.toLowerCase() is 'red hat'\n      # Remove minor version (eg centos 7)\n      version = \"#{match[0]}\" if match = /^(\\d+)\\.(\\d+)/.exec version\n      match = options.if_os.some (rule) ->\n        n = !rule.name.length || rule.name.some (value) ->\n          return true if typeof value is 'string' and value is name\n          return true if value instanceof RegExp and value.test name\n        v = !rule.version.length || rule.version.some (value) ->\n          version = semver.sanitize version, '0'\n          return true if typeof value is 'string' and semver.satisfies version, value\n          return true if value instanceof RegExp and value.test version\n        return n and v\n      if match then succeed() else skip()",
            "title": "Run an action if OS match: if_os"
        },
        {
            "location": "/misc/conditions.coffee/#run-an-action-unless-os-match-unless_os",
            "text": "Work on the property  unless_os  in  options . The value may \nbe a single condition command or an array of conditions.     The callback  succeed  is called if none of the provided filter passed otherwise\nthe callback  skip  is called.    unless_os: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    options.unless_os = [options.unless_os] unless Array.isArray options.unless_os\n    for rule in options.unless_os\n      rule.name ?= []\n      rule.name = [rule.name] unless Array.isArray rule.name\n      rule.version ?= []\n      rule.version = [rule.version] unless Array.isArray rule.version\n      rule.version = semver.sanitize rule.version, 'x'\n      rule.arch ?= []\n      rule.arch = [rule.arch] unless Array.isArray rule.arch\n    options.log? message: \"Nikita `unless_os`: #{JSON.stringify options.unless_os}\", level: 'DEBUG', module: 'nikita/misc/conditions'\n    exec ssh, os, (err, stdout, stderr) ->\n      return skip err if err\n      [arch, name, version] = stdout.split '|'\n      name = 'redhat' if name.toLowerCase() is 'red hat'\n      # Remove minor version (eg centos 7)\n      version = \"#{match[0]}\" if match = /^(\\d+)\\.(\\d+)/.exec version\n      match = options.unless_os.some (rule) ->\n        n = !rule.name.length || rule.name.some (value) ->\n          return true if typeof value is 'string' and value is name\n          return true if value instanceof RegExp and value.test name\n        v = !rule.version.length || rule.version.some (value) ->\n          version = semver.sanitize version, '0'\n          return true if typeof value is 'string' and semver.satisfies version, value\n          return true if value instanceof RegExp and value.test version\n        return n and v\n      if match then skip() else succeed()",
            "title": "Run an action unless OS match: unless_os"
        },
        {
            "location": "/misc/conditions.coffee/#run-an-action-if-a-file-exists-if_exists",
            "text": "Work on the property  if_exists  in  options . The value may \nbe a file path or an array of file paths. You could also set the\nvalue to  true , in which case it will be set with the  target \noption.  The callback  succeed  is called if all the provided paths \nexists otherwise the callback  skip  is called.    if_exists: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    if typeof options.if_exists is 'boolean' and options.target\n      options.if_exists = if options.if_exists then [options.target] else null\n    each(options.if_exists)\n    .call (if_exists, next) ->\n      fs.exists ssh, if_exists, (err, exists) ->\n        if exists\n          options.log? message: \"File exists #{if_exists}, continuing\", level: 'DEBUG', module: 'nikita/misc/conditions'\n          next()\n        else\n          options.log? message: \"File doesnt exists #{if_exists}, skipping\", level: 'INFO', module: 'nikita/misc/conditions'\n          skip()\n    .next succeed",
            "title": "Run an action if a file exists: if_exists"
        },
        {
            "location": "/misc/conditions.coffee/#skip-an-action-if-a-file-exists-unless_exists",
            "text": "Work on the property  unless_exists  in  options . The value may \nbe a file path or an array of file paths. You could also set the\nvalue to  true , in which case it will be set with the  target \noption.  The callback  succeed  is called if none of the provided paths \nexists otherwise the callback  skip  is called.    unless_exists: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    if typeof options.unless_exists is 'boolean' and options.target\n      options.unless_exists = if options.unless_exists then [options.target] else null\n    each(options.unless_exists)\n    .call (unless_exists, next) ->\n      fs.exists ssh, unless_exists, (err, exists) ->\n        if exists\n          options.log? message: \"File exists #{unless_exists}, skipping\", level: 'INFO', module: 'nikita/misc/conditions'\n          skip()\n        else\n          options.log? message: \"File doesnt exists #{unless_exists}, continuing\", level: 'DEBUG', module: 'nikita/misc/conditions'\n          next()\n    .next succeed",
            "title": "Skip an action if a file exists: unless_exists"
        },
        {
            "location": "/misc/conditions.coffee/#ensure-a-file-exist-should_exist",
            "text": "Ensure that an action run if all the files present in the \noption \"should_exist\" exist. The value may \nbe a file path or an array of file paths.  The callback  succeed  is called if all of the provided paths \nexists otherwise the callback  skip  is called with an error.    should_exist: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    each(options.should_exist)\n    .call (should_exist, next) ->\n      fs.exists ssh, should_exist, (err, exists) ->\n        if exists\n        then next()\n        else next Error \"File does not exist: #{should_exist}\"\n    .error skip\n    .next succeed",
            "title": "Ensure a file exist: should_exist"
        },
        {
            "location": "/misc/conditions.coffee/#ensure-a-file-already-exist-should_not_exist",
            "text": "Ensure that an action run if none of the files present in the \noption \"should_exist\" exist. The value may \nbe a file path or an array of file paths.  The callback  succeed  is called if none of the provided paths \nexists otherwise the callback  skip  is called with an error.    should_not_exist: (options, succeed, skip) ->\n    # SSH connection\n    ssh = @ssh options.ssh\n    each(options.should_not_exist)\n    .call (should_not_exist, next) ->\n      fs.exists ssh, should_not_exist, (err, exists) ->\n        if exists\n        then next Error \"File does not exist: #{should_not_exist}\"\n        else next()\n    .error skip\n    .next -> succeed()",
            "title": "Ensure a file already exist: should_not_exist"
        },
        {
            "location": "/misc/conditions.coffee/#run-all-conditions-alloptions-skip-succeed",
            "text": "This is the function run internally to execute all the conditions.   opts \n    Command options  succeed \n    Succeed callback, only called if all the condition succeed  skip \n    Skip callback, called when a condition is not fulfill. May also be called with on error on failure   Example:  conditions.all({\n  if: true\n}, function(){\n  console.info('Conditions succeed')\n}, function(err){\n  console.info('Conditins failed or pass an error')\n})    all: (context, options, succeed, failed) ->\n    return succeed() unless options? and (typeof options is 'object' and not Array.isArray options)\n    keys = Object.keys options\n    i = 0\n    next = ->\n      key = keys[i++]\n      return succeed() unless key?\n      return next() if key is 'all'\n      return next() unless module.exports[key]?\n      module.exports[key].call context, options, next, (err) ->\n        # options.log? \"Nikita `#{key}`: skipping action\"\n        failed err\n    next()\n    null",
            "title": "Run all conditions: all(options, skip, succeed)"
        },
        {
            "location": "/misc/conditions.coffee/#dependencies",
            "text": "each = require 'each'\nexec = require 'ssh2-exec'\nfs = require 'ssh2-fs'\nos = require './os'\nsemver = require './semver'\ntemplate = require './template'",
            "title": "Dependencies"
        },
        {
            "location": "/misc/db.coffee/",
            "text": "Misc DB\n\n\nEscape\n\n\nEscape SQL for Bash processing.\n\n\nmodule.exports.escape = (sql) ->\n  sql.replace /[\\\\\"]/g, \"\\\\$&\"\n\n\n\nBuild a Unix command\n\n\nmodule.exports.cmd = (opts...) ->\n  properties = ['engine', 'cmd', 'admin_username', 'admin_password', 'username', 'password', 'host', 'database','silent']\n  options = {}\n  for opt in opts\n    opt = cmd: opt if typeof opt is 'string'\n    for k, v of opt\n      continue unless k in properties\n      options[k] = v\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  options.engine = options.engine.toLowerCase()\n  options.admin_password = null unless options.admin_username\n  options.silent ?= true\n  throw Error 'Required Option: \"engine\"' unless options.engine\n  throw Error 'Required Option: \"host\"' unless options.host\n  if options.admin_username\n    throw Error 'Required Option: \"admin_password\"' unless options.admin_password\n    username = options.admin_username\n    password = options.admin_password\n  else if options.username\n    throw Error 'Required Option: \"password\"' unless options.password\n    username = options.username\n    password = options.password\n  else throw Error 'Required Option: \"admin_username\" or \"username\"'\n  switch options.engine\n    when 'mariadb', 'mysql'\n      options.path ?= 'mysql'\n      options.port ?= '3306'\n      [\n        \"mysql\"\n        \"-h#{options.host}\"\n        \"-P#{options.port}\"\n        \"-u#{username}\"\n        \"-p'#{password}'\"\n        \"-D#{options.database}\" if options.database\n        \"#{options.mysql_options}\" if options.mysql_options\n        # -N, --skip-column-names   Don't write column names in results.\n        # -s, --silent              Be more silent. Print results with a tab as separator, each row on new line.\n        # -r, --raw                 Write fields without conversion. Used with --batch.\n        \"-N -s -r\" if options.silent\n        \"-e \\\"#{module.exports.escape options.cmd}\\\"\" if options.cmd\n      ].join ' '\n    when 'postgresql'\n      options.path ?= 'psql'\n      options.port ?= '5432'\n      [\n        \"PGPASSWORD=#{options.admin_password or options.password}\"\n        \"psql\"\n        \"-h #{options.host}\"\n        \"-p #{options.port}\"\n        \"-U #{options.admin_username or options.username}\"\n        \"-d #{options.database}\" if options.database\n        \"#{options.postgres_options}\" if options.postgres_options\n        # -t, --tuples-only        Print rows only\n        # -A, --no-align           Unaligned table output mode\n        # -q, --quiet              Run quietly (no messages, only query output)\n        \"-tAq\"\n        \"-c \\\"#{options.cmd}\\\"\" if options.cmd\n      ].join ' '\n    else\n      throw Error \"Unsupported engine: #{JSON.stringify options.engine}\"\n\n\n\nParse JDBC URL\n\n\nEnrich the result of \nurl.parse\n with the \"engine\" and \"db\" properties.\n\n\nExemple:\n\n\nparse 'jdbc:mysql://host1:3306,host2:3306/hive?createDatabaseIfNotExist=true'\n{ engine: 'mysql',\n  addresses:\n   [ { host: 'host1', port: '3306' },\n     { host: 'host2', port: '3306' } ],\n  database: 'hive' }\n\n\n\n\nmodule.exports.jdbc = (jdbc) ->\n  if /^jdbc:mysql:/.test jdbc\n    [_, engine, addresses, database] = /^jdbc:(.*?):\\/+(.*?)\\/(.*?)(\\?(.*)|$)/.exec jdbc\n    addresses = addresses.split(',').map (address) ->\n      [host, port] = address.split ':'\n      host: host, port: port or 3306\n    engine: 'mysql'\n    addresses: addresses\n    database: database\n  else if /^jdbc:postgresql:/.test jdbc\n    [_, engine, addresses, database] = /^jdbc:(.*?):\\/+(.*?)\\/(.*?)(\\?(.*)|$)/.exec jdbc\n    addresses = addresses.split(',').map (address) ->\n      [host, port] = address.split ':'\n      host: host, port: port or 5432\n    engine: 'postgresql'\n    addresses: addresses\n    database: database\n  else\n    throw Error 'Invalid JDBC URL'\n\n\n\nDependencies\n\n\nmisc = require '.'",
            "title": "Db.coffee"
        },
        {
            "location": "/misc/db.coffee/#misc-db",
            "text": "",
            "title": "Misc DB"
        },
        {
            "location": "/misc/db.coffee/#escape",
            "text": "Escape SQL for Bash processing.  module.exports.escape = (sql) ->\n  sql.replace /[\\\\\"]/g, \"\\\\$&\"",
            "title": "Escape"
        },
        {
            "location": "/misc/db.coffee/#build-a-unix-command",
            "text": "module.exports.cmd = (opts...) ->\n  properties = ['engine', 'cmd', 'admin_username', 'admin_password', 'username', 'password', 'host', 'database','silent']\n  options = {}\n  for opt in opts\n    opt = cmd: opt if typeof opt is 'string'\n    for k, v of opt\n      continue unless k in properties\n      options[k] = v\n  # Deprecation\n  if options.engine is 'postgres'\n    console.log 'Deprecated Value: options \"postgres\" is deprecated in favor of \"postgresql\"'\n    options.engine = 'postgresql'\n  options.engine = options.engine.toLowerCase()\n  options.admin_password = null unless options.admin_username\n  options.silent ?= true\n  throw Error 'Required Option: \"engine\"' unless options.engine\n  throw Error 'Required Option: \"host\"' unless options.host\n  if options.admin_username\n    throw Error 'Required Option: \"admin_password\"' unless options.admin_password\n    username = options.admin_username\n    password = options.admin_password\n  else if options.username\n    throw Error 'Required Option: \"password\"' unless options.password\n    username = options.username\n    password = options.password\n  else throw Error 'Required Option: \"admin_username\" or \"username\"'\n  switch options.engine\n    when 'mariadb', 'mysql'\n      options.path ?= 'mysql'\n      options.port ?= '3306'\n      [\n        \"mysql\"\n        \"-h#{options.host}\"\n        \"-P#{options.port}\"\n        \"-u#{username}\"\n        \"-p'#{password}'\"\n        \"-D#{options.database}\" if options.database\n        \"#{options.mysql_options}\" if options.mysql_options\n        # -N, --skip-column-names   Don't write column names in results.\n        # -s, --silent              Be more silent. Print results with a tab as separator, each row on new line.\n        # -r, --raw                 Write fields without conversion. Used with --batch.\n        \"-N -s -r\" if options.silent\n        \"-e \\\"#{module.exports.escape options.cmd}\\\"\" if options.cmd\n      ].join ' '\n    when 'postgresql'\n      options.path ?= 'psql'\n      options.port ?= '5432'\n      [\n        \"PGPASSWORD=#{options.admin_password or options.password}\"\n        \"psql\"\n        \"-h #{options.host}\"\n        \"-p #{options.port}\"\n        \"-U #{options.admin_username or options.username}\"\n        \"-d #{options.database}\" if options.database\n        \"#{options.postgres_options}\" if options.postgres_options\n        # -t, --tuples-only        Print rows only\n        # -A, --no-align           Unaligned table output mode\n        # -q, --quiet              Run quietly (no messages, only query output)\n        \"-tAq\"\n        \"-c \\\"#{options.cmd}\\\"\" if options.cmd\n      ].join ' '\n    else\n      throw Error \"Unsupported engine: #{JSON.stringify options.engine}\"",
            "title": "Build a Unix command"
        },
        {
            "location": "/misc/db.coffee/#parse-jdbc-url",
            "text": "Enrich the result of  url.parse  with the \"engine\" and \"db\" properties.  Exemple:  parse 'jdbc:mysql://host1:3306,host2:3306/hive?createDatabaseIfNotExist=true'\n{ engine: 'mysql',\n  addresses:\n   [ { host: 'host1', port: '3306' },\n     { host: 'host2', port: '3306' } ],\n  database: 'hive' }  module.exports.jdbc = (jdbc) ->\n  if /^jdbc:mysql:/.test jdbc\n    [_, engine, addresses, database] = /^jdbc:(.*?):\\/+(.*?)\\/(.*?)(\\?(.*)|$)/.exec jdbc\n    addresses = addresses.split(',').map (address) ->\n      [host, port] = address.split ':'\n      host: host, port: port or 3306\n    engine: 'mysql'\n    addresses: addresses\n    database: database\n  else if /^jdbc:postgresql:/.test jdbc\n    [_, engine, addresses, database] = /^jdbc:(.*?):\\/+(.*?)\\/(.*?)(\\?(.*)|$)/.exec jdbc\n    addresses = addresses.split(',').map (address) ->\n      [host, port] = address.split ':'\n      host: host, port: port or 5432\n    engine: 'postgresql'\n    addresses: addresses\n    database: database\n  else\n    throw Error 'Invalid JDBC URL'",
            "title": "Parse JDBC URL"
        },
        {
            "location": "/misc/db.coffee/#dependencies",
            "text": "misc = require '.'",
            "title": "Dependencies"
        },
        {
            "location": "/misc/diff.coffee/",
            "text": "Diff\n\n\nReport the difference between 2 strings.\n\n\nmodule.exports = (oldStr, newStr, options) ->\n  oldStr ?= ''\n  newStr ?= ''\n  lines = diff.diffLines oldStr, newStr\n  text = []\n  count_added = count_removed = 0\n  padsize = Math.ceil(lines.length/10)\n  for line in lines\n    continue if line.value is null\n    if not line.added and not line.removed\n      count_added++; count_removed++; continue\n    ls = string.lines line.value\n    if line.added\n      for line in ls\n        count_added++\n        text.push \"#{pad padsize, ''+(count_added)} + #{line}\"\n    else\n      for line in ls\n        count_removed++\n        text.push \"#{pad padsize, ''+(count_removed)} - #{line}\"\n  raw: lines, text: text.map( (t) -> \"#{t}\\n\" ).join('')\n\n\n\nDependencies\n\n\npad = require 'pad'\ndiff = require 'diff'\nstring = require './string'",
            "title": "Diff.coffee"
        },
        {
            "location": "/misc/diff.coffee/#diff",
            "text": "Report the difference between 2 strings.  module.exports = (oldStr, newStr, options) ->\n  oldStr ?= ''\n  newStr ?= ''\n  lines = diff.diffLines oldStr, newStr\n  text = []\n  count_added = count_removed = 0\n  padsize = Math.ceil(lines.length/10)\n  for line in lines\n    continue if line.value is null\n    if not line.added and not line.removed\n      count_added++; count_removed++; continue\n    ls = string.lines line.value\n    if line.added\n      for line in ls\n        count_added++\n        text.push \"#{pad padsize, ''+(count_added)} + #{line}\"\n    else\n      for line in ls\n        count_removed++\n        text.push \"#{pad padsize, ''+(count_removed)} - #{line}\"\n  raw: lines, text: text.map( (t) -> \"#{t}\\n\" ).join('')",
            "title": "Diff"
        },
        {
            "location": "/misc/diff.coffee/#dependencies",
            "text": "pad = require 'pad'\ndiff = require 'diff'\nstring = require './string'",
            "title": "Dependencies"
        },
        {
            "location": "/misc/docker.coffee/",
            "text": "string = require './string'\n\nmodule.exports.options = [\n  'api-cors-header', 'bridge', 'bip', 'debug', 'daemon', \n  'default-gateway', 'default-gateway-v6', 'default-ulimit', 'dns', \n  'dns-search', 'exec-driver', 'exec-opt', 'exec-root', 'fixed-cidr', \n  'fixed-cidr-v6', 'group', 'graph', 'host', 'help', 'icc', \n  'insecure-registry', 'ip', 'ip-forward', 'ip-masq', 'iptables', 'ipv6', \n  'log-level', 'label', 'log-driver', 'log-opt', 'mtu', 'pidfile', \n  'registry-mirror', 'storage-driver', 'selinux-enabled', 'storage-opt', \n  'tls', 'tlscacert', 'tlscert', 'tlskey', 'tlsverify', 'userland-proxy', \n  'version'\n]\nmodule.exports.compose_options = [\n  'file', 'project-name', 'verbose', 'no-ansi', 'version', 'host',\n  # TLS\n  'tls', 'tlscacert', 'tlscert', 'tlskey', 'tlsverify', 'skip-hostname-check',\n  'project-directory'\n]\nmodule.exports.opts = (options) ->\n  opts = for option in module.exports[ unless options.compose then 'options' else 'compose_options' ]\n    value = options[option]\n    continue unless value?\n    value = 'true' if value is true\n    value = 'false' if value is false\n    \"--#{option}=#{value}\"\n  opts.join ' '\n\n###\nBuild the docker command\nAccepted options are referenced in \"module.exports.options\". Also accept \n\"machine\" and \"boot2docker\".\n`compose` option allow to wrap the command for docker-compose instead of docker\n###\nmodule.exports.wrap = (options, cmd) ->\n  docker = {}\n  # options.compose ?= false\n  options.docker ?= {}\n  opts = module.exports.opts options\n  exe = if options.compose then 'bin_compose' else 'bin_docker'\n  \"\"\"\n  export SHELL=/bin/bash\n  export PATH=/opt/local/bin/:/opt/local/sbin/:/usr/local/bin/:/usr/local/sbin/:$PATH\n  bin_boot2docker=$(command -v boot2docker)\n  bin_docker=$(command -v docker)\n  bin_machine=$(command -v docker-machine)\n  bin_compose=$(command -v docker-compose)\n  machine='#{options.machine or ''}'\n  boot2docker='#{if options.boot2docker then '1' else ''}'\n  docker=''\n  if [[ $machine != '' ]] && [ $bin_machine ]; then\n    if [ -z \"#{options.machine or ''}\" ]; then exit 5; fi\n    if docker-machine status \"${machine}\" | egrep 'Stopped|Saved'; then\n      docker-machine start \"${machine}\";\n    fi\n    #docker=\"eval \\\\$(\\\\${bin_machine} env ${machine}) && $#{exe}\"\n    eval \"$(${bin_machine} env ${machine})\"\n  elif [[ $boot2docker != '1' ]] && [  $bin_boot2docker ]; then\n    #docker=\"eval \\\\$(\\\\${bin_boot2docker} shellinit) && $#{exe}\"\n    eval \"$(${bin_boot2docker} shellinit)\"\n  fi\n  $#{exe} #{opts} #{cmd}\n  \"\"\"\n# Reformat error message if any\n# TODO: rename this function as format_error\nmodule.exports.callback = (err, status, stdout, stderr) ->\n  throw Error stderr.trim() if err and string.lines(stderr.trim()).length is 1\n  throw Error stderr.trim().replace 'Error response from daemon: ', '' if err and /^Error response from daemon/.test stderr",
            "title": "Docker.coffee"
        },
        {
            "location": "/misc/krb5.coffee/",
            "text": "Miscellaneous kerberos functions\n\n\nkinit\n\n\nkrb5 = module.exports\n\nmodule.exports.kinit = (options) ->\n  cmd = \"kinit\"\n  if options.keytab is true then \" -k\"\n  else if options.keytab and typeof options.keytab is 'string' then cmd += \" -kt #{options.keytab}\"\n  else if options.password then cmd = \"echo #{options.password} | #{cmd}\"\n  else throw Error \"Incoherent options: expects one of keytab or password\"\n  cmd += \" #{options.principal}\"\n  cmd = krb5.su options, cmd\n\nmodule.exports.su = (options, cmd) ->\n  cmd = \"su - #{options.uid} -c '#{cmd}'\" if options.uid\n  cmd",
            "title": "Krb5.coffee"
        },
        {
            "location": "/misc/krb5.coffee/#miscellaneous-kerberos-functions",
            "text": "",
            "title": "Miscellaneous kerberos functions"
        },
        {
            "location": "/misc/krb5.coffee/#kinit",
            "text": "krb5 = module.exports\n\nmodule.exports.kinit = (options) ->\n  cmd = \"kinit\"\n  if options.keytab is true then \" -k\"\n  else if options.keytab and typeof options.keytab is 'string' then cmd += \" -kt #{options.keytab}\"\n  else if options.password then cmd = \"echo #{options.password} | #{cmd}\"\n  else throw Error \"Incoherent options: expects one of keytab or password\"\n  cmd += \" #{options.principal}\"\n  cmd = krb5.su options, cmd\n\nmodule.exports.su = (options, cmd) ->\n  cmd = \"su - #{options.uid} -c '#{cmd}'\" if options.uid\n  cmd",
            "title": "kinit"
        },
        {
            "location": "/misc/ldap.coffee/",
            "text": "Misc LDAP\n\n\nmodule.exports =\n  acl:\n\n\n\nParse ACLs\n\n\nParse one or multiple \"olcAccess\" entries.\n\n\nExample:\n\n\nldap.acl\n.parse [ '{0}to attrs=userPassword,userPKCS12 by dn.base=\"gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth\" manage by dn.exact=\"cn=nssproxy,ou=users,dc=adaltas,dc=com\" read by self write by anonymous auth by * none' ]\n.should.eql [\n  index: 0\n  to: 'attrs=userPassword,userPKCS12'\n  by: [ 'dn.base=\"gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth\" manage'\n    'dn.exact=\"cn=nssproxy,ou=users,dc=adaltas,dc=com\" read'\n    'self write'\n    'anonymous auth'\n    '* none'\n  ]\n]\n\n\n\n\n    parse: (olcAccesses) ->\n      isArray = Array.isArray olcAccesses\n      olcAccesses = [olcAccesses] unless isArray\n      olcAccesses = for olcAccess, i in olcAccesses\n        match = /^\\{(\\d+)\\}to\\s+(.*?)(\\s*by\\s+|$)(.*)$/.exec olcAccess\n        throw Error 'Invalid olcAccess entry' unless match\n        index: parseInt match[1], 10\n        to: match[2]\n        by: match[4].split /\\s+by\\s+/\n      if isArray then olcAccesses else olcAccesses[0]\n\n\n\nStringify ACLs\n\n\nStringify one or multiple \"olcAccess\" entries.\n\n\n    stringify: (olcAccesses) ->\n      isArray = Array.isArray olcAccesses\n      olcAccesses = [olcAccesses] unless isArray\n      for olcAccess, i in olcAccesses\n        value = \"{#{olcAccess.index}}to #{olcAccess.to}\"\n        for bie in olcAccess.by\n          value += \" by #{bie}\"\n        olcAccesses[i] = value\n      if isArray then olcAccesses else olcAccesses[0]\n\n  index:\n\n\n\nParse Index\n\n\nParse one or multiple \"olcDbIndex\" entries.\n\n\n    parse: (indexes) ->\n      isArray = Array.isArray indexes\n      indexes = [indexes] unless isArray\n      indexes.forEach (index, i) ->\n        indexes = {} if i is 0\n        [k,v] = index.split ' '\n        indexes[k] = v\n      if isArray then indexes else indexes[0]\n\n\n\nStringify Index\n\n\nStringify one or multiple \"olcDbIndex\" entries.\n\n\n    stringify: (indexes) ->\n      isArray = Array.isArray indexes\n      indexes = [indexes] unless isArray\n      indexes = for k, v of indexes\n        \"#{k} #{v}\"\n      if isArray then indexes else indexes[0]",
            "title": "Ldap.coffee"
        },
        {
            "location": "/misc/ldap.coffee/#misc-ldap",
            "text": "module.exports =\n  acl:",
            "title": "Misc LDAP"
        },
        {
            "location": "/misc/ldap.coffee/#parse-acls",
            "text": "Parse one or multiple \"olcAccess\" entries.  Example:  ldap.acl\n.parse [ '{0}to attrs=userPassword,userPKCS12 by dn.base=\"gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth\" manage by dn.exact=\"cn=nssproxy,ou=users,dc=adaltas,dc=com\" read by self write by anonymous auth by * none' ]\n.should.eql [\n  index: 0\n  to: 'attrs=userPassword,userPKCS12'\n  by: [ 'dn.base=\"gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth\" manage'\n    'dn.exact=\"cn=nssproxy,ou=users,dc=adaltas,dc=com\" read'\n    'self write'\n    'anonymous auth'\n    '* none'\n  ]\n]      parse: (olcAccesses) ->\n      isArray = Array.isArray olcAccesses\n      olcAccesses = [olcAccesses] unless isArray\n      olcAccesses = for olcAccess, i in olcAccesses\n        match = /^\\{(\\d+)\\}to\\s+(.*?)(\\s*by\\s+|$)(.*)$/.exec olcAccess\n        throw Error 'Invalid olcAccess entry' unless match\n        index: parseInt match[1], 10\n        to: match[2]\n        by: match[4].split /\\s+by\\s+/\n      if isArray then olcAccesses else olcAccesses[0]",
            "title": "Parse ACLs"
        },
        {
            "location": "/misc/ldap.coffee/#stringify-acls",
            "text": "Stringify one or multiple \"olcAccess\" entries.      stringify: (olcAccesses) ->\n      isArray = Array.isArray olcAccesses\n      olcAccesses = [olcAccesses] unless isArray\n      for olcAccess, i in olcAccesses\n        value = \"{#{olcAccess.index}}to #{olcAccess.to}\"\n        for bie in olcAccess.by\n          value += \" by #{bie}\"\n        olcAccesses[i] = value\n      if isArray then olcAccesses else olcAccesses[0]\n\n  index:",
            "title": "Stringify ACLs"
        },
        {
            "location": "/misc/ldap.coffee/#parse-index",
            "text": "Parse one or multiple \"olcDbIndex\" entries.      parse: (indexes) ->\n      isArray = Array.isArray indexes\n      indexes = [indexes] unless isArray\n      indexes.forEach (index, i) ->\n        indexes = {} if i is 0\n        [k,v] = index.split ' '\n        indexes[k] = v\n      if isArray then indexes else indexes[0]",
            "title": "Parse Index"
        },
        {
            "location": "/misc/ldap.coffee/#stringify-index",
            "text": "Stringify one or multiple \"olcDbIndex\" entries.      stringify: (indexes) ->\n      isArray = Array.isArray indexes\n      indexes = [indexes] unless isArray\n      indexes = for k, v of indexes\n        \"#{k} #{v}\"\n      if isArray then indexes else indexes[0]",
            "title": "Stringify Index"
        },
        {
            "location": "/misc/os.coffee/",
            "text": "Misc OS\n\n\nShell command to print archictecture, OS name and version release to stdout. The\nfollowing plateform are supported:\n\n\n\n\nRH6 (RedHat, CentOS, Oracle)\n\n\nRH7 (RHEL, CentOS, Oracle)\n\n\nUbuntu/Debian\n\n\n\n\nArch Linux\n\n\nmodule.exports = \"\"\"\n  ARCH=$(uname -m | sed 's/x86_//;s/i[3-6]86/32/')\n  # Red Hat and CentOS\n  if [ -f /etc/redhat-release ]; then\n    # CentOS: 'CentOS release 6.8 (Final)'\n    # RedHat: 'Red Hat Enterprise Linux AS release 3 (Taroon)'\n    # Oracle: todo\n    OS=\ncat /etc/redhat-release | sed 's/^\\\\(Red \\\\)\\\\?\\\\([A-Za-z]*\\\\).*/\\\\1\\\\2/'\n\n    VERSION=\ncat /etc/redhat-release | sed 's/.* \\\\([0-9]\\\\)\\\\(\\\\(\\\\.*[0-9]\\\\)*\\\\) .*/\\\\1\\\\2/'\n\n  # Debian and Ubuntu\n  elif [ -f /etc/lsb-release ]; then\n      . /etc/lsb-release\n      OS=$DISTRIB_ID\n      VERSION=$DISTRIB_RELEASE\n  # Arch Linux\n  elif uname -r | egrep 'ARCH$' >/dev/null; then\n      OS=arch\n      VERSION=\nuname -r | sed 's/\\\\(.*\\\\)-ARCH/\\\\1/'\n\n  else\n    exit 2\n  fi\n  OS=\necho $OS | tr '[:upper:]' '[:lower:]'\n\n  echo -n \"$ARCH|$OS|$VERSION\"\n  \"\"\"",
            "title": "Os.coffee"
        },
        {
            "location": "/misc/os.coffee/#misc-os",
            "text": "Shell command to print archictecture, OS name and version release to stdout. The\nfollowing plateform are supported:   RH6 (RedHat, CentOS, Oracle)  RH7 (RHEL, CentOS, Oracle)  Ubuntu/Debian   Arch Linux  module.exports = \"\"\"\n  ARCH=$(uname -m | sed 's/x86_//;s/i[3-6]86/32/')\n  # Red Hat and CentOS\n  if [ -f /etc/redhat-release ]; then\n    # CentOS: 'CentOS release 6.8 (Final)'\n    # RedHat: 'Red Hat Enterprise Linux AS release 3 (Taroon)'\n    # Oracle: todo\n    OS= cat /etc/redhat-release | sed 's/^\\\\(Red \\\\)\\\\?\\\\([A-Za-z]*\\\\).*/\\\\1\\\\2/' \n    VERSION= cat /etc/redhat-release | sed 's/.* \\\\([0-9]\\\\)\\\\(\\\\(\\\\.*[0-9]\\\\)*\\\\) .*/\\\\1\\\\2/' \n  # Debian and Ubuntu\n  elif [ -f /etc/lsb-release ]; then\n      . /etc/lsb-release\n      OS=$DISTRIB_ID\n      VERSION=$DISTRIB_RELEASE\n  # Arch Linux\n  elif uname -r | egrep 'ARCH$' >/dev/null; then\n      OS=arch\n      VERSION= uname -r | sed 's/\\\\(.*\\\\)-ARCH/\\\\1/' \n  else\n    exit 2\n  fi\n  OS= echo $OS | tr '[:upper:]' '[:lower:]' \n  echo -n \"$ARCH|$OS|$VERSION\"\n  \"\"\"",
            "title": "Misc OS"
        },
        {
            "location": "/misc/pidfile_running.coffee/",
            "text": "pidfile_running(ssh, pidfile, callback)\n\n\nCheck if the pid (Process Id) stored inside a file match a running process. Any\nfile referencing a dead process will be removed.\n\n\nThe callback is called with an error and a boolean indicating if the process is\nrunning.\n\n\npidfile_running ssh, pidfile, function(err, running){\n  console.log(err ? err.message : 'Running: '+running);\n}\n\n\n\n\nmodule.exports = (ssh, pidfile, callback) ->\n  throw Error 'Argument \"options\" removed' if arguments.length is 4\n  child = exec ssh, \"\"\"\n  if [ ! -f '#{pidfile}' ]; then exit 1; fi\n  if ! kill -s 0 `cat '#{pidfile}'`; then\n    rm '#{pidfile}';\n    exit 2;\n  fi\n  \"\"\"\n  child.on 'error', callback\n  child.on 'exit', (code) ->\n    callback null, code is 0\n\n\n\nDependencies\n\n\nexec = require 'ssh2-exec'",
            "title": "Pidfile running.coffee"
        },
        {
            "location": "/misc/pidfile_running.coffee/#pidfile_runningssh-pidfile-callback",
            "text": "Check if the pid (Process Id) stored inside a file match a running process. Any\nfile referencing a dead process will be removed.  The callback is called with an error and a boolean indicating if the process is\nrunning.  pidfile_running ssh, pidfile, function(err, running){\n  console.log(err ? err.message : 'Running: '+running);\n}  module.exports = (ssh, pidfile, callback) ->\n  throw Error 'Argument \"options\" removed' if arguments.length is 4\n  child = exec ssh, \"\"\"\n  if [ ! -f '#{pidfile}' ]; then exit 1; fi\n  if ! kill -s 0 `cat '#{pidfile}'`; then\n    rm '#{pidfile}';\n    exit 2;\n  fi\n  \"\"\"\n  child.on 'error', callback\n  child.on 'exit', (code) ->\n    callback null, code is 0",
            "title": "pidfile_running(ssh, pidfile, callback)"
        },
        {
            "location": "/misc/pidfile_running.coffee/#dependencies",
            "text": "exec = require 'ssh2-exec'",
            "title": "Dependencies"
        },
        {
            "location": "/service/assert.coffee/",
            "text": "nikita.service(options, [callback])\n\n\nAssert service information and status.\n\n\nThe option \"action\" takes 3 possible values: \"start\", \"stop\" and \"restart\". A \nservice will only be restarted if it leads to a change of status. Set the value \nto \"['start', 'restart']\" to ensure the service will be always started.\n\n\nOptions\n\n\n\n\narch_chroot\n (boolean|string) \n\n  Run this command inside a root directory with the arc-chroot command or any\n  provided string, require the \"rootdir\" option if activated.\n\n\nname\n (string) \n\n  Package name, required.\n\n\nsrv_name\n (string) \n\n  Name used by the service utility, default to \"name\".\n\n\ninstalled\n \n\n  Assert the package is installeds.\n\n\nrootdir\n (string) \n\n  Path to the mount point corresponding to the root directory, required if\n  the \"arch_chroot\" option is activated.\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering service.install\", level: 'DEBUG', module: 'nikita/lib/service/install'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  options.srv_name ?= options.name\n  options.name = [options.name] if typeof options.name is 'string'\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name\n\n\n\nAssert a Package is installed\n\n\n  @system.execute\n    if: options.installed?\n    cmd: \"\"\"\n    if command -v yum >/dev/null 2>&1; then\n      rpm -qa --qf \"%{NAME}\\n\" | grep '^#{options.name.join '|'}$'\n    elif command -v pacman >/dev/null 2>&1; then\n      pacman -Qqe | grep '^#{options.name.join '|'}$'\n    elif command -v apt-get >/dev/null 2>&1; then\n      dpkg -l | grep \\'^ii\\' | awk \\'{print $2}\\' | grep '^#{options.name.join '|'}$'\n    else\n      echo \"Unsupported Package Manager\" >&2\n      exit 2\n    fi\n    \"\"\"\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n    stdin_log: true\n    stdout_log: false\n    shy: true\n  , (err) ->\n    throw Error \"Unsupported Package Manager\" if err?.code is 2\n    throw Error \"Uninstalled Package: #{options.name}\" if err\n\n\n\nAssert a Service is started or stopped\n\n\nNote, this doesnt check wether a service is installed or not.\n\n\n  @system.execute\n    if: options.started? or options.stopped?\n    cmd: \"\"\"\n      ls \\\n        /lib/systemd/system/*.service \\\n        /etc/systemd/system/*.service \\\n        /etc/rc.d/* \\\n        /etc/init.d/* \\\n        2>/dev/null \\\n      | grep -w \"#{options.srv_name}\" || exit 3\n      if command -v systemctl >/dev/null 2>&1; then\n        systemctl status #{options.srv_name} || exit 3\n      elif command -v service >/dev/null 2>&1; then\n        service #{options.srv_name} status || exit 3\n      else\n        echo \"Unsupported Loader\" >&2\n        exit 2\n      fi\n      \"\"\"\n    code: 0\n    code_skipped: 3\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n  , (err, status) ->\n    throw Error \"Unsupported Loader\" if err?.code is 2\n    return if err\n    if options.started?\n      throw Error \"Service Not Started: #{options.srv_name}\" if options.started and not status\n      throw Error \"Service Started: #{options.srv_name}\" if not options.started and status\n    if options.stopped?\n      throw Error \"Service Not Stopped: #{options.srv_name}\" if options.stopped and status\n      throw Error \"Service Stopped: #{options.srv_name}\" if not options.stopped and not status",
            "title": "Assert.coffee"
        },
        {
            "location": "/service/assert.coffee/#nikitaserviceoptions-callback",
            "text": "Assert service information and status.  The option \"action\" takes 3 possible values: \"start\", \"stop\" and \"restart\". A \nservice will only be restarted if it leads to a change of status. Set the value \nto \"['start', 'restart']\" to ensure the service will be always started.",
            "title": "nikita.service(options, [callback])"
        },
        {
            "location": "/service/assert.coffee/#options",
            "text": "arch_chroot  (boolean|string)  \n  Run this command inside a root directory with the arc-chroot command or any\n  provided string, require the \"rootdir\" option if activated.  name  (string)  \n  Package name, required.  srv_name  (string)  \n  Name used by the service utility, default to \"name\".  installed   \n  Assert the package is installeds.  rootdir  (string)  \n  Path to the mount point corresponding to the root directory, required if\n  the \"arch_chroot\" option is activated.",
            "title": "Options"
        },
        {
            "location": "/service/assert.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering service.install\", level: 'DEBUG', module: 'nikita/lib/service/install'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  options.srv_name ?= options.name\n  options.name = [options.name] if typeof options.name is 'string'\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name",
            "title": "Source Code"
        },
        {
            "location": "/service/assert.coffee/#assert-a-package-is-installed",
            "text": "@system.execute\n    if: options.installed?\n    cmd: \"\"\"\n    if command -v yum >/dev/null 2>&1; then\n      rpm -qa --qf \"%{NAME}\\n\" | grep '^#{options.name.join '|'}$'\n    elif command -v pacman >/dev/null 2>&1; then\n      pacman -Qqe | grep '^#{options.name.join '|'}$'\n    elif command -v apt-get >/dev/null 2>&1; then\n      dpkg -l | grep \\'^ii\\' | awk \\'{print $2}\\' | grep '^#{options.name.join '|'}$'\n    else\n      echo \"Unsupported Package Manager\" >&2\n      exit 2\n    fi\n    \"\"\"\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n    stdin_log: true\n    stdout_log: false\n    shy: true\n  , (err) ->\n    throw Error \"Unsupported Package Manager\" if err?.code is 2\n    throw Error \"Uninstalled Package: #{options.name}\" if err",
            "title": "Assert a Package is installed"
        },
        {
            "location": "/service/assert.coffee/#assert-a-service-is-started-or-stopped",
            "text": "Note, this doesnt check wether a service is installed or not.    @system.execute\n    if: options.started? or options.stopped?\n    cmd: \"\"\"\n      ls \\\n        /lib/systemd/system/*.service \\\n        /etc/systemd/system/*.service \\\n        /etc/rc.d/* \\\n        /etc/init.d/* \\\n        2>/dev/null \\\n      | grep -w \"#{options.srv_name}\" || exit 3\n      if command -v systemctl >/dev/null 2>&1; then\n        systemctl status #{options.srv_name} || exit 3\n      elif command -v service >/dev/null 2>&1; then\n        service #{options.srv_name} status || exit 3\n      else\n        echo \"Unsupported Loader\" >&2\n        exit 2\n      fi\n      \"\"\"\n    code: 0\n    code_skipped: 3\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n  , (err, status) ->\n    throw Error \"Unsupported Loader\" if err?.code is 2\n    return if err\n    if options.started?\n      throw Error \"Service Not Started: #{options.srv_name}\" if options.started and not status\n      throw Error \"Service Started: #{options.srv_name}\" if not options.started and status\n    if options.stopped?\n      throw Error \"Service Not Stopped: #{options.srv_name}\" if options.stopped and status\n      throw Error \"Service Stopped: #{options.srv_name}\" if not options.stopped and not status",
            "title": "Assert a Service is started or stopped"
        },
        {
            "location": "/service/discover.coffee/",
            "text": "nikita.service.discover(options, [callback])\n\n\nDiscover the OS init loader.\nFor now it only supports Centos/Redhat OS in version 6 or 7, Ubuntu.\nStore properties in the nikita store object.\n\n\nOptions\n\n\n\n\nstrict\n (boolean) \n\n  Throw an error if the OS is not supported. false by default.   \n\n\ncache\n \n\n  Disable cache. false by default   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Indicate a change in service such as a change in installation, update, \n  start/stop or startup registration.   \n\n\nloader\n \n\n  the init loader name   \n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  detected = false\n  loader = null\n  options.strict ?= false\n  options.shy ?= true\n  options.cache ?= true\n  @system.execute\n    shy: options.shy\n    unless: @store['nikita:service:loader']?\n    cmd: \"\"\"\n    if command -v systemctl >/dev/null; then exit 1; fi ;\n    if command -v service >/dev/null; then exit 2; fi ;\n    exit 3 ;\n    \"\"\"\n    code: [1, 2]\n    shy: true\n  , (err, status, stdout, stderr, signal) ->\n    throw Error \"Undetected Operating System Loader\" if err?.code is 3 and options.strict\n    loader = switch signal\n      when 1 then 'systemctl'\n      when 2 then 'service'\n    @store['nikita:service:loader'] = options.loader if options.cache\n  @next (err, status) ->\n    loader = @store['nikita:service:loader']? if options.cache and not loader?\n    callback err, status, loader",
            "title": "Discover.coffee"
        },
        {
            "location": "/service/discover.coffee/#nikitaservicediscoveroptions-callback",
            "text": "Discover the OS init loader.\nFor now it only supports Centos/Redhat OS in version 6 or 7, Ubuntu.\nStore properties in the nikita store object.",
            "title": "nikita.service.discover(options, [callback])"
        },
        {
            "location": "/service/discover.coffee/#options",
            "text": "strict  (boolean)  \n  Throw an error if the OS is not supported. false by default.     cache   \n  Disable cache. false by default",
            "title": "Options"
        },
        {
            "location": "/service/discover.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Indicate a change in service such as a change in installation, update, \n  start/stop or startup registration.     loader   \n  the init loader name",
            "title": "Callback parameters"
        },
        {
            "location": "/service/discover.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  detected = false\n  loader = null\n  options.strict ?= false\n  options.shy ?= true\n  options.cache ?= true\n  @system.execute\n    shy: options.shy\n    unless: @store['nikita:service:loader']?\n    cmd: \"\"\"\n    if command -v systemctl >/dev/null; then exit 1; fi ;\n    if command -v service >/dev/null; then exit 2; fi ;\n    exit 3 ;\n    \"\"\"\n    code: [1, 2]\n    shy: true\n  , (err, status, stdout, stderr, signal) ->\n    throw Error \"Undetected Operating System Loader\" if err?.code is 3 and options.strict\n    loader = switch signal\n      when 1 then 'systemctl'\n      when 2 then 'service'\n    @store['nikita:service:loader'] = options.loader if options.cache\n  @next (err, status) ->\n    loader = @store['nikita:service:loader']? if options.cache and not loader?\n    callback err, status, loader",
            "title": "Source Code"
        },
        {
            "location": "/service/index.coffee/",
            "text": "nikita.service(options, [callback])\n\n\nInstall, start/stop/restart and startup a service.\n\n\nThe option \"action\" takes 3 possible values: \"start\", \"stop\" and \"restart\". A \nservice will only be restarted if it leads to a change of status. Set the value \nto \"['start', 'restart']\" to ensure the service will be always started.\n\n\nOptions\n\n\n\n\naction\n (string) \n\n  Execute the service with the provided action argument.\n\n\ncache\n \n\n  Run entirely from system cache to list installed and outdated packages.\n\n\ncacheonly\n (boolean) \n\n  Run the yum command entirely from system cache, don't update cache.\n\n\nchk_name\n (string) \n\n  Name used by the chkconfig utility, default to \"srv_name\" and \"name\".\n\n\ninstalled\n \n\n  Cache a list of installed services. If an object, the service will be\n  installed if a key of the same name exists; if anything else (default), no\n  caching will take place.\n\n\nname\n (string) \n\n  Package name, required unless provided as main argument.\n\n\noutdated\n \n\n  Cache a list of outdated services. If an object, the service will be updated\n  if a key of the same name exists; If true, the option will be converted to\n  an object with all the outdated service names as keys; if anything else\n  (default), no caching will take place.\n\n\nsrv_name\n (string) \n\n  Name used by the service utility, default to \"name\".\n\n\nstartup\n (boolean|string) \n\n  Run service daemon on startup. If true, startup will be set to '2345', use\n  an empty string to not define any run level.\n\n\nyum_name\n (string)\n  Name used by the yum utility, default to \"name\".\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  Indicate a change in service such as a change in installation, update,\n  start/stop or startup registration.\n\n\ninstalled\n \n\n  List of installed services.\n\n\nupdates\n \n\n  List of services to update.\n\n\n\n\nExample\n\n\nrequire('nikita').service([{\n  ssh: ssh,\n  name: 'ganglia-gmetad-3.5.0-99',\n  srv_name: 'gmetad',\n  action: 'stop',\n  startup: false\n},{\n  ssh: ssh,\n  name: 'ganglia-web-3.5.7-99'\n}], function(err, status){\n  console.log(err ? err.message : 'Service status: ' + !!status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering service\", level: 'DEBUG', module: 'nikita/lib/service'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  pkgname = options.yum_name or options.name\n  chkname = options.chk_name or options.srv_name or options.name\n  srvname = options.srv_name or options.chk_name or options.name\n  options.action = options.action.split(',') if typeof options.action is 'string'\n  @service.install\n    name: pkgname\n    cache: options.cache\n    cacheonly: options.cacheonly\n    if: pkgname # option name and yum_name are optional, skill installation if not present\n    installed: options.installed\n    outdated: options.outdated\n  @service.startup\n    name: chkname\n    startup: options.startup\n    if: options.startup?\n  @call\n    if: -> options.action\n  , ->\n    @service.status\n      name: srvname\n      code_started: options.code_started\n      code_stopped: options.code_stopped\n      shy: true\n    @service.start\n      name: srvname\n      if: -> not @status(-1) and 'start' in options.action\n    @service.stop\n      name: srvname\n      if: -> @status(-2) and 'stop' in options.action\n    @service.restart\n      name: srvname\n      if: -> @status(-3) and 'restart' in options.action",
            "title": "Index.coffee"
        },
        {
            "location": "/service/index.coffee/#nikitaserviceoptions-callback",
            "text": "Install, start/stop/restart and startup a service.  The option \"action\" takes 3 possible values: \"start\", \"stop\" and \"restart\". A \nservice will only be restarted if it leads to a change of status. Set the value \nto \"['start', 'restart']\" to ensure the service will be always started.",
            "title": "nikita.service(options, [callback])"
        },
        {
            "location": "/service/index.coffee/#options",
            "text": "action  (string)  \n  Execute the service with the provided action argument.  cache   \n  Run entirely from system cache to list installed and outdated packages.  cacheonly  (boolean)  \n  Run the yum command entirely from system cache, don't update cache.  chk_name  (string)  \n  Name used by the chkconfig utility, default to \"srv_name\" and \"name\".  installed   \n  Cache a list of installed services. If an object, the service will be\n  installed if a key of the same name exists; if anything else (default), no\n  caching will take place.  name  (string)  \n  Package name, required unless provided as main argument.  outdated   \n  Cache a list of outdated services. If an object, the service will be updated\n  if a key of the same name exists; If true, the option will be converted to\n  an object with all the outdated service names as keys; if anything else\n  (default), no caching will take place.  srv_name  (string)  \n  Name used by the service utility, default to \"name\".  startup  (boolean|string)  \n  Run service daemon on startup. If true, startup will be set to '2345', use\n  an empty string to not define any run level.  yum_name  (string)\n  Name used by the yum utility, default to \"name\".",
            "title": "Options"
        },
        {
            "location": "/service/index.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  Indicate a change in service such as a change in installation, update,\n  start/stop or startup registration.  installed   \n  List of installed services.  updates   \n  List of services to update.",
            "title": "Callback parameters"
        },
        {
            "location": "/service/index.coffee/#example",
            "text": "require('nikita').service([{\n  ssh: ssh,\n  name: 'ganglia-gmetad-3.5.0-99',\n  srv_name: 'gmetad',\n  action: 'stop',\n  startup: false\n},{\n  ssh: ssh,\n  name: 'ganglia-web-3.5.7-99'\n}], function(err, status){\n  console.log(err ? err.message : 'Service status: ' + !!status);\n});",
            "title": "Example"
        },
        {
            "location": "/service/index.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering service\", level: 'DEBUG', module: 'nikita/lib/service'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  pkgname = options.yum_name or options.name\n  chkname = options.chk_name or options.srv_name or options.name\n  srvname = options.srv_name or options.chk_name or options.name\n  options.action = options.action.split(',') if typeof options.action is 'string'\n  @service.install\n    name: pkgname\n    cache: options.cache\n    cacheonly: options.cacheonly\n    if: pkgname # option name and yum_name are optional, skill installation if not present\n    installed: options.installed\n    outdated: options.outdated\n  @service.startup\n    name: chkname\n    startup: options.startup\n    if: options.startup?\n  @call\n    if: -> options.action\n  , ->\n    @service.status\n      name: srvname\n      code_started: options.code_started\n      code_stopped: options.code_stopped\n      shy: true\n    @service.start\n      name: srvname\n      if: -> not @status(-1) and 'start' in options.action\n    @service.stop\n      name: srvname\n      if: -> @status(-2) and 'stop' in options.action\n    @service.restart\n      name: srvname\n      if: -> @status(-3) and 'restart' in options.action",
            "title": "Source Code"
        },
        {
            "location": "/service/init.coffee/",
            "text": "nikita.service.init(options, [callback])\n\n\nRender startup script.\nReload the service daemon provider depending on the os.\n\n\nOptions\n\n\n\n\nbackup\n (string|boolean) \n\n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.\n\n\ncontext\n (object) \n\n  The context object used to render the scripts file.\n\n\nengine\n \n\n  Template engine to use. Nunjucks by default.\n\n\nfilters\n (function) \n\n  Filter function to extend the nunjucks engine.\n\n\nlocal\n \n\n  Treat the source as local instead of remote, only apply with \"ssh\"\n  option.\n\n\nname\n (string) \n\n  The name of the destination file. Use the name of the template if missing.\n\n\nskip_empty_lines\n \n\n  Remove empty lines.\n\n\nsource\n (boolean) REQUIRED \n\n  The source of startup script template.\n\n\ntarget\n (string) OPTIONAL \n\n  The destination file. \n/etc/init.d/crond\n or \n/etc/systemd/system/crond.service\n for example.\n  If no provided, nikita put it on the default folder based on the service daemon\n  provider,the OS and use the source filename as the name.\n\n\nuid\n \n\n  File user name or user id.\n\n\ngid\n \n\n  File group name or group id.\n\n\nmode\n \n\n  File mode (permission and sticky bits), default to \n0666\n, in the for of\n  \n{mode: 0o744}\n or \n{mode: \"744\"}\n.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  Indicates if the init script was reloaded.\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering service.init\", level: 'DEBUG', module: 'nikita/lib/service/init'\n  # mandatory options\n  throw Error 'Missing source' unless options.source?\n  options.engine ?= 'nunjunks'\n  options.mode ?= 0o755\n  # check if file is target is directory\n  # detect daemon loader provider to construct target\n  options.name ?= path.basename(options.source).split('.')[0]\n  options.name = path.basename(options.target).split('.service')[0] if options.target?\n  options.target ?= \"/etc/init.d/#{options.name}\"\n  options.context ?= {}\n  @service.discover (err, status, loader) ->\n    options.loader ?= loader\n  # discover loader to put in cache\n    @file.render\n      target: options.target\n      source: options.source\n      mode: options.mode\n      uid: options.uid\n      gid: options.gid\n      backup: options.backup\n      context: options.context\n      local: options.local\n    @system.execute\n      if: -> options.loader is 'systemctl'\n      shy: true\n      cmd: \"\"\"\n        systemctl status #{options.name} 2>\\&1 | egrep \\\n        '(Reason: No such file or directory)|(Unit #{options.name}.service could not be found)|(#{options.name}.service changed on disk)'\n        \"\"\"\n      code_skipped: 1\n    @system.execute\n      if: ->  @status -1\n      cmd: 'systemctl daemon-reload'\n\n\n\nDependencies\n\n\npath = require 'path'",
            "title": "Init.coffee"
        },
        {
            "location": "/service/init.coffee/#nikitaserviceinitoptions-callback",
            "text": "Render startup script.\nReload the service daemon provider depending on the os.",
            "title": "nikita.service.init(options, [callback])"
        },
        {
            "location": "/service/init.coffee/#options",
            "text": "backup  (string|boolean)  \n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.  context  (object)  \n  The context object used to render the scripts file.  engine   \n  Template engine to use. Nunjucks by default.  filters  (function)  \n  Filter function to extend the nunjucks engine.  local   \n  Treat the source as local instead of remote, only apply with \"ssh\"\n  option.  name  (string)  \n  The name of the destination file. Use the name of the template if missing.  skip_empty_lines   \n  Remove empty lines.  source  (boolean) REQUIRED  \n  The source of startup script template.  target  (string) OPTIONAL  \n  The destination file.  /etc/init.d/crond  or  /etc/systemd/system/crond.service  for example.\n  If no provided, nikita put it on the default folder based on the service daemon\n  provider,the OS and use the source filename as the name.  uid   \n  File user name or user id.  gid   \n  File group name or group id.  mode   \n  File mode (permission and sticky bits), default to  0666 , in the for of\n   {mode: 0o744}  or  {mode: \"744\"} .",
            "title": "Options"
        },
        {
            "location": "/service/init.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  Indicates if the init script was reloaded.",
            "title": "Callback parameters"
        },
        {
            "location": "/service/init.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering service.init\", level: 'DEBUG', module: 'nikita/lib/service/init'\n  # mandatory options\n  throw Error 'Missing source' unless options.source?\n  options.engine ?= 'nunjunks'\n  options.mode ?= 0o755\n  # check if file is target is directory\n  # detect daemon loader provider to construct target\n  options.name ?= path.basename(options.source).split('.')[0]\n  options.name = path.basename(options.target).split('.service')[0] if options.target?\n  options.target ?= \"/etc/init.d/#{options.name}\"\n  options.context ?= {}\n  @service.discover (err, status, loader) ->\n    options.loader ?= loader\n  # discover loader to put in cache\n    @file.render\n      target: options.target\n      source: options.source\n      mode: options.mode\n      uid: options.uid\n      gid: options.gid\n      backup: options.backup\n      context: options.context\n      local: options.local\n    @system.execute\n      if: -> options.loader is 'systemctl'\n      shy: true\n      cmd: \"\"\"\n        systemctl status #{options.name} 2>\\&1 | egrep \\\n        '(Reason: No such file or directory)|(Unit #{options.name}.service could not be found)|(#{options.name}.service changed on disk)'\n        \"\"\"\n      code_skipped: 1\n    @system.execute\n      if: ->  @status -1\n      cmd: 'systemctl daemon-reload'",
            "title": "Source Code"
        },
        {
            "location": "/service/init.coffee/#dependencies",
            "text": "path = require 'path'",
            "title": "Dependencies"
        },
        {
            "location": "/service/install.coffee/",
            "text": "nikita.service.install(options, [callback])\n\n\nInstall a service. Yum, Yaourt, Pacman and apt-get are supported.\n\n\nOptions\n\n\n\n\narch_chroot\n (boolean|string) \n\n  Run this command inside a root directory with the arc-chroot command or any\n  provided string, require the \"rootdir\" option if activated.\n\n\ncache\n (boolean) \n\n  Cache the list of installed and outpdated packages.\n\n\ncacheonly\n (boolean) \n\n  Run the yum command entirely from system cache, don't update cache.\n\n\ncode_skipped\n (integer|array) \n\n   Error code to skip when using nikita.service.\n\n\ninstalled\n \n\n  Cache a list of installed services. If an object, the service will be\n  installed if a key of the same name exists; if anything else (default), no\n  caching will take place.\n\n\nname\n (string) \n\n  Package name, required unless provided as main argument.\n\n\noutdated\n \n\n  Cache a list of outdated services. If an object, the service will be updated\n  if a key of the same name exists; If true, the option will be converted to\n  an object with all the outdated service names as keys; if anything else\n  (default), no caching will take place.\n\n\nrootdir\n (string) \n\n  Path to the mount point corresponding to the root directory, required if\n  the \"arch_chroot\" option is activated.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Indicates if the service was installed.   \n\n\n\n\nExample\n\n\nrequire('nikita').service.install({\n  ssh: ssh,\n  name: 'ntp'\n}, function(err, status){\n  console.log(err || \"Package installed: \" + status ? 'yes' : 'no');\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering service.install\", level: 'DEBUG', module: 'nikita/lib/service/install'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  options.installed ?= @store['nikita:execute:installed'] if options.cache\n  options.outpdated ?= @store['nikita:execute:outpdated'] if options.cache\n  cacheonly = if options.cacheonly then '-C' else ''\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name\n  # Start real work\n  options.log message: \"Install service #{options.name}\", level: 'INFO', module: 'nikita/lib/service/install'\n  # List installed packages\n  @system.execute\n    unless: options.installed?\n    cmd: \"\"\"\n    if command -v yum >/dev/null 2>&1; then\n      rpm -qa --qf \"%{NAME}\\n\"\n    elif command -v pacman >/dev/null 2>&1; then\n      pacman -Qqe\n    elif command -v apt-get >/dev/null 2>&1; then\n      dpkg -l | grep \\'^ii\\' | awk \\'{print $2}\\'\n    else\n      echo \"Unsupported Package Manager\" >&2\n      exit 2\n    fi\n    \"\"\"\n    code_skipped: 1\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n    stdin_log: false\n    stdout_log: false\n    shy: true\n  , (err, status, stdout) ->\n    throw Error \"Unsupported Package Manager\" if err?.code is 2\n    throw err if err\n    return unless status\n    options.log message: \"Installed packages retrieved\", level: 'INFO', module: 'nikita/lib/service/install'\n    options.installed = for pkg in string.lines(stdout) then pkg\n  # List packages waiting for update\n  @system.execute\n    unless: options.outpdated?\n    if: -> options.installed.indexOf(options.name) is -1\n    cmd: \"\"\"\n    if command -v yum >/dev/null 2>&1; then\n      yum #{cacheonly} list updates | egrep updates$ | sed 's/\\\\([^\\\\.]*\\\\).*/\\\\1/'\n    elif command -v pacman >/dev/null 2>&1; then\n      pacman -Qu | sed 's/\\\\([^ ]*\\\\).*/\\\\1/'\n    elif command -v apt-get >/dev/null 2>&1; then\n      apt-get -u upgrade --assume-no | grep '^\\\\s' | sed 's/\\\\s/\\\\n/g'\n    else\n      echo \"Unsupported Package Manager\" >&2\n      exit 2\n    fi\n    \"\"\"\n    code_skipped: 1\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n    stdin_log: false\n    stdout_log: false\n    shy: true\n  , (err, status, stdout) ->\n    throw Error \"Unsupported Package Manager\" if err?.code is 2\n    throw err if err\n    return options.outpdated = [] unless status\n    options.log message: \"Outpdated package list retrieved\", level: 'INFO', module: 'nikita/lib/service/install'\n    options.outpdated = string.lines stdout.trim()\n  @system.execute\n    if: -> options.installed.indexOf(options.name) is -1 or options.outpdated.indexOf(options.name) isnt -1\n    cmd: \"\"\"\n    if command -v yum >/dev/null 2>&1; then\n      yum install -y #{cacheonly} #{options.name}\n    elif command -v yaourt >/dev/null 2>&1; then\n      yaourt --noconfirm -S #{options.name}\n    elif command -v pacman >/dev/null 2>&1; then\n      pacman --noconfirm -S #{options.name}\n    elif command -v apt-get >/dev/null 2>&1; then\n      apt-get install -y #{options.name}\n    else\n      echo \"Unsupported Package Manager: yum, pacman, apt-get supported\" >&2\n      exit 2\n    fi\n    \"\"\"\n    code_skipped: options.code_skipped\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n  , (err, status) ->\n    throw Error \"Unsupported Package Manager: yum, yaourt, pacman, apt-get supported\" if err?.code is 2\n    throw err if err\n    options.log if status\n    then message: \"Package \\\"#{options.name}\\\" is installed\", level: 'WARN', module: 'nikita/lib/service/install'\n    else message: \"Package \\\"#{options.name}\\\" is already installed\", level: 'INFO', module: 'nikita/lib/service/install'\n    # Enrich installed array with package name unless already there\n    installedIndex = options.installed.indexOf options.name\n    options.installed.push options.name if installedIndex is -1\n    # Remove package name from outpdated if listed\n    if options.outpdated\n      outpdatedIndex = options.outpdated.indexOf options.name\n      options.outpdated.splice outpdatedIndex, 1 unless outpdatedIndex is -1\n  @call\n    if: options.cache\n    handler: ->\n      options.log message: \"Caching installed on \\\"nikita:execute:installed\\\"\", level: 'INFO', module: 'nikita/lib/service/install'\n      @store['nikita:execute:installed'] = options.installed\n      options.log message: \"Caching outpdated list on \\\"nikita:execute:outpdated\\\"\", level: 'INFO', module: 'nikita/lib/service/install'\n      @store['nikita:execute:outpdated'] = options.outpdated\n\n\n\nDependencies\n\n\nstring = require '../misc/string'",
            "title": "Install.coffee"
        },
        {
            "location": "/service/install.coffee/#nikitaserviceinstalloptions-callback",
            "text": "Install a service. Yum, Yaourt, Pacman and apt-get are supported.",
            "title": "nikita.service.install(options, [callback])"
        },
        {
            "location": "/service/install.coffee/#options",
            "text": "arch_chroot  (boolean|string)  \n  Run this command inside a root directory with the arc-chroot command or any\n  provided string, require the \"rootdir\" option if activated.  cache  (boolean)  \n  Cache the list of installed and outpdated packages.  cacheonly  (boolean)  \n  Run the yum command entirely from system cache, don't update cache.  code_skipped  (integer|array)  \n   Error code to skip when using nikita.service.  installed   \n  Cache a list of installed services. If an object, the service will be\n  installed if a key of the same name exists; if anything else (default), no\n  caching will take place.  name  (string)  \n  Package name, required unless provided as main argument.  outdated   \n  Cache a list of outdated services. If an object, the service will be updated\n  if a key of the same name exists; If true, the option will be converted to\n  an object with all the outdated service names as keys; if anything else\n  (default), no caching will take place.  rootdir  (string)  \n  Path to the mount point corresponding to the root directory, required if\n  the \"arch_chroot\" option is activated.",
            "title": "Options"
        },
        {
            "location": "/service/install.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Indicates if the service was installed.",
            "title": "Callback parameters"
        },
        {
            "location": "/service/install.coffee/#example",
            "text": "require('nikita').service.install({\n  ssh: ssh,\n  name: 'ntp'\n}, function(err, status){\n  console.log(err || \"Package installed: \" + status ? 'yes' : 'no');\n});",
            "title": "Example"
        },
        {
            "location": "/service/install.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering service.install\", level: 'DEBUG', module: 'nikita/lib/service/install'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  options.installed ?= @store['nikita:execute:installed'] if options.cache\n  options.outpdated ?= @store['nikita:execute:outpdated'] if options.cache\n  cacheonly = if options.cacheonly then '-C' else ''\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name\n  # Start real work\n  options.log message: \"Install service #{options.name}\", level: 'INFO', module: 'nikita/lib/service/install'\n  # List installed packages\n  @system.execute\n    unless: options.installed?\n    cmd: \"\"\"\n    if command -v yum >/dev/null 2>&1; then\n      rpm -qa --qf \"%{NAME}\\n\"\n    elif command -v pacman >/dev/null 2>&1; then\n      pacman -Qqe\n    elif command -v apt-get >/dev/null 2>&1; then\n      dpkg -l | grep \\'^ii\\' | awk \\'{print $2}\\'\n    else\n      echo \"Unsupported Package Manager\" >&2\n      exit 2\n    fi\n    \"\"\"\n    code_skipped: 1\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n    stdin_log: false\n    stdout_log: false\n    shy: true\n  , (err, status, stdout) ->\n    throw Error \"Unsupported Package Manager\" if err?.code is 2\n    throw err if err\n    return unless status\n    options.log message: \"Installed packages retrieved\", level: 'INFO', module: 'nikita/lib/service/install'\n    options.installed = for pkg in string.lines(stdout) then pkg\n  # List packages waiting for update\n  @system.execute\n    unless: options.outpdated?\n    if: -> options.installed.indexOf(options.name) is -1\n    cmd: \"\"\"\n    if command -v yum >/dev/null 2>&1; then\n      yum #{cacheonly} list updates | egrep updates$ | sed 's/\\\\([^\\\\.]*\\\\).*/\\\\1/'\n    elif command -v pacman >/dev/null 2>&1; then\n      pacman -Qu | sed 's/\\\\([^ ]*\\\\).*/\\\\1/'\n    elif command -v apt-get >/dev/null 2>&1; then\n      apt-get -u upgrade --assume-no | grep '^\\\\s' | sed 's/\\\\s/\\\\n/g'\n    else\n      echo \"Unsupported Package Manager\" >&2\n      exit 2\n    fi\n    \"\"\"\n    code_skipped: 1\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n    stdin_log: false\n    stdout_log: false\n    shy: true\n  , (err, status, stdout) ->\n    throw Error \"Unsupported Package Manager\" if err?.code is 2\n    throw err if err\n    return options.outpdated = [] unless status\n    options.log message: \"Outpdated package list retrieved\", level: 'INFO', module: 'nikita/lib/service/install'\n    options.outpdated = string.lines stdout.trim()\n  @system.execute\n    if: -> options.installed.indexOf(options.name) is -1 or options.outpdated.indexOf(options.name) isnt -1\n    cmd: \"\"\"\n    if command -v yum >/dev/null 2>&1; then\n      yum install -y #{cacheonly} #{options.name}\n    elif command -v yaourt >/dev/null 2>&1; then\n      yaourt --noconfirm -S #{options.name}\n    elif command -v pacman >/dev/null 2>&1; then\n      pacman --noconfirm -S #{options.name}\n    elif command -v apt-get >/dev/null 2>&1; then\n      apt-get install -y #{options.name}\n    else\n      echo \"Unsupported Package Manager: yum, pacman, apt-get supported\" >&2\n      exit 2\n    fi\n    \"\"\"\n    code_skipped: options.code_skipped\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n  , (err, status) ->\n    throw Error \"Unsupported Package Manager: yum, yaourt, pacman, apt-get supported\" if err?.code is 2\n    throw err if err\n    options.log if status\n    then message: \"Package \\\"#{options.name}\\\" is installed\", level: 'WARN', module: 'nikita/lib/service/install'\n    else message: \"Package \\\"#{options.name}\\\" is already installed\", level: 'INFO', module: 'nikita/lib/service/install'\n    # Enrich installed array with package name unless already there\n    installedIndex = options.installed.indexOf options.name\n    options.installed.push options.name if installedIndex is -1\n    # Remove package name from outpdated if listed\n    if options.outpdated\n      outpdatedIndex = options.outpdated.indexOf options.name\n      options.outpdated.splice outpdatedIndex, 1 unless outpdatedIndex is -1\n  @call\n    if: options.cache\n    handler: ->\n      options.log message: \"Caching installed on \\\"nikita:execute:installed\\\"\", level: 'INFO', module: 'nikita/lib/service/install'\n      @store['nikita:execute:installed'] = options.installed\n      options.log message: \"Caching outpdated list on \\\"nikita:execute:outpdated\\\"\", level: 'INFO', module: 'nikita/lib/service/install'\n      @store['nikita:execute:outpdated'] = options.outpdated",
            "title": "Source Code"
        },
        {
            "location": "/service/install.coffee/#dependencies",
            "text": "string = require '../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/service/remove.coffee/",
            "text": "nikita.service.remove(options, [callback])\n\n\nStatus of a service.\n\n\nOptions\n\n\n\n\ncacheonly\n (boolean) \n\n  Run the yum command entirely from system cache, don't update cache.   \n\n\nname\n (string) \n\n  Service name.   \n\n\nssh\n (object|ssh2) \n\n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Indicates if the startup behavior has changed.   \n\n\n\n\nExample\n\n\nrequire('nikita').service.start([{\n  ssh: ssh,\n  name: 'gmetad'\n}, function(err, status){ /* do sth */ });\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering service.remove\", level: 'DEBUG', module: 'nikita/lib/service/remove'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  options.manager ?= @store['nikita:service:manager']\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name\n  # Action\n  options.log message: \"Remove service #{options.name}\", level: 'INFO', module: 'nikita/lib/service/remove'\n  cacheonly = if options.cacheonly then '-C' else ''\n  if options.cache\n    installed = @store['nikita:execute:installed']\n  @system.execute\n    cmd: \"\"\"\n    if command -v yum >/dev/null 2>&1; then\n      rpm -qa --qf \"%{NAME}\\n\"\n    elif command -v pacman >/dev/null 2>&1; then\n      pacman -Qqe\n    elif command -v apt-get >/dev/null 2>&1; then\n      dpkg -l | grep \\'^ii\\' | awk \\'{print $2}\\'\n    else\n      echo \"Unsupported Package Manager\" >&2\n      exit 2\n    fi\n    \"\"\"\n    code_skipped: 1\n    stdout_log: false\n    shy: true\n    unless: installed?\n  , (err, status, stdout) ->\n    throw Error \"Unsupported Package Manager\" if err?.code is 2\n    throw err if err\n    return unless status\n    options.log message: \"Installed packages retrieved\", level: 'INFO', module: 'nikita/lib/service/remove'\n    installed = for pkg in string.lines(stdout) then pkg\n  @system.execute\n    cmd: \"\"\"\n    if command -v yum >/dev/null 2>&1; then\n      yum remove -y #{cacheonly} '#{options.name}'\n    elif command -v pacman >/dev/null 2>&1; then\n      pacman --noconfirm -R #{options.name}\n    elif command -v apt-get >/dev/null 2>&1; then\n      apt-get remove -y #{options.name}\n    else\n      echo \"Unsupported Package Manager: yum, pacman, apt-get supported\" >&2\n      exit 2\n    fi\n    \"\"\"\n    code_skipped: 3\n    if: ->\n      installed.indexOf(options.name) isnt -1 \n  , (err, status) ->\n    throw Error \"Invalid Service Name: #{options.name}\" if err\n    # Update list of installed packages\n    installed.splice installed.indexOf(options.name), 1\n    # Log information\n    options.log if status\n    then message: \"Service removed\", level: 'WARN', module: 'nikita/lib/service/remove'\n    else message: \"Service already removed\", level: 'INFO', module: 'nikita/lib/service/remove'\n  @call\n    if: options.cache\n    handler: ->\n      options.log message: \"Caching installed on \\\"nikita:execute:installed\\\"\", level: 'INFO', module: 'nikita/lib/service/remove'\n      @store['nikita:execute:installed'] = installed\n\n\n\nDependencies\n\n\nstring = require '../misc/string'",
            "title": "Remove.coffee"
        },
        {
            "location": "/service/remove.coffee/#nikitaserviceremoveoptions-callback",
            "text": "Status of a service.",
            "title": "nikita.service.remove(options, [callback])"
        },
        {
            "location": "/service/remove.coffee/#options",
            "text": "cacheonly  (boolean)  \n  Run the yum command entirely from system cache, don't update cache.     name  (string)  \n  Service name.     ssh  (object|ssh2)  \n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.",
            "title": "Options"
        },
        {
            "location": "/service/remove.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Indicates if the startup behavior has changed.",
            "title": "Callback parameters"
        },
        {
            "location": "/service/remove.coffee/#example",
            "text": "require('nikita').service.start([{\n  ssh: ssh,\n  name: 'gmetad'\n}, function(err, status){ /* do sth */ });",
            "title": "Example"
        },
        {
            "location": "/service/remove.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering service.remove\", level: 'DEBUG', module: 'nikita/lib/service/remove'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  options.manager ?= @store['nikita:service:manager']\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name\n  # Action\n  options.log message: \"Remove service #{options.name}\", level: 'INFO', module: 'nikita/lib/service/remove'\n  cacheonly = if options.cacheonly then '-C' else ''\n  if options.cache\n    installed = @store['nikita:execute:installed']\n  @system.execute\n    cmd: \"\"\"\n    if command -v yum >/dev/null 2>&1; then\n      rpm -qa --qf \"%{NAME}\\n\"\n    elif command -v pacman >/dev/null 2>&1; then\n      pacman -Qqe\n    elif command -v apt-get >/dev/null 2>&1; then\n      dpkg -l | grep \\'^ii\\' | awk \\'{print $2}\\'\n    else\n      echo \"Unsupported Package Manager\" >&2\n      exit 2\n    fi\n    \"\"\"\n    code_skipped: 1\n    stdout_log: false\n    shy: true\n    unless: installed?\n  , (err, status, stdout) ->\n    throw Error \"Unsupported Package Manager\" if err?.code is 2\n    throw err if err\n    return unless status\n    options.log message: \"Installed packages retrieved\", level: 'INFO', module: 'nikita/lib/service/remove'\n    installed = for pkg in string.lines(stdout) then pkg\n  @system.execute\n    cmd: \"\"\"\n    if command -v yum >/dev/null 2>&1; then\n      yum remove -y #{cacheonly} '#{options.name}'\n    elif command -v pacman >/dev/null 2>&1; then\n      pacman --noconfirm -R #{options.name}\n    elif command -v apt-get >/dev/null 2>&1; then\n      apt-get remove -y #{options.name}\n    else\n      echo \"Unsupported Package Manager: yum, pacman, apt-get supported\" >&2\n      exit 2\n    fi\n    \"\"\"\n    code_skipped: 3\n    if: ->\n      installed.indexOf(options.name) isnt -1 \n  , (err, status) ->\n    throw Error \"Invalid Service Name: #{options.name}\" if err\n    # Update list of installed packages\n    installed.splice installed.indexOf(options.name), 1\n    # Log information\n    options.log if status\n    then message: \"Service removed\", level: 'WARN', module: 'nikita/lib/service/remove'\n    else message: \"Service already removed\", level: 'INFO', module: 'nikita/lib/service/remove'\n  @call\n    if: options.cache\n    handler: ->\n      options.log message: \"Caching installed on \\\"nikita:execute:installed\\\"\", level: 'INFO', module: 'nikita/lib/service/remove'\n      @store['nikita:execute:installed'] = installed",
            "title": "Source Code"
        },
        {
            "location": "/service/remove.coffee/#dependencies",
            "text": "string = require '../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/service/restart.coffee/",
            "text": "nikita.service.restart(options, [callback])\n\n\nStart a service.\n\n\nOptions\n\n\n\n\nname\n (string) \n\n  Service name.   \n\n\nssh\n (object|ssh2) \n\n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.   \n\n\nstdout\n (stream.Writable) \n\n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.   \n\n\nstderr\n (stream.Writable) \n\n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nmodified\n \n\n  Indicates if the startup behavior has changed.   \n\n\n\n\nExample\n\n\nrequire('nikita').service.start([{\n  ssh: ssh,\n  name: 'gmetad'\n}, function(err, status){ /* do sth */ });\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering service.restart\", level: 'DEBUG', module: 'nikita/lib/service/restart'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name\n  # Action\n  options.log message: \"Restart service #{options.name}\", level: 'INFO', module: 'nikita/lib/service/restart'\n  @service.discover (err, status, loader) -> \n    options.loader ?= loader\n  @call ->\n    cmd = switch options.loader\n      when 'systemctl' then \"systemctl restart #{options.name}\"\n      when 'service' then \"service #{options.name} restart\"\n      else throw Error 'Init System not supported'\n    @system.execute\n      cmd: cmd\n    , (err, restarted) ->\n      throw err if err\n      @store[\"nikita.service.#{options.name}.status\"] = 'started' if restarted",
            "title": "Restart.coffee"
        },
        {
            "location": "/service/restart.coffee/#nikitaservicerestartoptions-callback",
            "text": "Start a service.",
            "title": "nikita.service.restart(options, [callback])"
        },
        {
            "location": "/service/restart.coffee/#options",
            "text": "name  (string)  \n  Service name.     ssh  (object|ssh2)  \n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.     stdout  (stream.Writable)  \n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.     stderr  (stream.Writable)  \n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.",
            "title": "Options"
        },
        {
            "location": "/service/restart.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     modified   \n  Indicates if the startup behavior has changed.",
            "title": "Callback parameters"
        },
        {
            "location": "/service/restart.coffee/#example",
            "text": "require('nikita').service.start([{\n  ssh: ssh,\n  name: 'gmetad'\n}, function(err, status){ /* do sth */ });",
            "title": "Example"
        },
        {
            "location": "/service/restart.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering service.restart\", level: 'DEBUG', module: 'nikita/lib/service/restart'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name\n  # Action\n  options.log message: \"Restart service #{options.name}\", level: 'INFO', module: 'nikita/lib/service/restart'\n  @service.discover (err, status, loader) -> \n    options.loader ?= loader\n  @call ->\n    cmd = switch options.loader\n      when 'systemctl' then \"systemctl restart #{options.name}\"\n      when 'service' then \"service #{options.name} restart\"\n      else throw Error 'Init System not supported'\n    @system.execute\n      cmd: cmd\n    , (err, restarted) ->\n      throw err if err\n      @store[\"nikita.service.#{options.name}.status\"] = 'started' if restarted",
            "title": "Source Code"
        },
        {
            "location": "/service/start.coffee/",
            "text": "nikita.service.start(options, [callback])\n\n\nStart a service. Note, does not throw an error if service is not installed.\n\n\nOptions\n\n\n\n\narch_chroot\n (boolean|string) \n\n  Run this command inside a root directory with the arc-chroot command or any \n  provided string, require the \"rootdir\" option if activated.   \n\n\nrootdir\n (string) \n\n  Path to the mount point corresponding to the root directory, required if \n  the \"arch_chroot\" option is activated.   \n\n\nname\n (string) \n\n  Service name.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Indicates if the service was started (\"true\") or if it was already running \n  (\"false\").   \n\n\n\n\nExample\n\n\nrequire('nikita').service.start([{\n  ssh: ssh,\n  name: 'gmetad'\n}, function(err, status){ /* do sth */ });\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering service.start\", level: 'DEBUG', module: 'nikita/lib/service/start'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name\n  # Action\n  @system.execute\n    cmd: \"\"\"\n    ls \\\n      /lib/systemd/system/*.service \\\n      /etc/systemd/system/*.service \\\n      /etc/rc.d/* \\\n      /etc/init.d/* \\\n      2>/dev/null \\\n    | grep -w \"#{options.name}\" || exit 3\n    if command -v systemctl >/dev/null 2>&1; then\n      systemctl status #{options.name} && exit 3\n      systemctl start #{options.name}\n    elif command -v service >/dev/null 2>&1; then\n      service #{options.name} status && exit 3\n      service #{options.name} start\n    else\n      echo \"Unsupported Loader\" >&2\n      exit 2\n    fi\n    \"\"\"\n    code_skipped: 3\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n  , (err, started) ->\n    options.log message: \"Service already started\", level: 'WARN', module: 'nikita/lib/service/start' if not err and not started\n    options.log message: \"Service is started\", level: 'INFO', module: 'nikita/lib/service/start' if not err and started",
            "title": "Start.coffee"
        },
        {
            "location": "/service/start.coffee/#nikitaservicestartoptions-callback",
            "text": "Start a service. Note, does not throw an error if service is not installed.",
            "title": "nikita.service.start(options, [callback])"
        },
        {
            "location": "/service/start.coffee/#options",
            "text": "arch_chroot  (boolean|string)  \n  Run this command inside a root directory with the arc-chroot command or any \n  provided string, require the \"rootdir\" option if activated.     rootdir  (string)  \n  Path to the mount point corresponding to the root directory, required if \n  the \"arch_chroot\" option is activated.     name  (string)  \n  Service name.",
            "title": "Options"
        },
        {
            "location": "/service/start.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Indicates if the service was started (\"true\") or if it was already running \n  (\"false\").",
            "title": "Callback parameters"
        },
        {
            "location": "/service/start.coffee/#example",
            "text": "require('nikita').service.start([{\n  ssh: ssh,\n  name: 'gmetad'\n}, function(err, status){ /* do sth */ });",
            "title": "Example"
        },
        {
            "location": "/service/start.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering service.start\", level: 'DEBUG', module: 'nikita/lib/service/start'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name\n  # Action\n  @system.execute\n    cmd: \"\"\"\n    ls \\\n      /lib/systemd/system/*.service \\\n      /etc/systemd/system/*.service \\\n      /etc/rc.d/* \\\n      /etc/init.d/* \\\n      2>/dev/null \\\n    | grep -w \"#{options.name}\" || exit 3\n    if command -v systemctl >/dev/null 2>&1; then\n      systemctl status #{options.name} && exit 3\n      systemctl start #{options.name}\n    elif command -v service >/dev/null 2>&1; then\n      service #{options.name} status && exit 3\n      service #{options.name} start\n    else\n      echo \"Unsupported Loader\" >&2\n      exit 2\n    fi\n    \"\"\"\n    code_skipped: 3\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n  , (err, started) ->\n    options.log message: \"Service already started\", level: 'WARN', module: 'nikita/lib/service/start' if not err and not started\n    options.log message: \"Service is started\", level: 'INFO', module: 'nikita/lib/service/start' if not err and started",
            "title": "Source Code"
        },
        {
            "location": "/service/startup.coffee/",
            "text": "nikita.service.startup(options, [callback])\n\n\nActivate or desactivate a service on startup.\n\n\nOptions\n\n\n\n\narch_chroot\n (boolean|string) \n\n  Run this command inside a root directory with the arc-chroot command or any \n  provided string, require the \"rootdir\" option if activated.   \n\n\nrootdir\n (string) \n\n  Path to the mount point corresponding to the root directory, required if \n  the \"arch_chroot\" option is activated.   \n\n\ncache\n (boolean) \n\n  Cache service information.   \n\n\nname\n (string) \n\n  Service name, required.   \n\n\nstartup\n (boolean|string)\n  Run service daemon on startup, required. A string represent a list of activated\n  levels, for example '2345' or 'multi-user'. \n\n  An empty string to not define any run level. \n\n  Note: String argument is only used if SysVinit runlevel is installed on \n  the OS (automatically detected by nikita).   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Indicates if the startup behavior has changed.   \n\n\n\n\nExample\n\n\nrequire('nikita').service.startup([{\n  ssh: ssh,\n  name: 'gmetad',\n  startup: false\n}, function(err, modified){ /* do sth */ });\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering service.startup\", level: 'DEBUG', module: 'nikita/lib/service/startup'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  options.startup ?= true\n  options.startup = [options.startup] if Array.isArray options.startup\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name?\n  # Action\n  options.log message: \"Startup service #{options.name}\", level: 'INFO', module: 'nikita/lib/service/startup'\n  @system.execute\n    unless: options.cmd\n    cmd: \"\"\"\n    if command -v systemctl >/dev/null 2>&1; then\n      echo 'systemctl'\n    elif command -v chkconfig >/dev/null 2>&1; then\n      echo 'chkconfig'\n    elif command -v update-rc.d >/dev/null 2>&1; then\n      echo 'update-rc'\n    else\n      echo \"Unsupported Loader\" >&2\n      exit 2\n    fi\n    \"\"\"\n    shy: true\n  , (err, _, stdout) ->\n    throw err if err\n    options.cmd = stdout.trim()\n    throw Error \"Unsupported Loader\" unless options.cmd in ['systemctl', 'chkconfig', 'update-rc']\n  @system.execute\n    if: -> options.cmd is 'systemctl'\n    cmd: \"\"\"\n      startup=#{if options.startup then '1' else ''}\n      if systemctl is-enabled #{options.name}; then\n        [ -z \"$startup\" ] || exit 3\n        echo 'Disable #{options.name}'\n        systemctl disable #{options.name}\n      else\n        [ -z \"$startup\" ] && exit 3\n        echo 'Enable #{options.name}'\n        systemctl enable #{options.name}\n      fi\n      \"\"\"\n    trap: true\n    code_skipped: 3\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n  , (err, status) ->\n    err = Error \"Startup Enable Failed: #{options.name}\" if err and options.startup\n    err = Error \"Startup Disable Failed: #{options.name}\" if err and not options.startup\n    throw err if err\n    message = if options.startup then 'activated' else 'disabled'\n    options.log if status\n    then message: \"Service startup updated: #{message}\", level: 'WARN', module: 'nikita/lib/service/remove'\n    else message: \"Service startup not modified: #{message}\", level: 'INFO', module: 'nikita/lib/service/remove'\n  @call\n    if: -> options.cmd is 'chkconfig'\n  , (_, callback) ->\n    @system.execute\n      if: -> options.cmd is 'chkconfig'\n      cmd: \"chkconfig --list #{options.name}\"\n      code_skipped: 1\n    , (err, registered, stdout, stderr) ->\n      return callback err if err\n      # Invalid service name return code is 0 and message in stderr start by error\n      if /^error/.test stderr\n        options.log message: \"Invalid chkconfig name for \\\"#{options.name}\\\"\", level: 'ERROR', module: 'mecano/lib/service/startup'\n        throw Error \"Invalid chkconfig name for `#{options.name}`\"\n      current_startup = ''\n      if registered\n        for c in stdout.split(' ').pop().trim().split '\\t'\n          [level, status] = c.split ':'\n          current_startup += level if ['on', 'marche'].indexOf(status) > -1\n      return callback() if options.startup is true and current_startup.length\n      return callback() if options.startup is current_startup\n      return callback() if registered and options.startup is false and current_startup is ''\n      @call if: options.startup, ->\n        cmd = \"chkconfig --add #{options.name};\"\n        if typeof options.startup is 'string'\n          startup_on = startup_off = ''\n          for i in [0...6]\n            if options.startup.indexOf(i) isnt -1\n            then startup_on += i\n            else startup_off += i\n          cmd += \"chkconfig --level #{startup_on} #{options.name} on;\" if startup_on\n          cmd += \"chkconfig --level #{startup_off} #{options.name} off;\" if startup_off\n        else\n          cmd += \"chkconfig #{options.name} on;\"\n        @system.execute\n          cmd: cmd\n        , (err) -> callback err, true\n      @call unless: options.startup, ->\n        options.log message: \"Desactivating startup rules\", level: 'DEBUG', module: 'mecano/lib/service/startup'\n        options.log? \"Mecano `service.startup`: s\"\n        # Setting the level to off. An alternative is to delete it: `chkconfig --del #{options.name}`\n        @system.execute\n          cmd: \"chkconfig #{options.name} off\"\n        , (err) -> callback err, true\n  , (err, status) ->\n    throw err if err\n    message = if options.startup then 'activated' else 'disabled'\n    options.log if status\n    then message: \"Service startup updated: #{message}\", level: 'WARN', module: 'nikita/lib/service/startup'\n    else message: \"Service startup not modified: #{message}\", level: 'INFO', module: 'nikita/lib/service/startup'\n  @system.execute\n    if: -> options.cmd is 'update-rc'\n    cmd: \"\"\"\n      startup=#{if options.startup then '1' else ''}\n      if ls /etc/rc*.d/S??#{options.name}; then\n        [ -z \"$startup\" ] || exit 3\n        echo 'Disable #{options.name}'\n        update-rc.d -f #{options.name} disable\n      else\n        [ -z \"$startup\" ] && exit 3\n        echo 'Enable #{options.name}'\n        update-rc.d -f #{options.name} enable\n      fi\n      \"\"\"\n    code_skipped: 3\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n  , (err, status) ->\n    throw err if err\n    message = if options.startup then 'activated' else 'disabled'\n    options.log if status\n    then message: \"Service startup updated: #{message}\", level: 'WARN', module: 'nikita/lib/service/remove'\n    else message: \"Service startup not modified: #{message}\", level: 'INFO', module: 'nikita/lib/service/remove'",
            "title": "Startup.coffee"
        },
        {
            "location": "/service/startup.coffee/#nikitaservicestartupoptions-callback",
            "text": "Activate or desactivate a service on startup.",
            "title": "nikita.service.startup(options, [callback])"
        },
        {
            "location": "/service/startup.coffee/#options",
            "text": "arch_chroot  (boolean|string)  \n  Run this command inside a root directory with the arc-chroot command or any \n  provided string, require the \"rootdir\" option if activated.     rootdir  (string)  \n  Path to the mount point corresponding to the root directory, required if \n  the \"arch_chroot\" option is activated.     cache  (boolean)  \n  Cache service information.     name  (string)  \n  Service name, required.     startup  (boolean|string)\n  Run service daemon on startup, required. A string represent a list of activated\n  levels, for example '2345' or 'multi-user'.  \n  An empty string to not define any run level.  \n  Note: String argument is only used if SysVinit runlevel is installed on \n  the OS (automatically detected by nikita).",
            "title": "Options"
        },
        {
            "location": "/service/startup.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Indicates if the startup behavior has changed.",
            "title": "Callback parameters"
        },
        {
            "location": "/service/startup.coffee/#example",
            "text": "require('nikita').service.startup([{\n  ssh: ssh,\n  name: 'gmetad',\n  startup: false\n}, function(err, modified){ /* do sth */ });",
            "title": "Example"
        },
        {
            "location": "/service/startup.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering service.startup\", level: 'DEBUG', module: 'nikita/lib/service/startup'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  options.startup ?= true\n  options.startup = [options.startup] if Array.isArray options.startup\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name?\n  # Action\n  options.log message: \"Startup service #{options.name}\", level: 'INFO', module: 'nikita/lib/service/startup'\n  @system.execute\n    unless: options.cmd\n    cmd: \"\"\"\n    if command -v systemctl >/dev/null 2>&1; then\n      echo 'systemctl'\n    elif command -v chkconfig >/dev/null 2>&1; then\n      echo 'chkconfig'\n    elif command -v update-rc.d >/dev/null 2>&1; then\n      echo 'update-rc'\n    else\n      echo \"Unsupported Loader\" >&2\n      exit 2\n    fi\n    \"\"\"\n    shy: true\n  , (err, _, stdout) ->\n    throw err if err\n    options.cmd = stdout.trim()\n    throw Error \"Unsupported Loader\" unless options.cmd in ['systemctl', 'chkconfig', 'update-rc']\n  @system.execute\n    if: -> options.cmd is 'systemctl'\n    cmd: \"\"\"\n      startup=#{if options.startup then '1' else ''}\n      if systemctl is-enabled #{options.name}; then\n        [ -z \"$startup\" ] || exit 3\n        echo 'Disable #{options.name}'\n        systemctl disable #{options.name}\n      else\n        [ -z \"$startup\" ] && exit 3\n        echo 'Enable #{options.name}'\n        systemctl enable #{options.name}\n      fi\n      \"\"\"\n    trap: true\n    code_skipped: 3\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n  , (err, status) ->\n    err = Error \"Startup Enable Failed: #{options.name}\" if err and options.startup\n    err = Error \"Startup Disable Failed: #{options.name}\" if err and not options.startup\n    throw err if err\n    message = if options.startup then 'activated' else 'disabled'\n    options.log if status\n    then message: \"Service startup updated: #{message}\", level: 'WARN', module: 'nikita/lib/service/remove'\n    else message: \"Service startup not modified: #{message}\", level: 'INFO', module: 'nikita/lib/service/remove'\n  @call\n    if: -> options.cmd is 'chkconfig'\n  , (_, callback) ->\n    @system.execute\n      if: -> options.cmd is 'chkconfig'\n      cmd: \"chkconfig --list #{options.name}\"\n      code_skipped: 1\n    , (err, registered, stdout, stderr) ->\n      return callback err if err\n      # Invalid service name return code is 0 and message in stderr start by error\n      if /^error/.test stderr\n        options.log message: \"Invalid chkconfig name for \\\"#{options.name}\\\"\", level: 'ERROR', module: 'mecano/lib/service/startup'\n        throw Error \"Invalid chkconfig name for `#{options.name}`\"\n      current_startup = ''\n      if registered\n        for c in stdout.split(' ').pop().trim().split '\\t'\n          [level, status] = c.split ':'\n          current_startup += level if ['on', 'marche'].indexOf(status) > -1\n      return callback() if options.startup is true and current_startup.length\n      return callback() if options.startup is current_startup\n      return callback() if registered and options.startup is false and current_startup is ''\n      @call if: options.startup, ->\n        cmd = \"chkconfig --add #{options.name};\"\n        if typeof options.startup is 'string'\n          startup_on = startup_off = ''\n          for i in [0...6]\n            if options.startup.indexOf(i) isnt -1\n            then startup_on += i\n            else startup_off += i\n          cmd += \"chkconfig --level #{startup_on} #{options.name} on;\" if startup_on\n          cmd += \"chkconfig --level #{startup_off} #{options.name} off;\" if startup_off\n        else\n          cmd += \"chkconfig #{options.name} on;\"\n        @system.execute\n          cmd: cmd\n        , (err) -> callback err, true\n      @call unless: options.startup, ->\n        options.log message: \"Desactivating startup rules\", level: 'DEBUG', module: 'mecano/lib/service/startup'\n        options.log? \"Mecano `service.startup`: s\"\n        # Setting the level to off. An alternative is to delete it: `chkconfig --del #{options.name}`\n        @system.execute\n          cmd: \"chkconfig #{options.name} off\"\n        , (err) -> callback err, true\n  , (err, status) ->\n    throw err if err\n    message = if options.startup then 'activated' else 'disabled'\n    options.log if status\n    then message: \"Service startup updated: #{message}\", level: 'WARN', module: 'nikita/lib/service/startup'\n    else message: \"Service startup not modified: #{message}\", level: 'INFO', module: 'nikita/lib/service/startup'\n  @system.execute\n    if: -> options.cmd is 'update-rc'\n    cmd: \"\"\"\n      startup=#{if options.startup then '1' else ''}\n      if ls /etc/rc*.d/S??#{options.name}; then\n        [ -z \"$startup\" ] || exit 3\n        echo 'Disable #{options.name}'\n        update-rc.d -f #{options.name} disable\n      else\n        [ -z \"$startup\" ] && exit 3\n        echo 'Enable #{options.name}'\n        update-rc.d -f #{options.name} enable\n      fi\n      \"\"\"\n    code_skipped: 3\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n  , (err, status) ->\n    throw err if err\n    message = if options.startup then 'activated' else 'disabled'\n    options.log if status\n    then message: \"Service startup updated: #{message}\", level: 'WARN', module: 'nikita/lib/service/remove'\n    else message: \"Service startup not modified: #{message}\", level: 'INFO', module: 'nikita/lib/service/remove'",
            "title": "Source Code"
        },
        {
            "location": "/service/status.coffee/",
            "text": "nikita.service.status(options, [callback])\n\n\nStatus of a service. Note, does not throw an error if service is not installed.\n\n\nOptions\n\n\n\n\narch_chroot\n (boolean|string) \n\n  Run this command inside a root directory with the arc-chroot command or any \n  provided string, require the \"rootdir\" option if activated.   \n\n\nrootdir\n (string) \n\n  Path to the mount point corresponding to the root directory, required if \n  the \"arch_chroot\" option is activated.   \n\n\nname\n (string) \n\n  Service name.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Indicates if the startup behavior has changed.   \n\n\n\n\nExample\n\n\nrequire('nikita').service.start([{\n  ssh: ssh,\n  name: 'gmetad'\n}, function(err, status){ /* do sth */ });\n\n\n\n\nNotes\n\n\nHistorically, we had the following two options:\n\n\n\n\ncode_started\n (int|string|array) \n\nExpected code(s) returned by the command for STARTED status, int or array of\nint, default to 0.   \n\n\ncode_stopped\n (int|string|array) \n\nExpected code(s) returned by the command for STOPPED status, int or array of \nint, default to 3   \n\n\n\n\nWe might think about re-integrating them.\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering service.status\", level: 'DEBUG', module: 'nikita/lib/service/status'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name\n  # Action\n  options.log message: \"Status for service #{options.name}\", level: 'INFO', module: 'nikita/lib/service/status'\n  @call -> @system.execute\n    cmd: \"\"\"\n      ls \\\n        /lib/systemd/system/*.service \\\n        /etc/systemd/system/*.service \\\n        /etc/rc.d/* \\\n        /etc/init.d/* \\\n        2>/dev/null \\\n      | grep -w \"#{options.name}\" || exit 3\n      if command -v systemctl >/dev/null 2>&1; then\n        systemctl status #{options.name} || exit 3\n      elif command -v service >/dev/null 2>&1; then\n        service #{options.name} status || exit 3\n      else\n        echo \"Unsupported Loader\" >&2\n        exit 2\n      fi\n      \"\"\"\n    code: 0\n    code_skipped: 3\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n  , (err, status) ->\n    throw Error \"Unsupported Loader\" if err?.code is 2\n    return if err\n    options.log message: \"Status for #{options.name} is #{if status then 'started' else 'stoped'}\", level: 'INFO', module: 'nikita/lib/service/status'",
            "title": "Status.coffee"
        },
        {
            "location": "/service/status.coffee/#nikitaservicestatusoptions-callback",
            "text": "Status of a service. Note, does not throw an error if service is not installed.",
            "title": "nikita.service.status(options, [callback])"
        },
        {
            "location": "/service/status.coffee/#options",
            "text": "arch_chroot  (boolean|string)  \n  Run this command inside a root directory with the arc-chroot command or any \n  provided string, require the \"rootdir\" option if activated.     rootdir  (string)  \n  Path to the mount point corresponding to the root directory, required if \n  the \"arch_chroot\" option is activated.     name  (string)  \n  Service name.",
            "title": "Options"
        },
        {
            "location": "/service/status.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Indicates if the startup behavior has changed.",
            "title": "Callback parameters"
        },
        {
            "location": "/service/status.coffee/#example",
            "text": "require('nikita').service.start([{\n  ssh: ssh,\n  name: 'gmetad'\n}, function(err, status){ /* do sth */ });",
            "title": "Example"
        },
        {
            "location": "/service/status.coffee/#notes",
            "text": "Historically, we had the following two options:   code_started  (int|string|array)  \nExpected code(s) returned by the command for STARTED status, int or array of\nint, default to 0.     code_stopped  (int|string|array)  \nExpected code(s) returned by the command for STOPPED status, int or array of \nint, default to 3      We might think about re-integrating them.",
            "title": "Notes"
        },
        {
            "location": "/service/status.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering service.status\", level: 'DEBUG', module: 'nikita/lib/service/status'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name\n  # Action\n  options.log message: \"Status for service #{options.name}\", level: 'INFO', module: 'nikita/lib/service/status'\n  @call -> @system.execute\n    cmd: \"\"\"\n      ls \\\n        /lib/systemd/system/*.service \\\n        /etc/systemd/system/*.service \\\n        /etc/rc.d/* \\\n        /etc/init.d/* \\\n        2>/dev/null \\\n      | grep -w \"#{options.name}\" || exit 3\n      if command -v systemctl >/dev/null 2>&1; then\n        systemctl status #{options.name} || exit 3\n      elif command -v service >/dev/null 2>&1; then\n        service #{options.name} status || exit 3\n      else\n        echo \"Unsupported Loader\" >&2\n        exit 2\n      fi\n      \"\"\"\n    code: 0\n    code_skipped: 3\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n  , (err, status) ->\n    throw Error \"Unsupported Loader\" if err?.code is 2\n    return if err\n    options.log message: \"Status for #{options.name} is #{if status then 'started' else 'stoped'}\", level: 'INFO', module: 'nikita/lib/service/status'",
            "title": "Source Code"
        },
        {
            "location": "/service/stop.coffee/",
            "text": "nikita.service.stop(options, [callback])\n\n\nStart a service. Note, does not throw an error if service is not installed.\n\n\nOptions\n\n\n\n\narch_chroot\n (boolean|string) \n\n  Run this command inside a root directory with the arc-chroot command or any \n  provided string, require the \"rootdir\" option if activated.   \n\n\nrootdir\n (string) \n\n  Path to the mount point corresponding to the root directory, required if \n  the \"arch_chroot\" option is activated.   \n\n\nname\n (string) \n\n  Service name.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Indicates if the service was stopped (\"true\") or if it was already stopped \n  (\"false\").   \n\n\n\n\nExample\n\n\nrequire('nikita').service.stop([{\n  ssh: ssh,\n  name: 'gmetad'\n}, function(err, status){ /* do sth */ });\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering service.stop\", level: 'DEBUG', module: 'nikita/lib/service/stop'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name\n  # Action\n  options.log message: \"Stop service #{options.name}\", level: 'INFO', module: 'nikita/lib/service/stop'\n  @system.execute\n    cmd: \"\"\"\n    ls \\\n      /lib/systemd/system/*.service \\\n      /etc/systemd/system/*.service \\\n      /etc/rc.d/* \\\n      /etc/init.d/* \\\n      2>/dev/null \\\n    | grep -w \"#{options.name}\" || exit 3\n    if command -v systemctl >/dev/null 2>&1; then\n      systemctl status #{options.name} || exit 3\n      systemctl stop #{options.name}\n    elif command -v service >/dev/null 2>&1; then\n      service #{options.name} status || exit 3\n      service #{options.name} stop\n    else\n      echo \"Unsupported Loader\" >&2\n      exit 2\n    fi\n    \"\"\"\n    code_skipped: 3\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n  , (err, status) ->\n    options.log message: \"Service already stopped\", level: 'WARN', module: 'nikita/lib/service/stop' if not err and not status\n    options.log message: \"Service is stopped\", level: 'INFO', module: 'nikita/lib/service/stop' if not err and status",
            "title": "Stop.coffee"
        },
        {
            "location": "/service/stop.coffee/#nikitaservicestopoptions-callback",
            "text": "Start a service. Note, does not throw an error if service is not installed.",
            "title": "nikita.service.stop(options, [callback])"
        },
        {
            "location": "/service/stop.coffee/#options",
            "text": "arch_chroot  (boolean|string)  \n  Run this command inside a root directory with the arc-chroot command or any \n  provided string, require the \"rootdir\" option if activated.     rootdir  (string)  \n  Path to the mount point corresponding to the root directory, required if \n  the \"arch_chroot\" option is activated.     name  (string)  \n  Service name.",
            "title": "Options"
        },
        {
            "location": "/service/stop.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Indicates if the service was stopped (\"true\") or if it was already stopped \n  (\"false\").",
            "title": "Callback parameters"
        },
        {
            "location": "/service/stop.coffee/#example",
            "text": "require('nikita').service.stop([{\n  ssh: ssh,\n  name: 'gmetad'\n}, function(err, status){ /* do sth */ });",
            "title": "Example"
        },
        {
            "location": "/service/stop.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering service.stop\", level: 'DEBUG', module: 'nikita/lib/service/stop'\n  # Options\n  options.name ?= options.argument if typeof options.argument is 'string'\n  # Validation\n  throw Error \"Invalid Name: #{JSON.stringify options.name}\" unless options.name\n  # Action\n  options.log message: \"Stop service #{options.name}\", level: 'INFO', module: 'nikita/lib/service/stop'\n  @system.execute\n    cmd: \"\"\"\n    ls \\\n      /lib/systemd/system/*.service \\\n      /etc/systemd/system/*.service \\\n      /etc/rc.d/* \\\n      /etc/init.d/* \\\n      2>/dev/null \\\n    | grep -w \"#{options.name}\" || exit 3\n    if command -v systemctl >/dev/null 2>&1; then\n      systemctl status #{options.name} || exit 3\n      systemctl stop #{options.name}\n    elif command -v service >/dev/null 2>&1; then\n      service #{options.name} status || exit 3\n      service #{options.name} stop\n    else\n      echo \"Unsupported Loader\" >&2\n      exit 2\n    fi\n    \"\"\"\n    code_skipped: 3\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n  , (err, status) ->\n    options.log message: \"Service already stopped\", level: 'WARN', module: 'nikita/lib/service/stop' if not err and not status\n    options.log message: \"Service is stopped\", level: 'INFO', module: 'nikita/lib/service/stop' if not err and status",
            "title": "Source Code"
        },
        {
            "location": "/ssh/close.coffee/",
            "text": "nikita.ssh.close(options, [callback])\n\n\nClose the existing connection if any.\n\n\nOptions\n\n\nThere are no options.\n\n\nSource code\n\n\nmodule.exports = handler: (options, callback) ->\n  options.log message: \"Entering ssh.close\", level: 'DEBUG', module: 'nikita/lib/ssh/close'\n  return callback() unless @store['nikita:ssh:connection']\n  ssh = @store['nikita:ssh:connection']\n  ssh.end()\n  ssh.on 'error', (err) -> callback err\n  ssh.on 'end', -> callback null, true\n  @store['nikita:ssh:connection'] = undefined",
            "title": "Close.coffee"
        },
        {
            "location": "/ssh/close.coffee/#nikitasshcloseoptions-callback",
            "text": "Close the existing connection if any.",
            "title": "nikita.ssh.close(options, [callback])"
        },
        {
            "location": "/ssh/close.coffee/#options",
            "text": "There are no options.",
            "title": "Options"
        },
        {
            "location": "/ssh/close.coffee/#source-code",
            "text": "module.exports = handler: (options, callback) ->\n  options.log message: \"Entering ssh.close\", level: 'DEBUG', module: 'nikita/lib/ssh/close'\n  return callback() unless @store['nikita:ssh:connection']\n  ssh = @store['nikita:ssh:connection']\n  ssh.end()\n  ssh.on 'error', (err) -> callback err\n  ssh.on 'end', -> callback null, true\n  @store['nikita:ssh:connection'] = undefined",
            "title": "Source code"
        },
        {
            "location": "/ssh/index.coffee/",
            "text": "nikita.ssh(options)\n\n\nGet the ssh connection if any.\n\n\nOptions\n\n\n\n\nssh\n (boolean) \n\n  Return the SSH connection if any and if true, null if false.\n\n\n\n\nSource code\n\n\nmodule.exports = get: true, handler: (options) ->\n  options.ssh ?= options.argument\n  throw Error \"Invalid Option: ssh must be a boolean value or null or undefined, got #{JSON.stringify options.ssh}\" if options.ssh? and not typeof options.ssh is 'boolean'\n  throw Error 'Unavailable Connection: requested to return a SSH connection but none is initialized' if options.ssh is true and not @store['nikita:ssh:connection']\n  return null if options.ssh is false\n  return @store['nikita:ssh:connection']",
            "title": "Index.coffee"
        },
        {
            "location": "/ssh/index.coffee/#nikitasshoptions",
            "text": "Get the ssh connection if any.",
            "title": "nikita.ssh(options)"
        },
        {
            "location": "/ssh/index.coffee/#options",
            "text": "ssh  (boolean)  \n  Return the SSH connection if any and if true, null if false.",
            "title": "Options"
        },
        {
            "location": "/ssh/index.coffee/#source-code",
            "text": "module.exports = get: true, handler: (options) ->\n  options.ssh ?= options.argument\n  throw Error \"Invalid Option: ssh must be a boolean value or null or undefined, got #{JSON.stringify options.ssh}\" if options.ssh? and not typeof options.ssh is 'boolean'\n  throw Error 'Unavailable Connection: requested to return a SSH connection but none is initialized' if options.ssh is true and not @store['nikita:ssh:connection']\n  return null if options.ssh is false\n  return @store['nikita:ssh:connection']",
            "title": "Source code"
        },
        {
            "location": "/ssh/open.coffee/",
            "text": "nikita.ssh.open(options, [callback])\n\n\nInitialize an SSH connection.\n\n\nOptions\n\n\nTakes the same options as the ssh2 module in an underscore form.\n\n\n\n\ncmd\n (string) \n\n  Command used to become the root user on the remote server, default to \"su -\".   \n\n\nprivate_key\n (string) \n\n  Private key for Ryba, optional, default to the value defined by\n  \"bootstrap.private_key_location\".   \n\n\nprivate_key_path\n (string) \n\n  Path where to read the private key for Ryba, default to \"~/.ssh/id_rsa\".   \n\n\npublic_key\n (string) \n\n  Public key associated with the private key.   \n\n\npassword\n (string) \n\n  Password of the user with super user permissions, required if current user \n  running masson doesnt yet have remote access as root.   \n\n\nusername\n (string) \n\n  Username of the user with super user permissions, required if current user \n  running masson doesnt yet have remote access as root.  \n\n\nhost\n (string) \n\n  Hostname or IP address of the remove server.   \n\n\nip\n (string) \n\n  IP address of the remove server, used if \"host\" option isn't defined.   \n\n\nhost\n (string) \n\n  Port of the remove server, default to 22.   \n\n\nroot\n (object)  \n\n  Options passed to \nnikita.ssh.root\n to enable password-less root login.   \n\n\n\n\nSource code\n\n\nmodule.exports = handler: (options) ->\n  options.log message: \"Entering ssh.open\", level: 'DEBUG', module: 'nikita/lib/ssh/open'\n  # SSH options namespace\n  # options.ssh ?= {}\n  options[k] ?= v for k, v of options.ssh or {}\n  options.username ?= 'root'\n  options.host ?= options.ip\n  options.port ?= 22\n  options.private_key ?= null\n  options.private_key_path ?= '~/.ssh/id_rsa'\n  # options.public_key ?= []\n  # options.public_key = [options.public_key] if typeof options.public_key is 'string'\n  options.root ?= {}\n  options.root.host ?= options.ip or options.host\n  options.root.port ?= options.port\n  # Check status\n  return if (\n    @store['nikita:ssh:connection']?.config and\n    @store['nikita:ssh:connection'].config.host is options.host and\n    @store['nikita:ssh:connection'].config.port is options.port and\n    @store['nikita:ssh:connection'].config.username is options.username\n  )\n  # Read private key if option is a path\n  @call unless: options.private_key, (_, callback) ->\n    options.log message: \"Read Private Key from: #{options.private_key_path}\", level: 'DEBUG', module: 'nikita/lib/ssh/open'\n    misc.path.normalize options.private_key_path, (location) =>\n      fs.readFile location, 'ascii', (err, content) =>\n        return callback Error \"Private key doesnt exists: #{JSON.stringify location}\" if err and err.code is 'ENOENT'\n        return callback err if err\n        options.private_key = content\n        callback()\n  # Establish connection\n  @call relax: true, (_, callback) ->\n    options.log message: \"Read Private Key: #{JSON.stringify options.private_key_path}\", level: 'DEBUG', module: 'nikita/lib/ssh/open'\n    connect options, (err, ssh) =>\n      options.log unless err\n      then message: \"Connection is established\", level: 'INFO', module: 'nikita/lib/ssh/open'\n      else message: \"Connection failed\", level: 'WARN', module: 'nikita/lib/ssh/open'\n      @store['nikita:ssh:connection'] = ssh unless err\n      callback err, !!ssh\n  , (err, status) ->\n    @end() unless err\n  # Enable root access\n  @call if: options.root.username, ->\n    options.log message: \"Bootstrap Root Access\", level: 'INFO', module: 'nikita/lib/ssh/open'\n    @ssh.root public_key: options.public_key, options.root\n  @call retry: 3, (_, callback) ->\n    options.log message: \"Establish Connection: attempt after enabling root access\", level: 'DEBUG', module: 'nikita/lib/ssh/open'\n    connect options, (err, ssh) =>\n      @store['nikita:ssh:connection'] = ssh unless err\n      callback err\n\n\n\nDependencies\n\n\nfs = require 'fs'\nmisc = require '../misc'\nconnect = require 'ssh2-connect'",
            "title": "Open.coffee"
        },
        {
            "location": "/ssh/open.coffee/#nikitasshopenoptions-callback",
            "text": "Initialize an SSH connection.",
            "title": "nikita.ssh.open(options, [callback])"
        },
        {
            "location": "/ssh/open.coffee/#options",
            "text": "Takes the same options as the ssh2 module in an underscore form.   cmd  (string)  \n  Command used to become the root user on the remote server, default to \"su -\".     private_key  (string)  \n  Private key for Ryba, optional, default to the value defined by\n  \"bootstrap.private_key_location\".     private_key_path  (string)  \n  Path where to read the private key for Ryba, default to \"~/.ssh/id_rsa\".     public_key  (string)  \n  Public key associated with the private key.     password  (string)  \n  Password of the user with super user permissions, required if current user \n  running masson doesnt yet have remote access as root.     username  (string)  \n  Username of the user with super user permissions, required if current user \n  running masson doesnt yet have remote access as root.    host  (string)  \n  Hostname or IP address of the remove server.     ip  (string)  \n  IP address of the remove server, used if \"host\" option isn't defined.     host  (string)  \n  Port of the remove server, default to 22.     root  (object)   \n  Options passed to  nikita.ssh.root  to enable password-less root login.",
            "title": "Options"
        },
        {
            "location": "/ssh/open.coffee/#source-code",
            "text": "module.exports = handler: (options) ->\n  options.log message: \"Entering ssh.open\", level: 'DEBUG', module: 'nikita/lib/ssh/open'\n  # SSH options namespace\n  # options.ssh ?= {}\n  options[k] ?= v for k, v of options.ssh or {}\n  options.username ?= 'root'\n  options.host ?= options.ip\n  options.port ?= 22\n  options.private_key ?= null\n  options.private_key_path ?= '~/.ssh/id_rsa'\n  # options.public_key ?= []\n  # options.public_key = [options.public_key] if typeof options.public_key is 'string'\n  options.root ?= {}\n  options.root.host ?= options.ip or options.host\n  options.root.port ?= options.port\n  # Check status\n  return if (\n    @store['nikita:ssh:connection']?.config and\n    @store['nikita:ssh:connection'].config.host is options.host and\n    @store['nikita:ssh:connection'].config.port is options.port and\n    @store['nikita:ssh:connection'].config.username is options.username\n  )\n  # Read private key if option is a path\n  @call unless: options.private_key, (_, callback) ->\n    options.log message: \"Read Private Key from: #{options.private_key_path}\", level: 'DEBUG', module: 'nikita/lib/ssh/open'\n    misc.path.normalize options.private_key_path, (location) =>\n      fs.readFile location, 'ascii', (err, content) =>\n        return callback Error \"Private key doesnt exists: #{JSON.stringify location}\" if err and err.code is 'ENOENT'\n        return callback err if err\n        options.private_key = content\n        callback()\n  # Establish connection\n  @call relax: true, (_, callback) ->\n    options.log message: \"Read Private Key: #{JSON.stringify options.private_key_path}\", level: 'DEBUG', module: 'nikita/lib/ssh/open'\n    connect options, (err, ssh) =>\n      options.log unless err\n      then message: \"Connection is established\", level: 'INFO', module: 'nikita/lib/ssh/open'\n      else message: \"Connection failed\", level: 'WARN', module: 'nikita/lib/ssh/open'\n      @store['nikita:ssh:connection'] = ssh unless err\n      callback err, !!ssh\n  , (err, status) ->\n    @end() unless err\n  # Enable root access\n  @call if: options.root.username, ->\n    options.log message: \"Bootstrap Root Access\", level: 'INFO', module: 'nikita/lib/ssh/open'\n    @ssh.root public_key: options.public_key, options.root\n  @call retry: 3, (_, callback) ->\n    options.log message: \"Establish Connection: attempt after enabling root access\", level: 'DEBUG', module: 'nikita/lib/ssh/open'\n    connect options, (err, ssh) =>\n      @store['nikita:ssh:connection'] = ssh unless err\n      callback err",
            "title": "Source code"
        },
        {
            "location": "/ssh/open.coffee/#dependencies",
            "text": "fs = require 'fs'\nmisc = require '../misc'\nconnect = require 'ssh2-connect'",
            "title": "Dependencies"
        },
        {
            "location": "/ssh/root.coffee/",
            "text": "nikita.ssh.root(options, [callback])\n\n\nPrepare the system to receive password-less root login with SSL/TLS keys.\n\n\nPrior executing this handler, a user with appropriate sudo permissions must be \ncreated. The script will use those credentials\nto loggin and will try to become root with the \"sudo\" command. Use the \"cmd\" \nproperty if you must use a different command (such as \"sudo su -\").\n\n\nAdditionnally, it disables SELINUX which require a restart. The restart is \nhandled by Masson and the installation procedure will continue as soon as an \nSSH connection is again available.\n\n\nOptions\n\n\n\n\ncmd\n (string | function) \n\n  Command used to become the root user on the remote server, for exemple \n  \nsu -\n.\n\n\npublic_key\n (string | Buffer) \n\n  Public key added to \"authorized_keys\" to enable the root user.\n\n\npublic_key_path\n (string | Buffer) \n\n  Local path to the public key added to \"authorized_keys\" to enable the root \n  user.\n\n\nusername\n (string) \n\n  Username of the user with sudo permissions to establish the SSH connection.\n\n\npassword\n (string) \n\n  Password of the user with sudo permissions to establish the SSH connection \n  if no private key is provided.\n\n\nprivate_key\n (string) \n\n  Private key of the user with sudo permissions to establish the SSH \n  connection if no password is provided.\n\n\nprivate_key_path\n (string) \n\n  Local path to the private key of the user with sudo permissions to \n  establish the SSH connection if no password is provided.\n\n\nselinux\n (string | boolean) \n\n  Controls the state of SELinux on the system, values are \"enforcing\", \n  \"permissive\", \"disabled\".\n\n\n\n\nExemple\n\n\nrequire('nikita')\n.ssh.root({\n  \"username\": \"vagrant\",\n  \"private_key_path\": \"/Users/wdavidw/.vagrant.d/insecure_private_key\"\n  \"public_key_path\": \"~/.ssh/id_rsa.pub\"\n}, function(err){\n  console.log(err || \"Public key updoaded for root user\");\n});\n\n\n\n\nSource code\n\n\nmodule.exports = handler: (options) ->\n  options.log message: \"Entering ssh.root\", level: 'DEBUG', module: 'nikita/lib/ssh/root'\n  options.host ?= options.ip\n  # options.cmd ?= 'su -'\n  options.username ?= null\n  options.password ?= null\n  options.selinux ?= false\n  options.selinux = 'permissive' if options.selinux is true\n  # Validation\n  throw Error \"Invalid option \\\"selinux\\\": #{options.selinux}\" if options.selinux and options.selinux not in ['enforcing', 'permissive', 'disabled']\n  rebooting = false\n  # Read public key if option is a path\n  @call\n    if: options.public_key_path\n    unless: options.public_key\n  , (_, callback) ->\n    misc.path.normalize options.public_key_path, (location) =>\n      fs.readFile location, 'ascii', (err, content) =>\n        return callback Error \"Private key doesnt exists: #{JSON.stringify location}\" if err and err.code is 'ENOENT'\n        return callback err if err\n        options.public_key = content\n        callback()\n  # Read private key if option is a path\n  @call\n    if: options.private_key_path\n    unless: options.private_key\n  , (_, callback) ->\n    options.log message: \"Read Private Key: #{JSON.stringify options.private_key_path}\", level: 'DEBUG', module: 'nikita/lib/ssh/root'\n    misc.path.normalize options.private_key_path, (location) =>\n      fs.readFile location, 'ascii', (err, content) =>\n        return callback Error \"Private key doesnt exists: #{JSON.stringify location}\" if err and err.code is 'ENOENT'\n        return callback err if err\n        options.private_key = content\n        callback()\n  @call (_, callback) ->\n    options.log message: \"Connecting\", level: 'DEBUG', module: 'nikita/lib/ssh/root'\n    connect options, (err, ssh) ->\n      return callback err if err\n      options.log message: \"Connected\", level: 'INFO', module: 'nikita/lib/ssh/root'\n      cmd = []\n      cmd.push \"\"\"\n      sed -i.back 's/.*PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config;\n      \"\"\"\n      cmd.push \"\"\"\n      mkdir -p /root/.ssh; chmod 700 /root/.ssh;\n      echo '#{options.public_key}' >> /root/.ssh/authorized_keys;\n      \"\"\" if options.public_key\n      cmd.push \"\"\"\n      sed -i.back 's/.*PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config;\n      selinux=\"#{options.selinux or ''}\";\n      if [ -n \"$selinux\" ] && [ -f /etc/selinux/config ] && grep ^SELINUX=\"$selinux\" /etc/selinux/config;\n      then\n        sed -i.back \"s/^SELINUX=enforcing/SELINUX=$selinux/\" /etc/selinux/config;\n        ( reboot )&\n        exit 2;\n      fi;\n      \"\"\"\n      cmd = cmd.join '\\n'\n      if options.username isnt 'root'\n        cmd = cmd.replace /\\n/g, ' '\n        if typeof options.cmd is 'function'\n          cmd = options.cmd cmd\n        else if typeof options.cmd is 'string'\n          cmd = \"#{options.cmd} #{cmd}\"\n        else\n          options.cmd = 'sudo '\n          options.cmd += \"-u #{options.user} \" if options.user\n          options.cmd = \"echo -e \\\"#{options.password}\\\\n\\\" | #{options.cmd} -S \" if options.password\n          options.cmd += \"-- sh -c \\\"#{cmd}\\\"\"\n          cmd = options.cmd\n      options.log message: \"Enable Root Access\", level: 'DEBUG', module: 'nikita/lib/ssh/root'\n      options.log message: cmd, type: 'stdin', module: 'nikita/lib/ssh/root'\n      child = exec\n        ssh: ssh\n        cmd: cmd\n      , (err) ->\n        if err?.code is 2\n          options.log message: \"Root Access Enabled\", level: 'WARN', module: 'nikita/lib/ssh/root'\n          err = null\n          rebooting = true\n        callback err\n      child.stdout.on 'data', (data) ->\n        options.log message: data, type: 'stdout', module: 'nikita/lib/ssh/root'\n      child.stdout.on 'end', (data) ->\n        options.log message: null, type: 'stdout', module: 'nikita/lib/ssh/root'\n      child.stderr.on 'data', (data) ->\n        options.log message: data, type: 'stderr', module: 'nikita/lib/ssh/root'\n      child.stderr.on 'end', (data) ->\n        options.log message: null, type: 'stderr', module: 'nikita/lib/ssh/root'\n  @call retry: true, sleep: 3000, if: (-> rebooting), (_, callback) ->\n    connect options, (err, conn) =>\n      return callback err if err\n      conn.end()\n      conn.on 'error', callback\n      conn.on 'end', callback\n\n\n\nDependencies\n\n\nfs = require 'fs'\nutil = require 'util'\nconnect = require 'ssh2-connect'\nexec = require 'ssh2-exec'\nmisc = require '../misc'",
            "title": "Root.coffee"
        },
        {
            "location": "/ssh/root.coffee/#nikitasshrootoptions-callback",
            "text": "Prepare the system to receive password-less root login with SSL/TLS keys.  Prior executing this handler, a user with appropriate sudo permissions must be \ncreated. The script will use those credentials\nto loggin and will try to become root with the \"sudo\" command. Use the \"cmd\" \nproperty if you must use a different command (such as \"sudo su -\").  Additionnally, it disables SELINUX which require a restart. The restart is \nhandled by Masson and the installation procedure will continue as soon as an \nSSH connection is again available.",
            "title": "nikita.ssh.root(options, [callback])"
        },
        {
            "location": "/ssh/root.coffee/#options",
            "text": "cmd  (string | function)  \n  Command used to become the root user on the remote server, for exemple \n   su - .  public_key  (string | Buffer)  \n  Public key added to \"authorized_keys\" to enable the root user.  public_key_path  (string | Buffer)  \n  Local path to the public key added to \"authorized_keys\" to enable the root \n  user.  username  (string)  \n  Username of the user with sudo permissions to establish the SSH connection.  password  (string)  \n  Password of the user with sudo permissions to establish the SSH connection \n  if no private key is provided.  private_key  (string)  \n  Private key of the user with sudo permissions to establish the SSH \n  connection if no password is provided.  private_key_path  (string)  \n  Local path to the private key of the user with sudo permissions to \n  establish the SSH connection if no password is provided.  selinux  (string | boolean)  \n  Controls the state of SELinux on the system, values are \"enforcing\", \n  \"permissive\", \"disabled\".",
            "title": "Options"
        },
        {
            "location": "/ssh/root.coffee/#exemple",
            "text": "require('nikita')\n.ssh.root({\n  \"username\": \"vagrant\",\n  \"private_key_path\": \"/Users/wdavidw/.vagrant.d/insecure_private_key\"\n  \"public_key_path\": \"~/.ssh/id_rsa.pub\"\n}, function(err){\n  console.log(err || \"Public key updoaded for root user\");\n});",
            "title": "Exemple"
        },
        {
            "location": "/ssh/root.coffee/#source-code",
            "text": "module.exports = handler: (options) ->\n  options.log message: \"Entering ssh.root\", level: 'DEBUG', module: 'nikita/lib/ssh/root'\n  options.host ?= options.ip\n  # options.cmd ?= 'su -'\n  options.username ?= null\n  options.password ?= null\n  options.selinux ?= false\n  options.selinux = 'permissive' if options.selinux is true\n  # Validation\n  throw Error \"Invalid option \\\"selinux\\\": #{options.selinux}\" if options.selinux and options.selinux not in ['enforcing', 'permissive', 'disabled']\n  rebooting = false\n  # Read public key if option is a path\n  @call\n    if: options.public_key_path\n    unless: options.public_key\n  , (_, callback) ->\n    misc.path.normalize options.public_key_path, (location) =>\n      fs.readFile location, 'ascii', (err, content) =>\n        return callback Error \"Private key doesnt exists: #{JSON.stringify location}\" if err and err.code is 'ENOENT'\n        return callback err if err\n        options.public_key = content\n        callback()\n  # Read private key if option is a path\n  @call\n    if: options.private_key_path\n    unless: options.private_key\n  , (_, callback) ->\n    options.log message: \"Read Private Key: #{JSON.stringify options.private_key_path}\", level: 'DEBUG', module: 'nikita/lib/ssh/root'\n    misc.path.normalize options.private_key_path, (location) =>\n      fs.readFile location, 'ascii', (err, content) =>\n        return callback Error \"Private key doesnt exists: #{JSON.stringify location}\" if err and err.code is 'ENOENT'\n        return callback err if err\n        options.private_key = content\n        callback()\n  @call (_, callback) ->\n    options.log message: \"Connecting\", level: 'DEBUG', module: 'nikita/lib/ssh/root'\n    connect options, (err, ssh) ->\n      return callback err if err\n      options.log message: \"Connected\", level: 'INFO', module: 'nikita/lib/ssh/root'\n      cmd = []\n      cmd.push \"\"\"\n      sed -i.back 's/.*PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config;\n      \"\"\"\n      cmd.push \"\"\"\n      mkdir -p /root/.ssh; chmod 700 /root/.ssh;\n      echo '#{options.public_key}' >> /root/.ssh/authorized_keys;\n      \"\"\" if options.public_key\n      cmd.push \"\"\"\n      sed -i.back 's/.*PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config;\n      selinux=\"#{options.selinux or ''}\";\n      if [ -n \"$selinux\" ] && [ -f /etc/selinux/config ] && grep ^SELINUX=\"$selinux\" /etc/selinux/config;\n      then\n        sed -i.back \"s/^SELINUX=enforcing/SELINUX=$selinux/\" /etc/selinux/config;\n        ( reboot )&\n        exit 2;\n      fi;\n      \"\"\"\n      cmd = cmd.join '\\n'\n      if options.username isnt 'root'\n        cmd = cmd.replace /\\n/g, ' '\n        if typeof options.cmd is 'function'\n          cmd = options.cmd cmd\n        else if typeof options.cmd is 'string'\n          cmd = \"#{options.cmd} #{cmd}\"\n        else\n          options.cmd = 'sudo '\n          options.cmd += \"-u #{options.user} \" if options.user\n          options.cmd = \"echo -e \\\"#{options.password}\\\\n\\\" | #{options.cmd} -S \" if options.password\n          options.cmd += \"-- sh -c \\\"#{cmd}\\\"\"\n          cmd = options.cmd\n      options.log message: \"Enable Root Access\", level: 'DEBUG', module: 'nikita/lib/ssh/root'\n      options.log message: cmd, type: 'stdin', module: 'nikita/lib/ssh/root'\n      child = exec\n        ssh: ssh\n        cmd: cmd\n      , (err) ->\n        if err?.code is 2\n          options.log message: \"Root Access Enabled\", level: 'WARN', module: 'nikita/lib/ssh/root'\n          err = null\n          rebooting = true\n        callback err\n      child.stdout.on 'data', (data) ->\n        options.log message: data, type: 'stdout', module: 'nikita/lib/ssh/root'\n      child.stdout.on 'end', (data) ->\n        options.log message: null, type: 'stdout', module: 'nikita/lib/ssh/root'\n      child.stderr.on 'data', (data) ->\n        options.log message: data, type: 'stderr', module: 'nikita/lib/ssh/root'\n      child.stderr.on 'end', (data) ->\n        options.log message: null, type: 'stderr', module: 'nikita/lib/ssh/root'\n  @call retry: true, sleep: 3000, if: (-> rebooting), (_, callback) ->\n    connect options, (err, conn) =>\n      return callback err if err\n      conn.end()\n      conn.on 'error', callback\n      conn.on 'end', callback",
            "title": "Source code"
        },
        {
            "location": "/ssh/root.coffee/#dependencies",
            "text": "fs = require 'fs'\nutil = require 'util'\nconnect = require 'ssh2-connect'\nexec = require 'ssh2-exec'\nmisc = require '../misc'",
            "title": "Dependencies"
        },
        {
            "location": "/system/cgroups.coffee/",
            "text": "nikita.system.cgroups(options, [callback])\n\n\nNikita action to manipulate cgroups. \ncgconfig.conf(5)\n describes the \nconfiguration file used by libcgroup to define control groups, their parameters \nand also mount points.. The configuration file is identitcal on ubuntu, redhat \nand centos.\n\n\nOptions\n\n\n\n\ndefault\n (object) \n\n  The default object of cgconfig file.   \n\n\ngroups\n (dictionnary) \n\n  Object of cgroups to add to cgconfig file.   \n\n\nignore\n (array|string) \n\n  List of group path to ignore. Only used when merging.   \n\n\nmounts\n (array) \n\n  List of mount object to add to cgconfig file.   \n\n\nmerge\n (boolean). \n\n  Default to true. Read the config from cgsnapshot command and merge mounts part\n  of the cgroups.   \n\n\ntarget\n (string). \n\n  The cgconfig configuration file. By default nikita detects provider based on \n  os.   \n\n\n\n\nThe groups object is a dictionnary containing as the key the cgroup name, and \nas a value the cgroup content. The content should contain the following \nproperties.\n\n\n\n\nperm\n (object) \n\n  Object to describe the permission of the owner and the task file.   \n\n\ncontrollers\n (dictionary) \n\n  Object of controller in the cgroup. Controllers can fe of the following \n  type. The key is the name of the controler, and the content are the value \n  of the controller. The controller's name can be of one of \n  (cpuset|cpu|cpuacct|memory|devices|freezer|net_cls|blkio.   \n\n\n\n\nIt accepts also all the \nnikita.file\n options.\n\n\nExample:\n\n\nExample of a group object\n\n\nbibi:\n  perm:\n    admin:\n      uid: 'bibi'\n      gid: 'bibi'\n    task:\n      uid: 'bibi'\n      gid: 'bibi'\n  controllers:\n    cpu:\n      'cpu.rt_period_us': '\"1000000\"'\n      'cpu.rt_runtime_us': '\"0\"'\n      'cpu.cfs_period_us': '\"100000\"'\n\n\n\n\nWhich will result in a file:\n\n\ngroup bibi {\n  perm {\n    admin {\n      uid = bibi;\n      gid = bibi;\n    }\n    task {\n      uid = bibi;\n      gid = bibi;\n    }\n  }\n  cpu {\n    cpu.rt_period_us = \"1000000\";\n    cpu.rt_runtime_us = \"0\";\n    cpu.cfs_period_us = \"100000\";\n  }\n}\n\n\n\n\nSource Code\n\n\nWhen reading the current config, nikita uses cgsnaphsot command in order to \nhave a well formatted file. Nonetheless if docker is installed and started, \ninformations about live containers could be printed, that's why all path under \ndocker/* are ignored.\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering cgroups\", level: 'DEBUG', module: 'nikita/lib/system/cgroups'\n  throw Error 'Missing cgroups content' unless options.groups? or options.mounts? or options.default?\n  options.mounts ?= []\n  options.groups ?= {}\n  options.merge ?= true\n  options.cgconfig = {}\n  options.cgconfig['mounts'] = options.mounts\n  options.cgconfig['groups'] = options.groups\n  options.cgconfig['groups'][''] = options.default if options.default?\n  options.ignore ?= []\n  options.ignore = [options.ignore] unless Array.isArray options.ignore\n  # Detect Os and version\n  @system.execute\n    unless: -> @store['nikita:system:type']? and @store['nikita:system:release']?\n    shy: true\n    cmd: 'cat /etc/system-release'\n    code_skipped: 1\n  , (err, status, stdout, stderr) ->\n    return unless status\n    [line] = string.lines stdout\n    if /CentOS/.test line\n      @store['nikita:system:type'] ?= 'centos'\n      index = line.split(' ').indexOf 'release'\n      @store['nikita:system:release'] ?= line.split(' ')[index+1]\n    if /Red\\sHat/.test line\n      @store['nikita:system:type'] ?= 'redhat'\n      index = line.split(' ').indexOf 'release'\n      @store['nikita:system:release'] ?= line.split(' ')[index+1]\n    throw Error 'Unsupported OS' unless @store['nikita:system:type']?\n  # configure parameters based on previous OS dection\n  @call\n    shy: true\n    if: -> (@store['nikita:system:type'] in ['redhat','centos'])\n  , ->\n    @system.execute\n      cmd: 'cgsnapshot -s 2>&1'\n    , (err, status, stdout, stderr) ->\n      throw err if err\n      cgconfig = misc.cgconfig.parse stdout\n      cgconfig.mounts ?= []\n      cpus = cgconfig.mounts.filter( (mount) -> if mount.type is 'cpu' then return mount)\n      cpuaccts = cgconfig.mounts.filter( (mount) -> if mount.type is 'cpuacct' then return mount)\n      # We choose a path which is mounted by default\n      if not @store['nikita:cgroups:cpu_path']?\n        if cpus.length > 0\n          cpu_path = cpus[0]['path'].split(',')[0]\n          @store['nikita:cgroups:cpu_path'] ?= cpu_path\n        # a arbitrary path is given based on the\n        else\n          switch @store['nikita:system:type']\n            when 'redhat'\n              @store['nikita:cgroups:cpu_path'] ?= '/cgroups/cpu' if @store['nikita:system:release'][0] is '6'\n              @store['nikita:cgroups:cpu_path'] ?= '/sys/fs/cgroup/cpu' if @store['nikita:system:release'][0] is '7'\n            else throw Error \"Nikita does not support cgroups on your OS #{@store['nikita:system:type']}\"\n      if not @store['nikita:cgroups:mount']?\n        @store['nikita:cgroups:mount'] ?= \"#{path.dirname @store['nikita:cgroups:cpu_path']}\"\n      # Running docker containers are remove from cgsnapshot output\n      if options.merge\n        groups = {}\n        for name, group of cgconfig.groups\n          groups[name] = group unless (name.indexOf('docker/') isnt -1) or (name in options.ignore)\n        options.cgconfig.groups = merge groups, options.groups\n        options.cgconfig.mounts.push cgconfig.mounts...\n  @call ->\n    options.target ?= '/etc/cgconfig.conf' if @store['nikita:system:type'] is 'redhat'\n    @file options,\n      content: misc.cgconfig.stringify(options.cgconfig)\n  @next (err, status) -> callback err, status, \n    cpu_path: @store['nikita:cgroups:cpu_path']\n    mount: @store['nikita:cgroups:mount']\n\n\n\nDependencies\n\n\nmisc = require '../misc'\nstring = require '../misc/string'\n{merge} = misc\npath = require 'path'",
            "title": "Cgroups.coffee"
        },
        {
            "location": "/system/cgroups.coffee/#nikitasystemcgroupsoptions-callback",
            "text": "Nikita action to manipulate cgroups.  cgconfig.conf(5)  describes the \nconfiguration file used by libcgroup to define control groups, their parameters \nand also mount points.. The configuration file is identitcal on ubuntu, redhat \nand centos.",
            "title": "nikita.system.cgroups(options, [callback])"
        },
        {
            "location": "/system/cgroups.coffee/#options",
            "text": "default  (object)  \n  The default object of cgconfig file.     groups  (dictionnary)  \n  Object of cgroups to add to cgconfig file.     ignore  (array|string)  \n  List of group path to ignore. Only used when merging.     mounts  (array)  \n  List of mount object to add to cgconfig file.     merge  (boolean).  \n  Default to true. Read the config from cgsnapshot command and merge mounts part\n  of the cgroups.     target  (string).  \n  The cgconfig configuration file. By default nikita detects provider based on \n  os.      The groups object is a dictionnary containing as the key the cgroup name, and \nas a value the cgroup content. The content should contain the following \nproperties.   perm  (object)  \n  Object to describe the permission of the owner and the task file.     controllers  (dictionary)  \n  Object of controller in the cgroup. Controllers can fe of the following \n  type. The key is the name of the controler, and the content are the value \n  of the controller. The controller's name can be of one of \n  (cpuset|cpu|cpuacct|memory|devices|freezer|net_cls|blkio.      It accepts also all the  nikita.file  options.  Example:  Example of a group object  bibi:\n  perm:\n    admin:\n      uid: 'bibi'\n      gid: 'bibi'\n    task:\n      uid: 'bibi'\n      gid: 'bibi'\n  controllers:\n    cpu:\n      'cpu.rt_period_us': '\"1000000\"'\n      'cpu.rt_runtime_us': '\"0\"'\n      'cpu.cfs_period_us': '\"100000\"'  Which will result in a file:  group bibi {\n  perm {\n    admin {\n      uid = bibi;\n      gid = bibi;\n    }\n    task {\n      uid = bibi;\n      gid = bibi;\n    }\n  }\n  cpu {\n    cpu.rt_period_us = \"1000000\";\n    cpu.rt_runtime_us = \"0\";\n    cpu.cfs_period_us = \"100000\";\n  }\n}",
            "title": "Options"
        },
        {
            "location": "/system/cgroups.coffee/#source-code",
            "text": "When reading the current config, nikita uses cgsnaphsot command in order to \nhave a well formatted file. Nonetheless if docker is installed and started, \ninformations about live containers could be printed, that's why all path under \ndocker/* are ignored.  module.exports = (options, callback) ->\n  options.log message: \"Entering cgroups\", level: 'DEBUG', module: 'nikita/lib/system/cgroups'\n  throw Error 'Missing cgroups content' unless options.groups? or options.mounts? or options.default?\n  options.mounts ?= []\n  options.groups ?= {}\n  options.merge ?= true\n  options.cgconfig = {}\n  options.cgconfig['mounts'] = options.mounts\n  options.cgconfig['groups'] = options.groups\n  options.cgconfig['groups'][''] = options.default if options.default?\n  options.ignore ?= []\n  options.ignore = [options.ignore] unless Array.isArray options.ignore\n  # Detect Os and version\n  @system.execute\n    unless: -> @store['nikita:system:type']? and @store['nikita:system:release']?\n    shy: true\n    cmd: 'cat /etc/system-release'\n    code_skipped: 1\n  , (err, status, stdout, stderr) ->\n    return unless status\n    [line] = string.lines stdout\n    if /CentOS/.test line\n      @store['nikita:system:type'] ?= 'centos'\n      index = line.split(' ').indexOf 'release'\n      @store['nikita:system:release'] ?= line.split(' ')[index+1]\n    if /Red\\sHat/.test line\n      @store['nikita:system:type'] ?= 'redhat'\n      index = line.split(' ').indexOf 'release'\n      @store['nikita:system:release'] ?= line.split(' ')[index+1]\n    throw Error 'Unsupported OS' unless @store['nikita:system:type']?\n  # configure parameters based on previous OS dection\n  @call\n    shy: true\n    if: -> (@store['nikita:system:type'] in ['redhat','centos'])\n  , ->\n    @system.execute\n      cmd: 'cgsnapshot -s 2>&1'\n    , (err, status, stdout, stderr) ->\n      throw err if err\n      cgconfig = misc.cgconfig.parse stdout\n      cgconfig.mounts ?= []\n      cpus = cgconfig.mounts.filter( (mount) -> if mount.type is 'cpu' then return mount)\n      cpuaccts = cgconfig.mounts.filter( (mount) -> if mount.type is 'cpuacct' then return mount)\n      # We choose a path which is mounted by default\n      if not @store['nikita:cgroups:cpu_path']?\n        if cpus.length > 0\n          cpu_path = cpus[0]['path'].split(',')[0]\n          @store['nikita:cgroups:cpu_path'] ?= cpu_path\n        # a arbitrary path is given based on the\n        else\n          switch @store['nikita:system:type']\n            when 'redhat'\n              @store['nikita:cgroups:cpu_path'] ?= '/cgroups/cpu' if @store['nikita:system:release'][0] is '6'\n              @store['nikita:cgroups:cpu_path'] ?= '/sys/fs/cgroup/cpu' if @store['nikita:system:release'][0] is '7'\n            else throw Error \"Nikita does not support cgroups on your OS #{@store['nikita:system:type']}\"\n      if not @store['nikita:cgroups:mount']?\n        @store['nikita:cgroups:mount'] ?= \"#{path.dirname @store['nikita:cgroups:cpu_path']}\"\n      # Running docker containers are remove from cgsnapshot output\n      if options.merge\n        groups = {}\n        for name, group of cgconfig.groups\n          groups[name] = group unless (name.indexOf('docker/') isnt -1) or (name in options.ignore)\n        options.cgconfig.groups = merge groups, options.groups\n        options.cgconfig.mounts.push cgconfig.mounts...\n  @call ->\n    options.target ?= '/etc/cgconfig.conf' if @store['nikita:system:type'] is 'redhat'\n    @file options,\n      content: misc.cgconfig.stringify(options.cgconfig)\n  @next (err, status) -> callback err, status, \n    cpu_path: @store['nikita:cgroups:cpu_path']\n    mount: @store['nikita:cgroups:mount']",
            "title": "Source Code"
        },
        {
            "location": "/system/cgroups.coffee/#dependencies",
            "text": "misc = require '../misc'\nstring = require '../misc/string'\n{merge} = misc\npath = require 'path'",
            "title": "Dependencies"
        },
        {
            "location": "/system/chmod.coffee/",
            "text": "nikita.system.chmod(options, [callback])\n\n\nChange the permissions of a file or directory.\n\n\nOptions\n\n\n\n\nmode\n \n\n  Permissions of the file or the parent directory.   \n\n\nstat\n (Stat instance, optional) \n\n  Pass the Stat object relative to the target file or directory, to be\n  used as an optimization.     \n\n\ntarget\n \n\n  Where the file or directory is copied.   \n\n\n\n\nCallback Parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value is \"true\" if file permissions was created or modified.   \n\n\n\n\nExample\n\n\nrequire('nikita').system.chmod({\n  target: '~/my/project',\n  mode: 0o755\n}, function(err, modified){\n  console.log(err ? err.message : 'File was modified: ' + modified);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering chmod\", level: 'DEBUG', module: 'nikita/lib/system/chmod'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Validate parameters\n  throw Error \"Missing target: #{JSON.stringify options.target}\" unless options.target\n  throw Error \"Missing option 'mode'\" unless options.mode\n  @call\n    unless: !!options.stat # Option 'stat' short-circuit\n  , (_, callback) ->\n    options.log message: \"Stat information: \\\"#{options.target}\\\"\", level: 'DEBUG', module: 'nikita/lib/system/chmod'\n    @fs.stat\n      ssh: options.ssh\n      target: options.target\n    , (err, stat) ->\n      options.stat = stat unless err\n      callback err\n  @call (_, callback) ->\n    # Detect changes\n    if misc.mode.compare options.stat.mode, options.mode\n      options.log message: \"Identical permissions on \\\"#{options.target}\\\"\", level: 'INFO', module: 'nikita/lib/system/chmod'\n      return callback()\n    # Apply changes\n    @fs.chmod ssh: options.ssh, target: options.target, mode: options.mode, sudo: options.sudo, (err) ->\n      options.log message: \"Change permissions from \\\"#{options.stat.mode.toString 8}\\\" to \\\"#{options.mode.toString 8}\\\" on \\\"#{options.target}\\\"\", level: 'WARN', module: 'nikita/lib/system/chmod'\n      callback err, true\n\n\n\nDependencies\n\n\nmisc = require '../misc'",
            "title": "Chmod.coffee"
        },
        {
            "location": "/system/chmod.coffee/#nikitasystemchmodoptions-callback",
            "text": "Change the permissions of a file or directory.",
            "title": "nikita.system.chmod(options, [callback])"
        },
        {
            "location": "/system/chmod.coffee/#options",
            "text": "mode   \n  Permissions of the file or the parent directory.     stat  (Stat instance, optional)  \n  Pass the Stat object relative to the target file or directory, to be\n  used as an optimization.       target   \n  Where the file or directory is copied.",
            "title": "Options"
        },
        {
            "location": "/system/chmod.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value is \"true\" if file permissions was created or modified.",
            "title": "Callback Parameters"
        },
        {
            "location": "/system/chmod.coffee/#example",
            "text": "require('nikita').system.chmod({\n  target: '~/my/project',\n  mode: 0o755\n}, function(err, modified){\n  console.log(err ? err.message : 'File was modified: ' + modified);\n});",
            "title": "Example"
        },
        {
            "location": "/system/chmod.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering chmod\", level: 'DEBUG', module: 'nikita/lib/system/chmod'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Validate parameters\n  throw Error \"Missing target: #{JSON.stringify options.target}\" unless options.target\n  throw Error \"Missing option 'mode'\" unless options.mode\n  @call\n    unless: !!options.stat # Option 'stat' short-circuit\n  , (_, callback) ->\n    options.log message: \"Stat information: \\\"#{options.target}\\\"\", level: 'DEBUG', module: 'nikita/lib/system/chmod'\n    @fs.stat\n      ssh: options.ssh\n      target: options.target\n    , (err, stat) ->\n      options.stat = stat unless err\n      callback err\n  @call (_, callback) ->\n    # Detect changes\n    if misc.mode.compare options.stat.mode, options.mode\n      options.log message: \"Identical permissions on \\\"#{options.target}\\\"\", level: 'INFO', module: 'nikita/lib/system/chmod'\n      return callback()\n    # Apply changes\n    @fs.chmod ssh: options.ssh, target: options.target, mode: options.mode, sudo: options.sudo, (err) ->\n      options.log message: \"Change permissions from \\\"#{options.stat.mode.toString 8}\\\" to \\\"#{options.mode.toString 8}\\\" on \\\"#{options.target}\\\"\", level: 'WARN', module: 'nikita/lib/system/chmod'\n      callback err, true",
            "title": "Source Code"
        },
        {
            "location": "/system/chmod.coffee/#dependencies",
            "text": "misc = require '../misc'",
            "title": "Dependencies"
        },
        {
            "location": "/system/chown.coffee/",
            "text": "nikita.system.chown(options, [callback])\n\n\nChange the ownership of a file or a directory.\n\n\nOptions\n\n\n\n\ngid\n \n\n  Group name or id who owns the target file.   \n\n\nstat\n (Stat instance, optional) \n\n  Pass the Stat object relative to the target file or directory, to be\n  used as an optimization, discovered otherwise.   \n\n\ntarget\n \n\n  Where the file or directory is copied.   \n\n\nuid\n \n\n  User name or id who owns the target file.   \n\n\n\n\nCallback Parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value is \"true\" if file ownership was created or modified.   \n\n\n\n\nExample\n\n\nrequire('nikita').system.chown({\n  target: '~/my/project',\n  uid: 'my_user'\n  gid: 'my_group'\n}, function(err, modified){\n  console.log(err ? err.message : 'File was modified: ' + modified);\n});\n\n\n\n\nNote\n\n\nTo list all files owner by a user or a uid, run:\n\n\nfind /var/tmp -user `whoami`\nfind /var/tmp -uid 1000\nfind / -uid $old_uid -print | xargs chown $new_uid:$new_gid\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering chown\", level: 'DEBUG', module: 'nikita/lib/system/chown'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Normalize options\n  options.target = options.argument if options.argument?\n  options.uid = null if options.uid is false\n  options.gid = null if options.gid is false\n  # Validate parameters\n  throw Error \"Missing target option\" unless options.target?\n  throw Error \"Missing one of uid or gid option\" unless options.uid? or options.gid?\n  # Convert user and group names to uid and gid if necessary\n  @system.uid_gid\n    uid: options.uid\n    gid: options.gid\n    shy: true\n  , (err, status, {uid, gid}) ->\n    options.uid = uid\n    options.gid = gid\n  # Use option 'stat' short-circuit or discover\n  @call unless: !!options.stat, (_, callback) ->\n    options.log message: \"Stat #{options.target}\", level: 'DEBUG', module: 'nikita/lib/chown'\n    @fs.stat ssh: options.ssh, target: options.target, (err, stat) ->\n      return callback Error \"Target Does Not Exist: #{JSON.stringify options.target}\" if err?.code is 'ENOENT'\n      return callback err if err\n      options.stat = stat\n      callback()\n  # Detect changes\n  @call (_, callback) ->\n    if (not options.uid? or options.stat.uid is options.uid) and (not options.gid? or options.stat.gid is options.gid)\n      options.log message: \"Matching ownerships on '#{options.target}'\", level: 'INFO', module: 'nikita/lib/chown'\n      return callback()\n    callback null, true\n  # Apply changes\n  @call if: (-> @status -1), (_, callback) ->\n    options.uid ?= options.stat.uid\n    options.gid ?= options.stat.gid\n    @fs.chown ssh: options.ssh, target: options.target, uid: options.uid, gid: options.gid, sudo: options.sudo, (err) ->\n      options.log message: \"change uid from #{options.stat.uid} to #{options.uid}\", level: 'WARN', module: 'nikita/lib/chown' if options.stat.uid is not options.uid\n      options.log message: \"change gid from #{options.stat.gid} to #{options.gid}\", level: 'WARN', module: 'nikita/lib/chown' if options.stat.gid is not options.gid\n      callback err",
            "title": "Chown.coffee"
        },
        {
            "location": "/system/chown.coffee/#nikitasystemchownoptions-callback",
            "text": "Change the ownership of a file or a directory.",
            "title": "nikita.system.chown(options, [callback])"
        },
        {
            "location": "/system/chown.coffee/#options",
            "text": "gid   \n  Group name or id who owns the target file.     stat  (Stat instance, optional)  \n  Pass the Stat object relative to the target file or directory, to be\n  used as an optimization, discovered otherwise.     target   \n  Where the file or directory is copied.     uid   \n  User name or id who owns the target file.",
            "title": "Options"
        },
        {
            "location": "/system/chown.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value is \"true\" if file ownership was created or modified.",
            "title": "Callback Parameters"
        },
        {
            "location": "/system/chown.coffee/#example",
            "text": "require('nikita').system.chown({\n  target: '~/my/project',\n  uid: 'my_user'\n  gid: 'my_group'\n}, function(err, modified){\n  console.log(err ? err.message : 'File was modified: ' + modified);\n});",
            "title": "Example"
        },
        {
            "location": "/system/chown.coffee/#note",
            "text": "To list all files owner by a user or a uid, run:  find /var/tmp -user `whoami`\nfind /var/tmp -uid 1000\nfind / -uid $old_uid -print | xargs chown $new_uid:$new_gid",
            "title": "Note"
        },
        {
            "location": "/system/chown.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering chown\", level: 'DEBUG', module: 'nikita/lib/system/chown'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Normalize options\n  options.target = options.argument if options.argument?\n  options.uid = null if options.uid is false\n  options.gid = null if options.gid is false\n  # Validate parameters\n  throw Error \"Missing target option\" unless options.target?\n  throw Error \"Missing one of uid or gid option\" unless options.uid? or options.gid?\n  # Convert user and group names to uid and gid if necessary\n  @system.uid_gid\n    uid: options.uid\n    gid: options.gid\n    shy: true\n  , (err, status, {uid, gid}) ->\n    options.uid = uid\n    options.gid = gid\n  # Use option 'stat' short-circuit or discover\n  @call unless: !!options.stat, (_, callback) ->\n    options.log message: \"Stat #{options.target}\", level: 'DEBUG', module: 'nikita/lib/chown'\n    @fs.stat ssh: options.ssh, target: options.target, (err, stat) ->\n      return callback Error \"Target Does Not Exist: #{JSON.stringify options.target}\" if err?.code is 'ENOENT'\n      return callback err if err\n      options.stat = stat\n      callback()\n  # Detect changes\n  @call (_, callback) ->\n    if (not options.uid? or options.stat.uid is options.uid) and (not options.gid? or options.stat.gid is options.gid)\n      options.log message: \"Matching ownerships on '#{options.target}'\", level: 'INFO', module: 'nikita/lib/chown'\n      return callback()\n    callback null, true\n  # Apply changes\n  @call if: (-> @status -1), (_, callback) ->\n    options.uid ?= options.stat.uid\n    options.gid ?= options.stat.gid\n    @fs.chown ssh: options.ssh, target: options.target, uid: options.uid, gid: options.gid, sudo: options.sudo, (err) ->\n      options.log message: \"change uid from #{options.stat.uid} to #{options.uid}\", level: 'WARN', module: 'nikita/lib/chown' if options.stat.uid is not options.uid\n      options.log message: \"change gid from #{options.stat.gid} to #{options.gid}\", level: 'WARN', module: 'nikita/lib/chown' if options.stat.gid is not options.gid\n      callback err",
            "title": "Source Code"
        },
        {
            "location": "/system/copy.coffee/",
            "text": "nikita.system.copy(options, [callback])\n\n\nCopy a file. The behavior is similar to the one of the \ncp\n\nUnix utility. Copying a file over an existing file will\noverwrite it.\n\n\nOptions\n\n\n\n\ngid\n \n\n  Group name or id who owns the file.   \n\n\nmode\n \n\n  Permissions of the file or the parent directory.   \n\n\nparent\n (boolean|object) \n\n  Create parent directory with provided attributes if an object or default \n  system options if \"true\", supported attributes include 'mode', 'uid', 'gid', \n  'size', 'atime', and 'mtime'.   \n\n\npreserve\n \n\n  Preserve file ownerships and permissions, default to \"false\".\n\n\nsource\n \n\n  The file or directory to copy.   \n\n\nsource_stats\n \n\n  Short-circuit to prevent source stat retrieval if already at our disposal.   \n\n\ntarget\n \n\n  Where the file or directory is copied.   \n\n\ntarget_stats\n \n\n  Short-circuit to prevent target stat retrieval if already at our disposal.   \n\n\nuid\n \n\n  User name or id who owns the file.   \n\n\n\n\nCallback Parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value is \"true\" if copied file was created or modified.   \n\n\n\n\nTodo\n\n\n\n\nApply permissions to directories\n\n\nHandle symlinks\n\n\nHandle globing\n\n\nPreserve permissions if \nmode\n is \ntrue\n\n\n\n\nExample\n\n\nrequire('nikita').system.copy({\n  source: '/etc/passwd',\n  target: '/etc/passwd.bck',\n  uid: 'my_user'\n  gid: 'my_group'\n  mode: '0755'\n}, function(err, status){\n  console.log(err ? err.message : 'File was copied: ' + status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering copy\", level: 'DEBUG', module: 'nikita/lib/system/copy'\n  # SSH connection\n  ssh = @ssh options.ssh\n\n\n\nValidate parameters.\n\n\n  options.uid ?= null\n  options.uid = parseInt options.uid if typeof options.uid is 'string' and not isNaN parseInt options.uid\n  options.gid ?= null\n  options.gid = parseInt options.gid if typeof options.gid is 'string' and not isNaN parseInt options.uid\n  options.preserve ?= false\n  options.parent ?= {}\n  options.parent = {} if options.parent is true\n  throw Error 'Missing source' unless options.source\n  throw Error 'Missing target' unless options.target\n\n\n\nRetrieve stats information about the source unless provided through the \"source_stats\" option.\n\n\n  @call (_, callback) ->\n    if options.source_stats\n      options.log message: \"Source Stats: using short circuit\", level: 'DEBUG', module: 'nikita/lib/system/copy'\n      return callback()\n    options.log message: \"Stats source file #{options.source}\", level: 'DEBUG', module: 'nikita/lib/system/copy'\n    @fs.stat ssh: options.ssh, target: options.source, (err, stats) =>\n      return callback err if err\n      options.source_stats = stats unless err\n      callback()\n\n\n\nRetrieve stat information about the traget unless provided through the \"target_stats\" option.\n\n\n  @call (_, callback) ->\n    if options.target_stats\n      options.log message: \"Target Stats: using short circuit\", level: 'DEBUG', module: 'nikita/lib/system/copy'\n      return callback()\n    options.log message: \"Stats target file #{options.target}\", level: 'DEBUG', module: 'nikita/lib/system/copy'\n    @fs.stat ssh: options.ssh, target: options.target, (err, stats) =>\n      # Note, target file doesnt necessarily exist\n      return callback err if err and err.code isnt 'ENOENT'\n      options.target_stats = stats\n      callback()\n\n\n\nCreate target parent directory if target does not exists and if the \"parent\"\noptions is set to \"true\" (default) or as an object.\n\n\n  @system.mkdir\n    if: !!options.parent\n    unless: options.target_stats\n    target: path.dirname options.target\n  , options.parent\n\n\n\nStop here if source is a directory. We traverse all its children\nRecursively, calling either \nsystem.mkdir\n or \nsystem.copy\n.\n\n\nLike with the Unix \ncp\n command, ending slash matters if the target directory \nexists. Let's consider a source directory \"/tmp/a_source\" and a target directory\n\"/tmp/a_target\". Without an ending slash , the directory \"/tmp/a_source\" is \ncopied into \"/tmp/a_target/a_source\". With an ending slash, all the files\npresent inside \"/tmp/a_source\" are copied inside \"/tmp/a_target\".\n\n\n  @call (_, callback) ->\n    return callback() unless options.source_stats.isDirectory()\n    sourceEndWithSlash = options.source.lastIndexOf('/') is options.source.length - 1\n    if options.target_stats and not sourceEndWithSlash\n      options.target = path.resolve options.target, path.basename options.source\n    options.log message: \"Source is a directory\", level: 'INFO', module: 'nikita/lib/system/copy'\n    @call (_, callback) -> \n      glob ssh, \"#{options.source}/**\", dot: true, (err, sources) =>\n        return callback err if err\n        for source in sources then do (source) =>\n          target = path.resolve options.target, path.relative options.source, source\n          @call (_, callback) -> # TODO: remove this line and indent up next line\n            @fs.stat ssh: options.ssh, target: source, (err, source_stats) =>\n              uid = options.uid\n              uid ?= source_stats.uid if options.preserve\n              gid = options.gid\n              gid ?= source_stats.gid if options.preserve\n              mode = options.mode\n              mode ?= source_stats.mode if options.preserve\n              if source_stats.isDirectory()\n                @system.mkdir\n                  target: target\n                  uid: uid\n                  gid: gid\n                  mode: mode\n              else\n                @system.copy\n                  target: target\n                  source: source\n                  source_stat: source_stats\n                  uid: uid\n                  gid: gid\n                  mode: mode\n              @next callback\n        @next callback\n    @next (err, status) -> callback err, status, true\n  , (err, status, end) ->\n    @end() if not err and end\n\n\n\nIf source is a file and target is a directory, then transform\ntarget into a file.\n\n\n  @call ->\n    return unless options.target_stats and options.target_stats.isDirectory()\n    options.target = path.resolve options.target, path.basename options.source\n\n\n\nCopy the file if content doesn't match.\n\n\n  @call (_, callback) ->\n    # Copy a file\n    misc.file.compare ssh, [options.source, options.target], (err, md5) =>\n      # Destination may not exists\n      return callback err if err and err.message.indexOf('Does not exist') isnt 0\n      # Files are the same, we can skip copying\n      return callback null, false if md5\n      options.log message: \"Copy file from #{options.source} into #{options.target}\", level: 'WARN', module: 'nikita/lib/system/copy'\n      @fs.copy\n        ssh: options.ssh\n        source: options.source\n        target: options.target\n      , (err) ->\n        callback err, true\n  , (err, status) ->\n    options.log message: \"File #{options.source} copied\", level: 'DEBUG', module: 'nikita/lib/system/copy'\n\n\n\nFile ownership and permissions\n\n\n  @call ->\n    options.uid ?= options.source_stats.uid if options.preserve\n    options.gid ?= options.source_stats.gid if options.preserve\n    options.mode ?= options.source_stats.mode if options.preserve\n    @system.chown\n      target: options.target\n      stat: options.target_stats\n      uid: options.uid\n      gid: options.gid\n      if: options.uid? or options.gid?\n    @system.chmod\n      target: options.target\n      stat: options.target_stats\n      mode: options.mode\n      if: options.mode?\n\n\n\nDependencies\n\n\npath = require 'path'\nmisc = require '../misc'\nglob = require '../misc/glob'",
            "title": "Copy.coffee"
        },
        {
            "location": "/system/copy.coffee/#nikitasystemcopyoptions-callback",
            "text": "Copy a file. The behavior is similar to the one of the  cp \nUnix utility. Copying a file over an existing file will\noverwrite it.",
            "title": "nikita.system.copy(options, [callback])"
        },
        {
            "location": "/system/copy.coffee/#options",
            "text": "gid   \n  Group name or id who owns the file.     mode   \n  Permissions of the file or the parent directory.     parent  (boolean|object)  \n  Create parent directory with provided attributes if an object or default \n  system options if \"true\", supported attributes include 'mode', 'uid', 'gid', \n  'size', 'atime', and 'mtime'.     preserve   \n  Preserve file ownerships and permissions, default to \"false\".  source   \n  The file or directory to copy.     source_stats   \n  Short-circuit to prevent source stat retrieval if already at our disposal.     target   \n  Where the file or directory is copied.     target_stats   \n  Short-circuit to prevent target stat retrieval if already at our disposal.     uid   \n  User name or id who owns the file.",
            "title": "Options"
        },
        {
            "location": "/system/copy.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value is \"true\" if copied file was created or modified.",
            "title": "Callback Parameters"
        },
        {
            "location": "/system/copy.coffee/#todo",
            "text": "Apply permissions to directories  Handle symlinks  Handle globing  Preserve permissions if  mode  is  true",
            "title": "Todo"
        },
        {
            "location": "/system/copy.coffee/#example",
            "text": "require('nikita').system.copy({\n  source: '/etc/passwd',\n  target: '/etc/passwd.bck',\n  uid: 'my_user'\n  gid: 'my_group'\n  mode: '0755'\n}, function(err, status){\n  console.log(err ? err.message : 'File was copied: ' + status);\n});",
            "title": "Example"
        },
        {
            "location": "/system/copy.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering copy\", level: 'DEBUG', module: 'nikita/lib/system/copy'\n  # SSH connection\n  ssh = @ssh options.ssh  Validate parameters.    options.uid ?= null\n  options.uid = parseInt options.uid if typeof options.uid is 'string' and not isNaN parseInt options.uid\n  options.gid ?= null\n  options.gid = parseInt options.gid if typeof options.gid is 'string' and not isNaN parseInt options.uid\n  options.preserve ?= false\n  options.parent ?= {}\n  options.parent = {} if options.parent is true\n  throw Error 'Missing source' unless options.source\n  throw Error 'Missing target' unless options.target  Retrieve stats information about the source unless provided through the \"source_stats\" option.    @call (_, callback) ->\n    if options.source_stats\n      options.log message: \"Source Stats: using short circuit\", level: 'DEBUG', module: 'nikita/lib/system/copy'\n      return callback()\n    options.log message: \"Stats source file #{options.source}\", level: 'DEBUG', module: 'nikita/lib/system/copy'\n    @fs.stat ssh: options.ssh, target: options.source, (err, stats) =>\n      return callback err if err\n      options.source_stats = stats unless err\n      callback()  Retrieve stat information about the traget unless provided through the \"target_stats\" option.    @call (_, callback) ->\n    if options.target_stats\n      options.log message: \"Target Stats: using short circuit\", level: 'DEBUG', module: 'nikita/lib/system/copy'\n      return callback()\n    options.log message: \"Stats target file #{options.target}\", level: 'DEBUG', module: 'nikita/lib/system/copy'\n    @fs.stat ssh: options.ssh, target: options.target, (err, stats) =>\n      # Note, target file doesnt necessarily exist\n      return callback err if err and err.code isnt 'ENOENT'\n      options.target_stats = stats\n      callback()  Create target parent directory if target does not exists and if the \"parent\"\noptions is set to \"true\" (default) or as an object.    @system.mkdir\n    if: !!options.parent\n    unless: options.target_stats\n    target: path.dirname options.target\n  , options.parent  Stop here if source is a directory. We traverse all its children\nRecursively, calling either  system.mkdir  or  system.copy .  Like with the Unix  cp  command, ending slash matters if the target directory \nexists. Let's consider a source directory \"/tmp/a_source\" and a target directory\n\"/tmp/a_target\". Without an ending slash , the directory \"/tmp/a_source\" is \ncopied into \"/tmp/a_target/a_source\". With an ending slash, all the files\npresent inside \"/tmp/a_source\" are copied inside \"/tmp/a_target\".    @call (_, callback) ->\n    return callback() unless options.source_stats.isDirectory()\n    sourceEndWithSlash = options.source.lastIndexOf('/') is options.source.length - 1\n    if options.target_stats and not sourceEndWithSlash\n      options.target = path.resolve options.target, path.basename options.source\n    options.log message: \"Source is a directory\", level: 'INFO', module: 'nikita/lib/system/copy'\n    @call (_, callback) -> \n      glob ssh, \"#{options.source}/**\", dot: true, (err, sources) =>\n        return callback err if err\n        for source in sources then do (source) =>\n          target = path.resolve options.target, path.relative options.source, source\n          @call (_, callback) -> # TODO: remove this line and indent up next line\n            @fs.stat ssh: options.ssh, target: source, (err, source_stats) =>\n              uid = options.uid\n              uid ?= source_stats.uid if options.preserve\n              gid = options.gid\n              gid ?= source_stats.gid if options.preserve\n              mode = options.mode\n              mode ?= source_stats.mode if options.preserve\n              if source_stats.isDirectory()\n                @system.mkdir\n                  target: target\n                  uid: uid\n                  gid: gid\n                  mode: mode\n              else\n                @system.copy\n                  target: target\n                  source: source\n                  source_stat: source_stats\n                  uid: uid\n                  gid: gid\n                  mode: mode\n              @next callback\n        @next callback\n    @next (err, status) -> callback err, status, true\n  , (err, status, end) ->\n    @end() if not err and end  If source is a file and target is a directory, then transform\ntarget into a file.    @call ->\n    return unless options.target_stats and options.target_stats.isDirectory()\n    options.target = path.resolve options.target, path.basename options.source  Copy the file if content doesn't match.    @call (_, callback) ->\n    # Copy a file\n    misc.file.compare ssh, [options.source, options.target], (err, md5) =>\n      # Destination may not exists\n      return callback err if err and err.message.indexOf('Does not exist') isnt 0\n      # Files are the same, we can skip copying\n      return callback null, false if md5\n      options.log message: \"Copy file from #{options.source} into #{options.target}\", level: 'WARN', module: 'nikita/lib/system/copy'\n      @fs.copy\n        ssh: options.ssh\n        source: options.source\n        target: options.target\n      , (err) ->\n        callback err, true\n  , (err, status) ->\n    options.log message: \"File #{options.source} copied\", level: 'DEBUG', module: 'nikita/lib/system/copy'  File ownership and permissions    @call ->\n    options.uid ?= options.source_stats.uid if options.preserve\n    options.gid ?= options.source_stats.gid if options.preserve\n    options.mode ?= options.source_stats.mode if options.preserve\n    @system.chown\n      target: options.target\n      stat: options.target_stats\n      uid: options.uid\n      gid: options.gid\n      if: options.uid? or options.gid?\n    @system.chmod\n      target: options.target\n      stat: options.target_stats\n      mode: options.mode\n      if: options.mode?",
            "title": "Source Code"
        },
        {
            "location": "/system/copy.coffee/#dependencies",
            "text": "path = require 'path'\nmisc = require '../misc'\nglob = require '../misc/glob'",
            "title": "Dependencies"
        },
        {
            "location": "/system/discover.coffee/",
            "text": "nikita.system.discover(options, [callback])\n\n\nDiscover the OS.\nFor now it only supports Centos/Redhat OS in version 6 or 7, ubuntu.\nStore properties in the nikita store object.\n\n\nOptions\n\n\n\n\nstrict\n (boolean) \n\n  Throw an error if the OS is not supported. false by default.   \n\n\ncache\n \n\n  Enable cache, \"false\" by default.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  True if information was fetch from system, false if retrieved from cache.   \n\n\ninfo\n \n\n  List of info about system   \n\n\n\n\nExample\n\n\nnikita.system.discover({\n  ssh: ssh\n}, function(err, status, info){\n  console.log(err || 'Use cache: ' + status);\n  console.log(err || 'System: ' + info.type);     // eg \"redhat\" or \"centos\"\n  console.log(err || 'Release: ' + info.release); // eg \"6\" or \"7\"\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = shy: true, handler: (options, callback) ->\n  detected = false\n  os = {}\n  os.type = null\n  os.release = null\n  options.strict ?= false\n  options.cache ?= false\n  if options.cache and @store['nikita:system:type']\n    return callback null, false, \n      type: @store['nikita:system:type']\n      release: @store['nikita:system:release']\n  @system.execute\n    cmd: 'cat /etc/redhat-release'\n    if_exec: \"cat /etc/redhat-release | egrep '(Red\\\\sHat)|(CentOS)'\"\n    unless: @store['nikita:system:type']?\n  , (err, status, stdout, stderr) ->\n    throw err if err\n    return unless status\n    [line] = string.lines stdout\n    #might only redhat for centos/redhat\n    if /^CentOS/.test line\n      os.type = 'centos'\n      splits = line.split ' '\n      os.release = splits[splits.indexOf('release')+1]\n    if /^Red\\sHat/.test line\n      os.type = 'redhat'\n      splits = line.split ' '\n      os.release = splits[splits.indexOf('release')+1]\n    if /^Oracle/.test line\n      os.type = 'oracle'\n      splits = line.split ' '\n      os.release = splits[splits.indexOf('release')+1]\n    if options.cache\n      @store['nikita:system:type'] = os.type\n      @store['nikita:system:release'] = os.release\n    throw Error 'OS not supported' if options.strict and os.type not in ['redhat', 'centos', 'oracle']\n  @system.execute\n    cmd: \"\"\"\n      . /etc/lsb-release\n      echo \"$DISTRIB_ID,$DISTRIB_RELEASE\"\n    \"\"\"\n    if_exec: \"cat /etc/lsb-release | egrep 'Ubuntu'\"\n    unless: -> @store['nikita:system:type']?\n  , (err, status, stdout, stderr) ->\n    throw err if err\n    return unless status\n    [distrib_id, distrib_release] = stdout.trim().split ','\n    #backward compatibilty remove 'nikita:system:type'\n    os.type = distrib_id.toLowerCase()\n    os.release = distrib_release\n    if options.cache\n      @store['nikita:system:type'] = os.type\n      @store['nikita:system:release'] = os.release\n    throw Error 'OS not supported' if options.strict and os.type not in ['ubuntu']\n  @next (err, status) ->\n    callback err, status, os\n\n\n\nDependencies\n\n\nstring = require '../misc/string'",
            "title": "Discover.coffee"
        },
        {
            "location": "/system/discover.coffee/#nikitasystemdiscoveroptions-callback",
            "text": "Discover the OS.\nFor now it only supports Centos/Redhat OS in version 6 or 7, ubuntu.\nStore properties in the nikita store object.",
            "title": "nikita.system.discover(options, [callback])"
        },
        {
            "location": "/system/discover.coffee/#options",
            "text": "strict  (boolean)  \n  Throw an error if the OS is not supported. false by default.     cache   \n  Enable cache, \"false\" by default.",
            "title": "Options"
        },
        {
            "location": "/system/discover.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  True if information was fetch from system, false if retrieved from cache.     info   \n  List of info about system",
            "title": "Callback parameters"
        },
        {
            "location": "/system/discover.coffee/#example",
            "text": "nikita.system.discover({\n  ssh: ssh\n}, function(err, status, info){\n  console.log(err || 'Use cache: ' + status);\n  console.log(err || 'System: ' + info.type);     // eg \"redhat\" or \"centos\"\n  console.log(err || 'Release: ' + info.release); // eg \"6\" or \"7\"\n});",
            "title": "Example"
        },
        {
            "location": "/system/discover.coffee/#source-code",
            "text": "module.exports = shy: true, handler: (options, callback) ->\n  detected = false\n  os = {}\n  os.type = null\n  os.release = null\n  options.strict ?= false\n  options.cache ?= false\n  if options.cache and @store['nikita:system:type']\n    return callback null, false, \n      type: @store['nikita:system:type']\n      release: @store['nikita:system:release']\n  @system.execute\n    cmd: 'cat /etc/redhat-release'\n    if_exec: \"cat /etc/redhat-release | egrep '(Red\\\\sHat)|(CentOS)'\"\n    unless: @store['nikita:system:type']?\n  , (err, status, stdout, stderr) ->\n    throw err if err\n    return unless status\n    [line] = string.lines stdout\n    #might only redhat for centos/redhat\n    if /^CentOS/.test line\n      os.type = 'centos'\n      splits = line.split ' '\n      os.release = splits[splits.indexOf('release')+1]\n    if /^Red\\sHat/.test line\n      os.type = 'redhat'\n      splits = line.split ' '\n      os.release = splits[splits.indexOf('release')+1]\n    if /^Oracle/.test line\n      os.type = 'oracle'\n      splits = line.split ' '\n      os.release = splits[splits.indexOf('release')+1]\n    if options.cache\n      @store['nikita:system:type'] = os.type\n      @store['nikita:system:release'] = os.release\n    throw Error 'OS not supported' if options.strict and os.type not in ['redhat', 'centos', 'oracle']\n  @system.execute\n    cmd: \"\"\"\n      . /etc/lsb-release\n      echo \"$DISTRIB_ID,$DISTRIB_RELEASE\"\n    \"\"\"\n    if_exec: \"cat /etc/lsb-release | egrep 'Ubuntu'\"\n    unless: -> @store['nikita:system:type']?\n  , (err, status, stdout, stderr) ->\n    throw err if err\n    return unless status\n    [distrib_id, distrib_release] = stdout.trim().split ','\n    #backward compatibilty remove 'nikita:system:type'\n    os.type = distrib_id.toLowerCase()\n    os.release = distrib_release\n    if options.cache\n      @store['nikita:system:type'] = os.type\n      @store['nikita:system:release'] = os.release\n    throw Error 'OS not supported' if options.strict and os.type not in ['ubuntu']\n  @next (err, status) ->\n    callback err, status, os",
            "title": "Source Code"
        },
        {
            "location": "/system/discover.coffee/#dependencies",
            "text": "string = require '../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/system/limits.coffee/",
            "text": "nikita.system.limits(options, [callback])\n\n\nControl system limits for a user.\n\n\nOptions\n\n\n\n\ntarget\n (string) \n\n  Where to write the file, default to \"/etc/security/limits.d/#{options.user}.conf\".   \n\n\nas\n (int) \n\n  Address space limit (KB)   \n\n\ncore\n (int) \n\n  Limits the core file size (KB)   \n\n\ncpu\n  (int) \n\n  CPU time limit (in seconds). \n\n  When the process reaches the soft limit, it receives a SIGXCPU every second. \n\n  When it reaches the hard limit, it receives SIGKILL.   \n\n\ndata\n (int) \n\n  Max data size (KB)   \n\n\nfsize\n (int) \n\n  Maximum filesize (KB)   \n\n\nlocks\n (int) \n\n  Max number of file locks the user can hold.   \n\n\nmaxlogins\n (int) \n\n  Max number of logins for this user.   \n\n\nmaxsyslogins\n (int) \n\n  Max number of logins on the system.   \n\n\nmemlock\n (int) \n\n  Max locked-in-memory address space (KB)   \n\n\nmsgqueue\n (int) \n\n  Max memory used by POSIX message queues (bytes)   \n\n\nnice\n (int: [-20, 19]) \n\n  Max nice priority allowed to raise to values   \n\n\nnofile\n (int) \n\n  Max number of open file descriptors   \n\n\nnproc\n (int) \n\n  Max number of processes   \n\n\npriority\n (int) \n\n  Priority to run user process with   \n\n\nrss\n (int) \n\n  Max resident set size (KB)   \n\n\nsigpending\n (int) \n\n  Max number of pending signals.   \n\n\nstack\n (int) \n\n  Max stack size (KB)   \n\n\nrtprio\n (int) \n\n  Max realtime priority.   \n\n\nuser\n (string) \n\n  The user to apply the limit to   \n\n\n\n\nImplemented strategy\n\n\nnproc and nofile\n\n\nthere is two cases, depending on the specified value\n\n\n\n\nint value\n\n\n\n\nIf an int value is specified, then nikita checks that the value is lesser than \nthe kernel limit. Please be aware that it is necessary but not sufficient to \nguarantee that the user would be able to open session.\n\n\n\n\ntrue value\n\n\n\n\nIf a true value is specified, then nikita set it to 75% of the kernel limit.\nThis value is neither optimal nor able to guarantee that the user would be\nable to open session, but that is the best nikita can automatically do.\n\n\nOther values\n\n\nOther values are not assessed by default.\nThey must be int typed, and no specific check is implemented.\n\n\nUlimit\n\n\nLinux allows to limit the resources allocated to users or user groups via\n\"/etc/security/limits.conf\" and \"/etc/security/limits.d/*.conf\" files loaded by\nWFP (Plugable Authentication Module) at each logon. The user can then adapt the\nresources available to its needs via \"ulimit\".\n\n\nIt is possible to define, for a number of resources (number of open files, file size,\nnumber of instantiated process, CPU time, etc.), a \"soft\" limit which can be\nincreased by user, via \"ulimit\" until a maximum \"hard\" limit.\nThe system does not exceed the value of the soft limit. If the user wants to push\nthis limit, it will set a new soft limit with ulimit.\nThe soft limit is always lower or equal to the hard limit.\nIn general, the limits applied to a user override those applied to a group.\n\n\nUlimit commands\n\n\nThe \"S\" option to \"ulimit\" impact the effective limit (\"soft\" limit) and the \"H\"\nimpact the \"hard\" limit (maximum value that can be defined by the user).\n\n\n\n\n\n\n\n\nresource\n\n\nsoft\n\n\nhard\n\n\nunit\n\n\n\n\n\n\n\n\n\n\ncore file size\n\n\nulimit -Sc\n\n\nulimit -Hc\n\n\nblocks\n\n\n\n\n\n\ndata seg size\n\n\nulimit -Sd\n\n\nulimit -Hd\n\n\nkbytes\n\n\n\n\n\n\nscheduling priority\n\n\nulimit -Se\n\n\nulimit -He\n\n\n\n\n\n\n\n\nfile size\n\n\nulimit -Sf\n\n\nulimit -Hf\n\n\nblocks\n\n\n\n\n\n\nmax locked memory\n\n\nulimit -Sl\n\n\nulimit -Hl\n\n\nkbytes\n\n\n\n\n\n\npending signals\n\n\nulimit -Si\n\n\nulimit -Hi\n\n\n\n\n\n\n\n\nmax memory size\n\n\nulimit -Sm\n\n\nulimit -Hm\n\n\nkbytes\n\n\n\n\n\n\nopen files\n\n\nulimit -Sn\n\n\nulimit -Hn\n\n\n\n\n\n\n\n\npipe size\n\n\nulimit -Sp\n\n\nulimit -Hp\n\n\nbytes\n\n\n\n\n\n\nPOSIX message queues\n\n\nulimit -Sq\n\n\nulimit -Hq\n\n\nbytes\n\n\n\n\n\n\nreal-time priority\n\n\nulimit -Sr\n\n\nulimit -Hr\n\n\n\n\n\n\n\n\nstack size\n\n\nulimit -Ss\n\n\nulimit -Hs\n\n\nkbytes\n\n\n\n\n\n\ncpu time\n\n\nulimit -St\n\n\nulimit -Ht\n\n\nseconds\n\n\n\n\n\n\nmax user processes\n\n\nulimit -Su\n\n\nulimit -Hu\n\n\n\n\n\n\n\n\nvirtual memory\n\n\nulimit -Sv\n\n\nulimit -Hv\n\n\nkbytes\n\n\n\n\n\n\nfile locks\n\n\nulimit -Sx\n\n\nulimit -Hx\n\n\n\n\n\n\n\n\n\n\nPass the option in flag-mode to get, and follows it with a value to set.\n\n\nRetrieve current information\n\n\nNumber of sub-process for a process:\n\n\npid=14986\nls /proc/$pid/task | wc\nps -L p $pid --no-headers | wc -l\n\n\n\n\nNumber of sub-process for a user:\nThe option \"-L\" show threads, possibly with LWP and NLWP columns.\n\n\nuser=`whoami`\nps -L -u $user --no-headers | wc -l\n\n\n\n\nKernel Limits\n\n\nUser limits cannot exceed kernel limits, so you need to configure kernel limits\nbefore user limits.\n\n\nProcesses\n\n\nsysctl kernel.pid_max         # print kernel.pid_max = VALUE\ncat /proc/sys/kernel/pid_max  # print VALUE\n\n\n\n\nTemporary change\n: \necho 4194303 > /proc/sys/kernel/pid_max\n\n\nPermanent change\n: \nvi /etc/sysctl.conf # kernel.pid_max = 4194303\n\n\nOpen Files\n\n\nsysctl fs.file-max         # print fs.file-max = VALUE\ncat /proc/sys/fs/file-max  # print VALUE\n\n\n\n\nTemporary change\n: \necho 1631017 > /proc/sys/fs/file-max\n\n\nPermanent change\n : \nvi /etc/sysctl.conf # fs.file-max = 1631017\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n    Error object if any.   \n\n\nstatus\n \n\n    Value is \"true\" if limits configuration file has been modified.   \n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering system_limits\", level: 'DEBUG', module: 'nikita/lib/system_limits'\n  return callback Error \"Incoherent options: both options system and user defined, #{JSON.stringify system: options.system, user: options.user}\" if options.system and options.user\n  options.user = '*' if options.system\n  return callback Error \"Missing required option 'user'\" unless options.user\n  options.target ?= \"/etc/security/\" + if options.user is '*' then \"limits.conf\" else \"limits.d/#{options.user}.conf\"\n  write = []\n  # Calculate nofile from kernel limit\n  @system.execute\n    cmd: \"cat /proc/sys/fs/file-max\"\n    shy: true\n    if: options.nofile?\n  , (err, status, stdout) ->\n    # console.log err, status, stdout\n    throw err if err\n    return unless status\n    kern_limit = parseInt stdout.trim()\n    if options.nofile is true then options.nofile = Math.round kern_limit*0.75\n    else if typeof options.nofile is 'number'\n      throw Error \"Invalid nofile options. Please set int value lesser than kernel limit: #{kern_limit}\" if options.nofile >= kern_limit\n    else if typeof options.nofile is 'object'\n      for _, v of options.nofile\n        throw Error \"Invalid nofile options. Please set int value lesser than kernel limit: #{kern_limit}\" if v >= kern_limit\n  # Calculate nproc from kernel limit\n  @system.execute\n    cmd: \"cat /proc/sys/kernel/pid_max\"\n    shy: true\n    if: options.nproc?\n  , (err, status, stdout) ->\n    throw err if err\n    return unless status\n    kern_limit = parseInt stdout.trim()\n    if options.nproc is true then options.nproc = Math.round kern_limit*0.75\n    else if typeof options.nproc is 'number'\n      throw Error \"Invalid nproc options. Please set int value lesser than kernel limit: #{kern_limit}\" if options.nproc >= kern_limit\n    else if typeof options.nproc is 'object'\n      for _, v of options.nproc\n        throw Error \"Invalid nproc options. Please set int value lesser than kernel limit: #{kern_limit}\" if v >= kern_limit\n  @call ->\n    for opt in ['as', 'core', 'cpu', 'data', 'fsize', 'locks', 'maxlogins',\n    'maxsyslogins', 'memlock', 'msgqueue', 'nice', 'nofile', 'nproc',\n    'priority', 'rss', 'sigpending', 'stack', 'rtprio']\n      if options[opt]?\n        options[opt] = '-': options[opt] unless typeof options[opt] is 'object'\n        for k in Object.keys options[opt]\n          throw Error \"Invalid option: #{JSON.stringify options[opt]}\" unless k in ['soft', 'hard', '-']\n          throw Error \"Invalid option: #{options[opt][k]} not a number\" unless (typeof options[opt][k] is 'number') or options[opt][k] is 'unlimited'\n          write.push\n            match: RegExp \"^#{regexp.escape options.user} +#{regexp.escape k} +#{opt}.+$\", 'm'\n            replace: \"#{options.user}    #{k}    #{opt}    #{options[opt][k]}\"\n            append: true\n    return false\n  @file\n    target: options.target\n    write: write\n    eof: true\n    uid: options.uid\n    gid: options.gid\n    if: -> write.length\n\n\n\nDependencies\n\n\n{regexp} = require '../misc'",
            "title": "Limits.coffee"
        },
        {
            "location": "/system/limits.coffee/#nikitasystemlimitsoptions-callback",
            "text": "Control system limits for a user.",
            "title": "nikita.system.limits(options, [callback])"
        },
        {
            "location": "/system/limits.coffee/#options",
            "text": "target  (string)  \n  Where to write the file, default to \"/etc/security/limits.d/#{options.user}.conf\".     as  (int)  \n  Address space limit (KB)     core  (int)  \n  Limits the core file size (KB)     cpu   (int)  \n  CPU time limit (in seconds).  \n  When the process reaches the soft limit, it receives a SIGXCPU every second.  \n  When it reaches the hard limit, it receives SIGKILL.     data  (int)  \n  Max data size (KB)     fsize  (int)  \n  Maximum filesize (KB)     locks  (int)  \n  Max number of file locks the user can hold.     maxlogins  (int)  \n  Max number of logins for this user.     maxsyslogins  (int)  \n  Max number of logins on the system.     memlock  (int)  \n  Max locked-in-memory address space (KB)     msgqueue  (int)  \n  Max memory used by POSIX message queues (bytes)     nice  (int: [-20, 19])  \n  Max nice priority allowed to raise to values     nofile  (int)  \n  Max number of open file descriptors     nproc  (int)  \n  Max number of processes     priority  (int)  \n  Priority to run user process with     rss  (int)  \n  Max resident set size (KB)     sigpending  (int)  \n  Max number of pending signals.     stack  (int)  \n  Max stack size (KB)     rtprio  (int)  \n  Max realtime priority.     user  (string)  \n  The user to apply the limit to",
            "title": "Options"
        },
        {
            "location": "/system/limits.coffee/#implemented-strategy",
            "text": "",
            "title": "Implemented strategy"
        },
        {
            "location": "/system/limits.coffee/#nproc-and-nofile",
            "text": "there is two cases, depending on the specified value   int value   If an int value is specified, then nikita checks that the value is lesser than \nthe kernel limit. Please be aware that it is necessary but not sufficient to \nguarantee that the user would be able to open session.   true value   If a true value is specified, then nikita set it to 75% of the kernel limit.\nThis value is neither optimal nor able to guarantee that the user would be\nable to open session, but that is the best nikita can automatically do.",
            "title": "nproc and nofile"
        },
        {
            "location": "/system/limits.coffee/#other-values",
            "text": "Other values are not assessed by default.\nThey must be int typed, and no specific check is implemented.",
            "title": "Other values"
        },
        {
            "location": "/system/limits.coffee/#ulimit",
            "text": "Linux allows to limit the resources allocated to users or user groups via\n\"/etc/security/limits.conf\" and \"/etc/security/limits.d/*.conf\" files loaded by\nWFP (Plugable Authentication Module) at each logon. The user can then adapt the\nresources available to its needs via \"ulimit\".  It is possible to define, for a number of resources (number of open files, file size,\nnumber of instantiated process, CPU time, etc.), a \"soft\" limit which can be\nincreased by user, via \"ulimit\" until a maximum \"hard\" limit.\nThe system does not exceed the value of the soft limit. If the user wants to push\nthis limit, it will set a new soft limit with ulimit.\nThe soft limit is always lower or equal to the hard limit.\nIn general, the limits applied to a user override those applied to a group.",
            "title": "Ulimit"
        },
        {
            "location": "/system/limits.coffee/#ulimit-commands",
            "text": "The \"S\" option to \"ulimit\" impact the effective limit (\"soft\" limit) and the \"H\"\nimpact the \"hard\" limit (maximum value that can be defined by the user).     resource  soft  hard  unit      core file size  ulimit -Sc  ulimit -Hc  blocks    data seg size  ulimit -Sd  ulimit -Hd  kbytes    scheduling priority  ulimit -Se  ulimit -He     file size  ulimit -Sf  ulimit -Hf  blocks    max locked memory  ulimit -Sl  ulimit -Hl  kbytes    pending signals  ulimit -Si  ulimit -Hi     max memory size  ulimit -Sm  ulimit -Hm  kbytes    open files  ulimit -Sn  ulimit -Hn     pipe size  ulimit -Sp  ulimit -Hp  bytes    POSIX message queues  ulimit -Sq  ulimit -Hq  bytes    real-time priority  ulimit -Sr  ulimit -Hr     stack size  ulimit -Ss  ulimit -Hs  kbytes    cpu time  ulimit -St  ulimit -Ht  seconds    max user processes  ulimit -Su  ulimit -Hu     virtual memory  ulimit -Sv  ulimit -Hv  kbytes    file locks  ulimit -Sx  ulimit -Hx      Pass the option in flag-mode to get, and follows it with a value to set.",
            "title": "Ulimit commands"
        },
        {
            "location": "/system/limits.coffee/#retrieve-current-information",
            "text": "Number of sub-process for a process:  pid=14986\nls /proc/$pid/task | wc\nps -L p $pid --no-headers | wc -l  Number of sub-process for a user:\nThe option \"-L\" show threads, possibly with LWP and NLWP columns.  user=`whoami`\nps -L -u $user --no-headers | wc -l",
            "title": "Retrieve current information"
        },
        {
            "location": "/system/limits.coffee/#kernel-limits",
            "text": "User limits cannot exceed kernel limits, so you need to configure kernel limits\nbefore user limits.",
            "title": "Kernel Limits"
        },
        {
            "location": "/system/limits.coffee/#processes",
            "text": "sysctl kernel.pid_max         # print kernel.pid_max = VALUE\ncat /proc/sys/kernel/pid_max  # print VALUE  Temporary change :  echo 4194303 > /proc/sys/kernel/pid_max  Permanent change :  vi /etc/sysctl.conf # kernel.pid_max = 4194303",
            "title": "Processes"
        },
        {
            "location": "/system/limits.coffee/#open-files",
            "text": "sysctl fs.file-max         # print fs.file-max = VALUE\ncat /proc/sys/fs/file-max  # print VALUE  Temporary change :  echo 1631017 > /proc/sys/fs/file-max  Permanent change  :  vi /etc/sysctl.conf # fs.file-max = 1631017",
            "title": "Open Files"
        },
        {
            "location": "/system/limits.coffee/#callback-parameters",
            "text": "err   \n    Error object if any.     status   \n    Value is \"true\" if limits configuration file has been modified.",
            "title": "Callback parameters"
        },
        {
            "location": "/system/limits.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering system_limits\", level: 'DEBUG', module: 'nikita/lib/system_limits'\n  return callback Error \"Incoherent options: both options system and user defined, #{JSON.stringify system: options.system, user: options.user}\" if options.system and options.user\n  options.user = '*' if options.system\n  return callback Error \"Missing required option 'user'\" unless options.user\n  options.target ?= \"/etc/security/\" + if options.user is '*' then \"limits.conf\" else \"limits.d/#{options.user}.conf\"\n  write = []\n  # Calculate nofile from kernel limit\n  @system.execute\n    cmd: \"cat /proc/sys/fs/file-max\"\n    shy: true\n    if: options.nofile?\n  , (err, status, stdout) ->\n    # console.log err, status, stdout\n    throw err if err\n    return unless status\n    kern_limit = parseInt stdout.trim()\n    if options.nofile is true then options.nofile = Math.round kern_limit*0.75\n    else if typeof options.nofile is 'number'\n      throw Error \"Invalid nofile options. Please set int value lesser than kernel limit: #{kern_limit}\" if options.nofile >= kern_limit\n    else if typeof options.nofile is 'object'\n      for _, v of options.nofile\n        throw Error \"Invalid nofile options. Please set int value lesser than kernel limit: #{kern_limit}\" if v >= kern_limit\n  # Calculate nproc from kernel limit\n  @system.execute\n    cmd: \"cat /proc/sys/kernel/pid_max\"\n    shy: true\n    if: options.nproc?\n  , (err, status, stdout) ->\n    throw err if err\n    return unless status\n    kern_limit = parseInt stdout.trim()\n    if options.nproc is true then options.nproc = Math.round kern_limit*0.75\n    else if typeof options.nproc is 'number'\n      throw Error \"Invalid nproc options. Please set int value lesser than kernel limit: #{kern_limit}\" if options.nproc >= kern_limit\n    else if typeof options.nproc is 'object'\n      for _, v of options.nproc\n        throw Error \"Invalid nproc options. Please set int value lesser than kernel limit: #{kern_limit}\" if v >= kern_limit\n  @call ->\n    for opt in ['as', 'core', 'cpu', 'data', 'fsize', 'locks', 'maxlogins',\n    'maxsyslogins', 'memlock', 'msgqueue', 'nice', 'nofile', 'nproc',\n    'priority', 'rss', 'sigpending', 'stack', 'rtprio']\n      if options[opt]?\n        options[opt] = '-': options[opt] unless typeof options[opt] is 'object'\n        for k in Object.keys options[opt]\n          throw Error \"Invalid option: #{JSON.stringify options[opt]}\" unless k in ['soft', 'hard', '-']\n          throw Error \"Invalid option: #{options[opt][k]} not a number\" unless (typeof options[opt][k] is 'number') or options[opt][k] is 'unlimited'\n          write.push\n            match: RegExp \"^#{regexp.escape options.user} +#{regexp.escape k} +#{opt}.+$\", 'm'\n            replace: \"#{options.user}    #{k}    #{opt}    #{options[opt][k]}\"\n            append: true\n    return false\n  @file\n    target: options.target\n    write: write\n    eof: true\n    uid: options.uid\n    gid: options.gid\n    if: -> write.length",
            "title": "Source Code"
        },
        {
            "location": "/system/limits.coffee/#dependencies",
            "text": "{regexp} = require '../misc'",
            "title": "Dependencies"
        },
        {
            "location": "/system/link.coffee/",
            "text": "nikita.system.link(options, [callback])\n\n\nCreate a symbolic link and it's parent directories if they don't yet\nexist.\n\n\nNote, it is valid for the \"source\" file to not exist.\n\n\nOptions\n\n\n\n\nsource\n \n\n  Referenced file to be linked.   \n\n\ntarget\n \n\n  Symbolic link to be created.   \n\n\nexec\n \n\n  Create an executable file with an \nexec\n command.   \n\n\nmode\n \n\n  Default to \n0o0755\n.   \n\n\n\n\nCallback Parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value is \"true\" if link was created or modified.   \n\n\n\n\nExample\n\n\nrequire('nikita').system.link({\n  source: __dirname,\n  target: '/tmp/a_link'\n}, function(err, status){\n  console.info(err ? err.message : 'Link created: ' + status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering link\", level: 'DEBUG', module: 'nikita/lib/system/link'\n  linked = 0\n  sym_exists = (options, callback) =>\n    @fs.readlink ssh: options.ssh, target: options.target, (err, resolvedPath) ->\n      return callback null, false if err\n      return callback null, true if resolvedPath is options.source\n      @fs.unlink ssh: options.ssh, target: options.target, (err) ->\n        return callback err if err\n        callback null, false\n  sym_create = (options, callback) =>\n    @fs.symlink ssh: options.ssh, source: options.source, target: options.target, (err) ->\n      return callback err if err\n      linked++\n      callback()\n  exec_exists = (options, callback) =>\n    @fs.exists ssh: options.ssh, target: options.target, (err, exists) ->\n      return callback null, false unless exists\n      @fs.readFile ssh: options.ssh, target: options.target, encoding: 'utf8', (err, content) ->\n        return callback err if err\n        exec_cmd = /exec (.*) \\$@/.exec(content)[1]\n        callback null, exec_cmd and exec_cmd is options.source\n  exec_create = (options, callback) =>\n    content = \"\"\"\n    #!/bin/bash\n    exec #{options.source} $@\n    \"\"\"\n    @fs.writeFile ssh: options.ssh, target: options.target, content: content, (err) ->\n      return callback err if err\n      @fs.chmod ssh: options.ssh, target: options.target, mode: options.mode, (err) ->\n        return callback err if err\n        linked++\n        callback()\n  return callback Error \"Missing source, got #{JSON.stringify(options.source)}\" unless options.source\n  return callback Error \"Missing target, got #{JSON.stringify(options.target)}\" unless options.target\n  options.mode ?= 0o0755\n  do_mkdir = =>\n    @system.mkdir\n      ssh: options.ssh\n      target: path.dirname options.target\n    , (err, created) ->\n      # It is possible to have collision if to symlink\n      # have the same parent directory\n      return callback err if err and err.code isnt 'EEXIST'\n      do_dispatch()\n  do_dispatch = =>\n    if options.exec\n      exec_exists options, (err, exists) ->\n        return do_end() if exists\n        exec_create options, do_end\n    else\n      sym_exists options, (err, exists) ->\n        return do_end() if exists\n        sym_create options, do_end\n  do_end = ->\n    callback null, linked\n  do_mkdir()\n\n\n\nDependencies\n\n\npath = require 'path'",
            "title": "Link.coffee"
        },
        {
            "location": "/system/link.coffee/#nikitasystemlinkoptions-callback",
            "text": "Create a symbolic link and it's parent directories if they don't yet\nexist.  Note, it is valid for the \"source\" file to not exist.",
            "title": "nikita.system.link(options, [callback])"
        },
        {
            "location": "/system/link.coffee/#options",
            "text": "source   \n  Referenced file to be linked.     target   \n  Symbolic link to be created.     exec   \n  Create an executable file with an  exec  command.     mode   \n  Default to  0o0755 .",
            "title": "Options"
        },
        {
            "location": "/system/link.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value is \"true\" if link was created or modified.",
            "title": "Callback Parameters"
        },
        {
            "location": "/system/link.coffee/#example",
            "text": "require('nikita').system.link({\n  source: __dirname,\n  target: '/tmp/a_link'\n}, function(err, status){\n  console.info(err ? err.message : 'Link created: ' + status);\n});",
            "title": "Example"
        },
        {
            "location": "/system/link.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering link\", level: 'DEBUG', module: 'nikita/lib/system/link'\n  linked = 0\n  sym_exists = (options, callback) =>\n    @fs.readlink ssh: options.ssh, target: options.target, (err, resolvedPath) ->\n      return callback null, false if err\n      return callback null, true if resolvedPath is options.source\n      @fs.unlink ssh: options.ssh, target: options.target, (err) ->\n        return callback err if err\n        callback null, false\n  sym_create = (options, callback) =>\n    @fs.symlink ssh: options.ssh, source: options.source, target: options.target, (err) ->\n      return callback err if err\n      linked++\n      callback()\n  exec_exists = (options, callback) =>\n    @fs.exists ssh: options.ssh, target: options.target, (err, exists) ->\n      return callback null, false unless exists\n      @fs.readFile ssh: options.ssh, target: options.target, encoding: 'utf8', (err, content) ->\n        return callback err if err\n        exec_cmd = /exec (.*) \\$@/.exec(content)[1]\n        callback null, exec_cmd and exec_cmd is options.source\n  exec_create = (options, callback) =>\n    content = \"\"\"\n    #!/bin/bash\n    exec #{options.source} $@\n    \"\"\"\n    @fs.writeFile ssh: options.ssh, target: options.target, content: content, (err) ->\n      return callback err if err\n      @fs.chmod ssh: options.ssh, target: options.target, mode: options.mode, (err) ->\n        return callback err if err\n        linked++\n        callback()\n  return callback Error \"Missing source, got #{JSON.stringify(options.source)}\" unless options.source\n  return callback Error \"Missing target, got #{JSON.stringify(options.target)}\" unless options.target\n  options.mode ?= 0o0755\n  do_mkdir = =>\n    @system.mkdir\n      ssh: options.ssh\n      target: path.dirname options.target\n    , (err, created) ->\n      # It is possible to have collision if to symlink\n      # have the same parent directory\n      return callback err if err and err.code isnt 'EEXIST'\n      do_dispatch()\n  do_dispatch = =>\n    if options.exec\n      exec_exists options, (err, exists) ->\n        return do_end() if exists\n        exec_create options, do_end\n    else\n      sym_exists options, (err, exists) ->\n        return do_end() if exists\n        sym_create options, do_end\n  do_end = ->\n    callback null, linked\n  do_mkdir()",
            "title": "Source Code"
        },
        {
            "location": "/system/link.coffee/#dependencies",
            "text": "path = require 'path'",
            "title": "Dependencies"
        },
        {
            "location": "/system/mkdir.coffee/",
            "text": "nikita.system.mkdir(options, [callback])\n\n\nRecursively create a directory. The behavior is similar to the Unix command\n\nmkdir -p\n. It supports an alternative syntax where options is simply the path\nof the directory to create.\n\n\nOptions\n\n\n\n\ncwd\n \n\n  Current working directory for relative paths.   \n\n\nuid\n \n\n  Unix user id.   \n\n\ngid\n \n\n  Unix group id.   \n\n\nmode\n \n\n  Default to \"0755\".   \n\n\ndirectory\n \n\n  Path or array of paths.   \n\n\ntarget\n \n\n  Alias for \ndirectory\n.   \n\n\nexclude\n \n\n  Regular expression.   \n\n\nparent\n (boolean|object) \n\n  Create parent directory with provided attributes if an object or default \n  system options if \"true\", supported attributes include 'mode', 'uid', 'gid', \n  'size', 'atime', and 'mtime'.   \n\n\nsource\n \n\n  Alias for \ndirectory\n.   \n\n\n\n\nCallback Parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value is \"true\" if directory was created or modified.   \n\n\n\n\nSimple usage\n\n\nrequire('nikita').system.mkdir('./some/dir', function(err, status){\n  console.log(err ? err.message : \"Directory created: \" + status);\n});\n\n\n\n\nAdvanced usage\n\n\nrequire('nikita').system.mkdir({\n  ssh: ssh,\n  target: './some/dir',\n  uid: 'a_user',\n  gid: 'a_group'\n  mode: 0o0777 // or '777'\n}, function(err, status){\n  console.log(err ? err.message : 'Directory created: ' + status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering mkdir\", level: 'DEBUG', module: 'nikita/lib/system/mkdir'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Validate options\n  options.target = options.argument if options.argument?\n  options.directory ?= options.target\n  options.directory ?= options.source\n  return callback Error 'Missing target option' unless options.directory?\n  options.cwd = process.cwd() if not ssh and (options.cwd is true or not options.cwd)\n  options.directory = [options.directory] unless Array.isArray options.directory\n  options.parent = {} if options.parent is true\n  # State\n  state = false\n  each options.directory\n  .call (directory, callback) =>\n    # first, we need to find which directory need to be created\n    # options.log message: \"Creating directory '#{directory}'\", level: 'DEBUG', module: 'nikita/lib/system/mkdir'\n    do_stats = =>\n      end = false\n      dirs = []\n      p = if ssh then path.posix else path\n      directory = if options.cwd then p.resolve options.cwd, directory else p.normalize directory # path.resolve also normalize\n      # Create directory and its parent directories\n      directories = directory.split('/')\n      directories.shift() # first element is empty with absolute path\n      directories.pop() if directories[directories.length-1] is ''\n      directories = for i in [0...directories.length]\n        '/' + directories.slice(0, directories.length - i).join '/'\n      each(directories)\n      .call (directory, i, next) =>\n        options.log message: \"Stat '#{directory}'\", level: 'DEBUG', module: 'nikita/lib/system/mkdir'\n        @fs.stat ssh: options.ssh, target: directory, (err, stat) ->\n          if err?.code is 'ENOENT' # if the directory is not yet created\n            directory.stat = stat\n            dirs.push directory\n            if i is directories.length - 1\n            then return do_create_parent(dirs)\n            else return next()\n          if stat?.isDirectory()\n            end = true\n            return  if i is 0 then do_update(stat) else do_create_parent(dirs)\n          if err\n            return next err\n          else # a file or symlink exists at this location\n            return next Error \"Not a directory: #{JSON.stringify directory}\"\n      .next callback\n    do_create_parent = (directories) =>\n      @system.uid_gid\n        uid: options.uid\n        gid: options.gid\n      , (err, status, {uid, gid}) ->\n        options.uid = uid\n        options.gid = gid\n        do_create directories\n    do_create = (directories) =>\n      each(directories.reverse())\n      .call (directory, i, callback) =>\n        # Directory name contains variables\n        # eg /\\${/ on './var/cache/${user}' creates './var/cache/'\n        if options.exclude? and options.exclude instanceof RegExp\n          return callback() if options.exclude.test path.basename directory\n        options.log message: \"Create directory \\\"#{directory}\\\"\", level: 'DEBUG', module: 'nikita/lib/system/mkdir' # unless directory is options.directory\n        opts = {}\n        for attr in ['mode', 'uid', 'gid', 'size', 'atime', 'mtime']\n          val = if i is directories.length - 1 then options[attr] else options.parent?[attr]\n          opts[attr] = val if val?\n        @fs.mkdir ssh: options.ssh, target: directory, opts, (err) ->\n          return callback err if err\n          options.log message: \"Directory \\\"#{directory}\\\" created \", level: 'INFO', module: 'nikita/lib/system/mkdir'\n          state = true\n          callback()\n      .next (err) ->\n        return callback err if err\n        callback()\n    do_update = (stat) =>\n      options.log message: \"Directory already exists\", level: 'INFO', module: 'nikita/lib/system/mkdir'\n      @system.chown\n        target: directory\n        stat: stat\n        uid: options.uid\n        gid: options.gid\n        if: options.uid? or options.gid?\n      @system.chmod\n        target: directory\n        stat: stat\n        mode: options.mode\n        if: options.mode?\n      @next (err, moded) ->\n        return callback err if err\n        state = true if moded\n        callback()\n    do_stats()\n  .next (err) ->\n    callback err, state\n\n\n\nDependencies\n\n\npath = require 'path'\neach = require 'each'\nmisc = require '../misc'\nwrap = require '../misc/wrap'",
            "title": "Mkdir.coffee"
        },
        {
            "location": "/system/mkdir.coffee/#nikitasystemmkdiroptions-callback",
            "text": "Recursively create a directory. The behavior is similar to the Unix command mkdir -p . It supports an alternative syntax where options is simply the path\nof the directory to create.",
            "title": "nikita.system.mkdir(options, [callback])"
        },
        {
            "location": "/system/mkdir.coffee/#options",
            "text": "cwd   \n  Current working directory for relative paths.     uid   \n  Unix user id.     gid   \n  Unix group id.     mode   \n  Default to \"0755\".     directory   \n  Path or array of paths.     target   \n  Alias for  directory .     exclude   \n  Regular expression.     parent  (boolean|object)  \n  Create parent directory with provided attributes if an object or default \n  system options if \"true\", supported attributes include 'mode', 'uid', 'gid', \n  'size', 'atime', and 'mtime'.     source   \n  Alias for  directory .",
            "title": "Options"
        },
        {
            "location": "/system/mkdir.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value is \"true\" if directory was created or modified.",
            "title": "Callback Parameters"
        },
        {
            "location": "/system/mkdir.coffee/#simple-usage",
            "text": "require('nikita').system.mkdir('./some/dir', function(err, status){\n  console.log(err ? err.message : \"Directory created: \" + status);\n});",
            "title": "Simple usage"
        },
        {
            "location": "/system/mkdir.coffee/#advanced-usage",
            "text": "require('nikita').system.mkdir({\n  ssh: ssh,\n  target: './some/dir',\n  uid: 'a_user',\n  gid: 'a_group'\n  mode: 0o0777 // or '777'\n}, function(err, status){\n  console.log(err ? err.message : 'Directory created: ' + status);\n});",
            "title": "Advanced usage"
        },
        {
            "location": "/system/mkdir.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering mkdir\", level: 'DEBUG', module: 'nikita/lib/system/mkdir'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Validate options\n  options.target = options.argument if options.argument?\n  options.directory ?= options.target\n  options.directory ?= options.source\n  return callback Error 'Missing target option' unless options.directory?\n  options.cwd = process.cwd() if not ssh and (options.cwd is true or not options.cwd)\n  options.directory = [options.directory] unless Array.isArray options.directory\n  options.parent = {} if options.parent is true\n  # State\n  state = false\n  each options.directory\n  .call (directory, callback) =>\n    # first, we need to find which directory need to be created\n    # options.log message: \"Creating directory '#{directory}'\", level: 'DEBUG', module: 'nikita/lib/system/mkdir'\n    do_stats = =>\n      end = false\n      dirs = []\n      p = if ssh then path.posix else path\n      directory = if options.cwd then p.resolve options.cwd, directory else p.normalize directory # path.resolve also normalize\n      # Create directory and its parent directories\n      directories = directory.split('/')\n      directories.shift() # first element is empty with absolute path\n      directories.pop() if directories[directories.length-1] is ''\n      directories = for i in [0...directories.length]\n        '/' + directories.slice(0, directories.length - i).join '/'\n      each(directories)\n      .call (directory, i, next) =>\n        options.log message: \"Stat '#{directory}'\", level: 'DEBUG', module: 'nikita/lib/system/mkdir'\n        @fs.stat ssh: options.ssh, target: directory, (err, stat) ->\n          if err?.code is 'ENOENT' # if the directory is not yet created\n            directory.stat = stat\n            dirs.push directory\n            if i is directories.length - 1\n            then return do_create_parent(dirs)\n            else return next()\n          if stat?.isDirectory()\n            end = true\n            return  if i is 0 then do_update(stat) else do_create_parent(dirs)\n          if err\n            return next err\n          else # a file or symlink exists at this location\n            return next Error \"Not a directory: #{JSON.stringify directory}\"\n      .next callback\n    do_create_parent = (directories) =>\n      @system.uid_gid\n        uid: options.uid\n        gid: options.gid\n      , (err, status, {uid, gid}) ->\n        options.uid = uid\n        options.gid = gid\n        do_create directories\n    do_create = (directories) =>\n      each(directories.reverse())\n      .call (directory, i, callback) =>\n        # Directory name contains variables\n        # eg /\\${/ on './var/cache/${user}' creates './var/cache/'\n        if options.exclude? and options.exclude instanceof RegExp\n          return callback() if options.exclude.test path.basename directory\n        options.log message: \"Create directory \\\"#{directory}\\\"\", level: 'DEBUG', module: 'nikita/lib/system/mkdir' # unless directory is options.directory\n        opts = {}\n        for attr in ['mode', 'uid', 'gid', 'size', 'atime', 'mtime']\n          val = if i is directories.length - 1 then options[attr] else options.parent?[attr]\n          opts[attr] = val if val?\n        @fs.mkdir ssh: options.ssh, target: directory, opts, (err) ->\n          return callback err if err\n          options.log message: \"Directory \\\"#{directory}\\\" created \", level: 'INFO', module: 'nikita/lib/system/mkdir'\n          state = true\n          callback()\n      .next (err) ->\n        return callback err if err\n        callback()\n    do_update = (stat) =>\n      options.log message: \"Directory already exists\", level: 'INFO', module: 'nikita/lib/system/mkdir'\n      @system.chown\n        target: directory\n        stat: stat\n        uid: options.uid\n        gid: options.gid\n        if: options.uid? or options.gid?\n      @system.chmod\n        target: directory\n        stat: stat\n        mode: options.mode\n        if: options.mode?\n      @next (err, moded) ->\n        return callback err if err\n        state = true if moded\n        callback()\n    do_stats()\n  .next (err) ->\n    callback err, state",
            "title": "Source Code"
        },
        {
            "location": "/system/mkdir.coffee/#dependencies",
            "text": "path = require 'path'\neach = require 'each'\nmisc = require '../misc'\nwrap = require '../misc/wrap'",
            "title": "Dependencies"
        },
        {
            "location": "/system/mod.coffee/",
            "text": "nikita.system.mod\n\n\nLoad a kernel module. By default, unless the \npersist\n options is \"false\",\nmodule are loaded on reboot by writing the file \"/etc/modules-load.d/{name}.conf\".\n\n\nOptions\n\n\n\n\nname\n (string)\n    Name of the module.\n\n\nload\n (booleaan) \n\n    Load the module, default is \"true\".\n\n\npersist\n (booleaan) \n\n    Load the module on startup, default is \"true\".\n\n\ntarget\n (string) \n\n    Path of the file to write the module, relative to \"/etc/modules-load.d\"\n    unless absolute, default to \"/etc/modules-load.d/{options.name}.conf\".\n\n\n\n\nExamples\n\n\nActivate the module \"vboxpci\" in the file \"/etc/modules-load.d/vboxpci.conf\":\n\n\nrequire('nikita').system.mod({\n  name: 'vboxpci'\n});\n\n\n\n\nActivate the module \"vboxpci\" in the file \"/etc/modules-load.d/my_modules.conf\":\n\n\nrequire('nikita').system.mod({\n  target: 'my_modules.conf',\n  name: 'vboxpci'\n});\n\n\n\n\nmodule.exports = (options) ->\n  options.name = options.argument if options.argument?\n  options.target ?= \"#{options.name}.conf\"\n  options.target = path.resolve '/etc/modules-load.d', options.target\n  options.load ?= true\n  options.persist ?= true\n  throw Error \"Required Option: name\" unless options.name\n  @system.execute\n    if: options.load\n    cmd: \"\"\"\n    lsmod | grep #{options.name} && exit 3\n    sudo modprobe #{options.name}\n    \"\"\"\n    code_skipped: 3\n  @file\n    if: options.persist\n    target: options.target\n    match: ///^#{quote options.name}$///m\n    replace: options.name\n    append: true\n    eof: true\n\n\n\nDependencies\n\n\npath = require 'path'\nquote = require 'regexp-quote'",
            "title": "Mod.coffee"
        },
        {
            "location": "/system/mod.coffee/#nikitasystemmod",
            "text": "Load a kernel module. By default, unless the  persist  options is \"false\",\nmodule are loaded on reboot by writing the file \"/etc/modules-load.d/{name}.conf\".",
            "title": "nikita.system.mod"
        },
        {
            "location": "/system/mod.coffee/#options",
            "text": "name  (string)\n    Name of the module.  load  (booleaan)  \n    Load the module, default is \"true\".  persist  (booleaan)  \n    Load the module on startup, default is \"true\".  target  (string)  \n    Path of the file to write the module, relative to \"/etc/modules-load.d\"\n    unless absolute, default to \"/etc/modules-load.d/{options.name}.conf\".",
            "title": "Options"
        },
        {
            "location": "/system/mod.coffee/#examples",
            "text": "Activate the module \"vboxpci\" in the file \"/etc/modules-load.d/vboxpci.conf\":  require('nikita').system.mod({\n  name: 'vboxpci'\n});  Activate the module \"vboxpci\" in the file \"/etc/modules-load.d/my_modules.conf\":  require('nikita').system.mod({\n  target: 'my_modules.conf',\n  name: 'vboxpci'\n});  module.exports = (options) ->\n  options.name = options.argument if options.argument?\n  options.target ?= \"#{options.name}.conf\"\n  options.target = path.resolve '/etc/modules-load.d', options.target\n  options.load ?= true\n  options.persist ?= true\n  throw Error \"Required Option: name\" unless options.name\n  @system.execute\n    if: options.load\n    cmd: \"\"\"\n    lsmod | grep #{options.name} && exit 3\n    sudo modprobe #{options.name}\n    \"\"\"\n    code_skipped: 3\n  @file\n    if: options.persist\n    target: options.target\n    match: ///^#{quote options.name}$///m\n    replace: options.name\n    append: true\n    eof: true",
            "title": "Examples"
        },
        {
            "location": "/system/mod.coffee/#dependencies",
            "text": "path = require 'path'\nquote = require 'regexp-quote'",
            "title": "Dependencies"
        },
        {
            "location": "/system/move.coffee/",
            "text": "nikita.system.move(options, [callback])\n\n\nMove files and directories. It is ok to overwrite the target file if it\nexists, in which case the source file will no longer exists.\n\n\nOptions\n\n\n\n\ntarget\n \n\n  Final name of the moved resource.   \n\n\nforce\n \n\n  Force the replacement of the file without checksum verification, speed up\n  the action and disable the \nmoved\n indicator in the callback.   \n\n\nsource\n \n\n  File or directory to move.   \n\n\ntarget_md5\n \n\n  Destination md5 checkum if known, otherwise computed if target\n  exists.   \n\n\nsource_md5\n \n\n  Source md5 checkum if known, otherwise computed.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value is \"true\" if resource was moved.   \n\n\n\n\nExample\n\n\nrequire('nikita').system.move({\n  source: __dirname,\n  desination: '/tmp/my_dir'\n}, function(err, status){\n  console.log(err ? err.message : 'File moved: ' + !!status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering move\", level: 'DEBUG', module: 'nikita/lib/system/move'\n  # SSH connection\n  ssh = @ssh options.ssh\n  do_exists = =>\n    options.log message: \"Stat target\", level: 'DEBUG', module: 'nikita/lib/system/move'\n    @fs.stat ssh: options.ssh, target: options.target, (err, stat) ->\n      return do_move() if err?.code is 'ENOENT'\n      return callback err if err\n      if options.force\n      then do_replace_dest()\n      else do_srchash()\n  do_srchash = ->\n    return do_dsthash() if options.source_md5\n    options.log message: \"Get source md5\", level: 'DEBUG', module: 'nikita/lib/system/move'\n    file.hash ssh, options.source, 'md5', (err, hash) ->\n      return callback err if err\n      options.log message: \"Source md5 is \\\"hash\\\"\", level: 'INFO', module: 'nikita/lib/system/move'\n      options.source_md5 = hash\n      do_dsthash()\n  do_dsthash = ->\n    return do_chkhash() if options.target_md5\n    options.log message: \"Get target md5\", level: 'DEBUG', module: 'nikita/lib/system/move'\n    file.hash ssh, options.target, 'md5', (err, hash) ->\n      return callback err if err\n      options.log message: \"Destination md5 is \\\"hash\\\"\", level: 'INFO', module: 'nikita/lib/system/move'\n      options.target_md5 = hash\n      do_chkhash()\n  do_chkhash = ->\n    if options.source_md5 is options.target_md5\n    then do_remove_src()\n    else do_replace_dest()\n  do_replace_dest = =>\n    options.log message: \"Remove #{options.target}\", level: 'WARN', module: 'nikita/lib/system/move'\n    @system.remove\n      target: options.target\n    , (err, removed) ->\n      return callback err if err\n      do_move()\n  do_move = =>\n    options.log message: \"Rename #{options.source} to #{options.target}\", level: 'WARN', module: 'nikita/lib/system/move'\n    @fs.rename ssh: options.ssh, source: options.source, target: options.target, (err) ->\n      return callback err if err\n      callback null, true\n  do_remove_src = =>\n    options.log message: \"Remove #{options.source}\", level: 'WARN', module: 'nikita/lib/system/move'\n    @system.remove\n      target: options.source\n    , (err, removed) ->\n      callback err\n  do_exists()\n\n\n\nDependencies\n\n\nfile = require '../misc/file'",
            "title": "Move.coffee"
        },
        {
            "location": "/system/move.coffee/#nikitasystemmoveoptions-callback",
            "text": "Move files and directories. It is ok to overwrite the target file if it\nexists, in which case the source file will no longer exists.",
            "title": "nikita.system.move(options, [callback])"
        },
        {
            "location": "/system/move.coffee/#options",
            "text": "target   \n  Final name of the moved resource.     force   \n  Force the replacement of the file without checksum verification, speed up\n  the action and disable the  moved  indicator in the callback.     source   \n  File or directory to move.     target_md5   \n  Destination md5 checkum if known, otherwise computed if target\n  exists.     source_md5   \n  Source md5 checkum if known, otherwise computed.",
            "title": "Options"
        },
        {
            "location": "/system/move.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value is \"true\" if resource was moved.",
            "title": "Callback parameters"
        },
        {
            "location": "/system/move.coffee/#example",
            "text": "require('nikita').system.move({\n  source: __dirname,\n  desination: '/tmp/my_dir'\n}, function(err, status){\n  console.log(err ? err.message : 'File moved: ' + !!status);\n});",
            "title": "Example"
        },
        {
            "location": "/system/move.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering move\", level: 'DEBUG', module: 'nikita/lib/system/move'\n  # SSH connection\n  ssh = @ssh options.ssh\n  do_exists = =>\n    options.log message: \"Stat target\", level: 'DEBUG', module: 'nikita/lib/system/move'\n    @fs.stat ssh: options.ssh, target: options.target, (err, stat) ->\n      return do_move() if err?.code is 'ENOENT'\n      return callback err if err\n      if options.force\n      then do_replace_dest()\n      else do_srchash()\n  do_srchash = ->\n    return do_dsthash() if options.source_md5\n    options.log message: \"Get source md5\", level: 'DEBUG', module: 'nikita/lib/system/move'\n    file.hash ssh, options.source, 'md5', (err, hash) ->\n      return callback err if err\n      options.log message: \"Source md5 is \\\"hash\\\"\", level: 'INFO', module: 'nikita/lib/system/move'\n      options.source_md5 = hash\n      do_dsthash()\n  do_dsthash = ->\n    return do_chkhash() if options.target_md5\n    options.log message: \"Get target md5\", level: 'DEBUG', module: 'nikita/lib/system/move'\n    file.hash ssh, options.target, 'md5', (err, hash) ->\n      return callback err if err\n      options.log message: \"Destination md5 is \\\"hash\\\"\", level: 'INFO', module: 'nikita/lib/system/move'\n      options.target_md5 = hash\n      do_chkhash()\n  do_chkhash = ->\n    if options.source_md5 is options.target_md5\n    then do_remove_src()\n    else do_replace_dest()\n  do_replace_dest = =>\n    options.log message: \"Remove #{options.target}\", level: 'WARN', module: 'nikita/lib/system/move'\n    @system.remove\n      target: options.target\n    , (err, removed) ->\n      return callback err if err\n      do_move()\n  do_move = =>\n    options.log message: \"Rename #{options.source} to #{options.target}\", level: 'WARN', module: 'nikita/lib/system/move'\n    @fs.rename ssh: options.ssh, source: options.source, target: options.target, (err) ->\n      return callback err if err\n      callback null, true\n  do_remove_src = =>\n    options.log message: \"Remove #{options.source}\", level: 'WARN', module: 'nikita/lib/system/move'\n    @system.remove\n      target: options.source\n    , (err, removed) ->\n      callback err\n  do_exists()",
            "title": "Source Code"
        },
        {
            "location": "/system/move.coffee/#dependencies",
            "text": "file = require '../misc/file'",
            "title": "Dependencies"
        },
        {
            "location": "/system/remove.coffee/",
            "text": "nikita.system.remove(options, [callback])\n\n\nRecursively remove files, directories and links.\n\n\nOptions\n\n\n\n\ntarget\n (string|[string])    \n\n  File, directory or glob (pattern matching based on wildcard characters).   \n\n\nsource\n (alias) \n\n  Alias for \"target\".   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value is \"true\" if files were removed.   \n\n\n\n\nImplementation details\n\n\nFiles are removed localling using the Unix \"rm\" utility. Porting \nrimraf\n over\nSSH would be too slow.\n\n\nSimple example\n\n\nrequire('nikita')\n.system.remove('./some/dir', function(err, status){\n  console.log(err ? err.message : \"File removed: \" + !!status);\n});\n\n\n\n\nRemoving a directory unless a given file exists\n\n\nrequire('nikita')\n.system.remove({\n  target: './some/dir',\n  unless_exists: './some/file'\n}, function(err, status){\n  console.log(err ? err.message : \"File removed: \" + !!status);\n});\n\n\n\n\nRemoving multiple files and directories\n\n\nrequire('nikita')\n.system.remove([\n  { target: './some/dir', unless_exists: './some/file' },\n  './some/file'\n], function(err, status){\n  console.log(err ? err.message : 'File removed: ' + !!status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering remove\", level: 'DEBUG', module: 'nikita/lib/system/remove'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Validate parameters\n  options.target = options.argument if options.argument?\n  options.target ?= options.source\n  return callback Error \"Missing option: \\\"target\\\"\" unless options.target?\n  # Start real work\n  glob ssh, options.target, (err, files) =>\n    return callback err if err\n    each files\n    .call (file, callback) =>\n      options.log message: \"Removing file #{file}\", level: 'INFO', module: 'nikita/lib/system/remove'\n      @system.execute\n        cmd: \"\"\"\n        rm -rf '#{file}'\n        \"\"\"\n      , callback\n    .next (err) ->\n      callback err, files.length\n\n\n\nDependencies\n\n\neach = require 'each'\nmisc = require '../misc'\nglob = require '../misc/glob'",
            "title": "Remove.coffee"
        },
        {
            "location": "/system/remove.coffee/#nikitasystemremoveoptions-callback",
            "text": "Recursively remove files, directories and links.",
            "title": "nikita.system.remove(options, [callback])"
        },
        {
            "location": "/system/remove.coffee/#options",
            "text": "target  (string|[string])     \n  File, directory or glob (pattern matching based on wildcard characters).     source  (alias)  \n  Alias for \"target\".",
            "title": "Options"
        },
        {
            "location": "/system/remove.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value is \"true\" if files were removed.",
            "title": "Callback parameters"
        },
        {
            "location": "/system/remove.coffee/#implementation-details",
            "text": "Files are removed localling using the Unix \"rm\" utility. Porting  rimraf  over\nSSH would be too slow.",
            "title": "Implementation details"
        },
        {
            "location": "/system/remove.coffee/#simple-example",
            "text": "require('nikita')\n.system.remove('./some/dir', function(err, status){\n  console.log(err ? err.message : \"File removed: \" + !!status);\n});",
            "title": "Simple example"
        },
        {
            "location": "/system/remove.coffee/#removing-a-directory-unless-a-given-file-exists",
            "text": "require('nikita')\n.system.remove({\n  target: './some/dir',\n  unless_exists: './some/file'\n}, function(err, status){\n  console.log(err ? err.message : \"File removed: \" + !!status);\n});",
            "title": "Removing a directory unless a given file exists"
        },
        {
            "location": "/system/remove.coffee/#removing-multiple-files-and-directories",
            "text": "require('nikita')\n.system.remove([\n  { target: './some/dir', unless_exists: './some/file' },\n  './some/file'\n], function(err, status){\n  console.log(err ? err.message : 'File removed: ' + !!status);\n});",
            "title": "Removing multiple files and directories"
        },
        {
            "location": "/system/remove.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering remove\", level: 'DEBUG', module: 'nikita/lib/system/remove'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Validate parameters\n  options.target = options.argument if options.argument?\n  options.target ?= options.source\n  return callback Error \"Missing option: \\\"target\\\"\" unless options.target?\n  # Start real work\n  glob ssh, options.target, (err, files) =>\n    return callback err if err\n    each files\n    .call (file, callback) =>\n      options.log message: \"Removing file #{file}\", level: 'INFO', module: 'nikita/lib/system/remove'\n      @system.execute\n        cmd: \"\"\"\n        rm -rf '#{file}'\n        \"\"\"\n      , callback\n    .next (err) ->\n      callback err, files.length",
            "title": "Source Code"
        },
        {
            "location": "/system/remove.coffee/#dependencies",
            "text": "each = require 'each'\nmisc = require '../misc'\nglob = require '../misc/glob'",
            "title": "Dependencies"
        },
        {
            "location": "/system/tmpfs.coffee/",
            "text": "nikita.system.tmpfs(options, callback)\n\n\nMount a directory with tmpfs.d as a \ntmpfs\n configuration file.\n\n\nOptions\n\n\n\n\nage\n (string) \n\n  Used to decide what files to delete when cleaning.\n\n\nargument\n (string) \n\n  the destination path of the symlink if type is \nL\n.\n\n\nbackup\n (string|boolean) \n\n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.\n\n\nmount\n (string) \n\n  The mount point dir to create on system startup.\n\n\nname\n (string) \n\n  The file name, can not be used with target. If only options.name is set, it\n  writes the content to default configuration directory and creates the file \n  as '\nname\n.conf'.\n\n\ntarget\n (string) \n\n  File path where to write content to. Defined to /etc/tmpfiles.d/{options.uid}.conf\n  if uid is defined or /etc/tmpfiles.d/default.conf.\n\n\ngid\n (string|integer) \n\n  File group name or group id.\n\n\nPerm\n (string) \n\n  target mount path mode in string format like \n'0644'\n.\n\n\nmerge\n (boolean) \n\n   Overrides properties if already exits.\n\n\nuid\n (string|integer) \n\n  File user name or user id.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  Wheter the directory was mounted or already mounted.\n\n\n\n\nExample\n\n\nAll parameters can be omitted except type. nikita.tmpfs will ommit by replacing \nthe undefined value as '-', which does apply the os default behavior.\n\n\nSetting uid/gid to '-', make the os creating the target owned by root:root. \n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering tmpfs action\", level: 'DEBUG', module: 'nikita/tmpfs/index'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  throw Error 'Missing Mount Point' unless options.mount?\n  # for now only support directory type path option\n  options.merge ?= true\n  options.backup ?= true\n  options.perm ?= '0644'\n  options.content  = {}\n  options.content[options.mount] = {}\n  options.content[options.mount][key] = options[key] for key in ['mount','perm','uid','gid','age','argu']\n  options.content[options.mount]['type'] = 'd'\n  if options.uid?\n    options.name ?= options.uid unless /^[0-9]+/.exec options.uid\n  options.target ?=  if options.name? then \"/etc/tmpfiles.d/#{options.name}.conf\" else '/etc/tmpfiles.d/default.conf'\n  options.log message: \"target set to #{options.target}\", level: 'DEBUG', module: 'nikita/tmpfs/index'\n  @call\n    shy: true\n    if: options.merge\n  , (_, callback) ->\n      options.log message: \"opening target file for merge\", level: 'DEBUG', module: 'nikita/tmpfs/index'\n      @fs.readFile ssh: options.ssh, target: options.target, encoding: 'utf8', (err, data) ->\n        if err\n          return callback null, false if err.code is 'ENOENT'\n          return callback err if err\n        else\n          source = misc.tmpfs.parse data\n          options.content = merge {}, source, options.content\n          options.log message: \"content has been merged\", level: 'DEBUG', module: 'nikita/tmpfs/index'\n          callback null, false\n  @call ->\n    @file options, content: misc.tmpfs.stringify(options.content), merge: false, target: options.target\n    @call\n      if: -> @status -1\n    , ->\n        options.log message: \"re-creating #{options.mount} tmpfs file\", level: 'INFO', module: 'nikita/tmpfs/index'\n        @system.execute\n          cmd: \"systemd-tmpfiles --remove #{options.target}\"\n        @system.execute\n          cmd: \"systemd-tmpfiles --create #{options.target}\"\n\n\n\nDependencies\n\n\nmisc = require '../misc'\n{merge} = require '../misc'",
            "title": "Tmpfs.coffee"
        },
        {
            "location": "/system/tmpfs.coffee/#nikitasystemtmpfsoptions-callback",
            "text": "Mount a directory with tmpfs.d as a  tmpfs  configuration file.",
            "title": "nikita.system.tmpfs(options, callback)"
        },
        {
            "location": "/system/tmpfs.coffee/#options",
            "text": "age  (string)  \n  Used to decide what files to delete when cleaning.  argument  (string)  \n  the destination path of the symlink if type is  L .  backup  (string|boolean)  \n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.  mount  (string)  \n  The mount point dir to create on system startup.  name  (string)  \n  The file name, can not be used with target. If only options.name is set, it\n  writes the content to default configuration directory and creates the file \n  as ' name .conf'.  target  (string)  \n  File path where to write content to. Defined to /etc/tmpfiles.d/{options.uid}.conf\n  if uid is defined or /etc/tmpfiles.d/default.conf.  gid  (string|integer)  \n  File group name or group id.  Perm  (string)  \n  target mount path mode in string format like  '0644' .  merge  (boolean)  \n   Overrides properties if already exits.  uid  (string|integer)  \n  File user name or user id.",
            "title": "Options"
        },
        {
            "location": "/system/tmpfs.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  Wheter the directory was mounted or already mounted.",
            "title": "Callback parameters"
        },
        {
            "location": "/system/tmpfs.coffee/#example",
            "text": "All parameters can be omitted except type. nikita.tmpfs will ommit by replacing \nthe undefined value as '-', which does apply the os default behavior.  Setting uid/gid to '-', make the os creating the target owned by root:root.",
            "title": "Example"
        },
        {
            "location": "/system/tmpfs.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering tmpfs action\", level: 'DEBUG', module: 'nikita/tmpfs/index'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  throw Error 'Missing Mount Point' unless options.mount?\n  # for now only support directory type path option\n  options.merge ?= true\n  options.backup ?= true\n  options.perm ?= '0644'\n  options.content  = {}\n  options.content[options.mount] = {}\n  options.content[options.mount][key] = options[key] for key in ['mount','perm','uid','gid','age','argu']\n  options.content[options.mount]['type'] = 'd'\n  if options.uid?\n    options.name ?= options.uid unless /^[0-9]+/.exec options.uid\n  options.target ?=  if options.name? then \"/etc/tmpfiles.d/#{options.name}.conf\" else '/etc/tmpfiles.d/default.conf'\n  options.log message: \"target set to #{options.target}\", level: 'DEBUG', module: 'nikita/tmpfs/index'\n  @call\n    shy: true\n    if: options.merge\n  , (_, callback) ->\n      options.log message: \"opening target file for merge\", level: 'DEBUG', module: 'nikita/tmpfs/index'\n      @fs.readFile ssh: options.ssh, target: options.target, encoding: 'utf8', (err, data) ->\n        if err\n          return callback null, false if err.code is 'ENOENT'\n          return callback err if err\n        else\n          source = misc.tmpfs.parse data\n          options.content = merge {}, source, options.content\n          options.log message: \"content has been merged\", level: 'DEBUG', module: 'nikita/tmpfs/index'\n          callback null, false\n  @call ->\n    @file options, content: misc.tmpfs.stringify(options.content), merge: false, target: options.target\n    @call\n      if: -> @status -1\n    , ->\n        options.log message: \"re-creating #{options.mount} tmpfs file\", level: 'INFO', module: 'nikita/tmpfs/index'\n        @system.execute\n          cmd: \"systemd-tmpfiles --remove #{options.target}\"\n        @system.execute\n          cmd: \"systemd-tmpfiles --create #{options.target}\"",
            "title": "Source Code"
        },
        {
            "location": "/system/tmpfs.coffee/#dependencies",
            "text": "misc = require '../misc'\n{merge} = require '../misc'",
            "title": "Dependencies"
        },
        {
            "location": "/system/uid_gid.coffee/",
            "text": "nikita.uid_gid(options, callback)\n\n\nNormalize the \"uid\" and \"gid\" options. A username defined by the \"uid\" option will\nbe converted to a Unix user ID and a group defined by the \"gid\" option will\nbe converted to a Unix group ID.    \n\n\nAt the moment, this only work with Unix username because it only read the\n\"/etc/passwd\" file. A future implementation might execute a system command to\nretrieve information from external identity provideds.   \n\n\nOptions\n\n\n\n\ncache\n (boolean) \n\n  Cache the result inside the store.\n\n\ngroup_target\n (string) \n\n  Path to the group definition file, default to \"/etc/group\".\n\n\npasswd_target\n (string) \n\n  Path to the passwd definition file, default to \"/etc/passwd\".\n\n\nuid\n (string|integer) \n\n  Convert the user name to a Unix ID.\n\n\ngid\n (string|integer) \n\n  Convert the group name to a Unix ID.\n\n\n\n\nExemple\n\n\nrequire('nikita').system.uid_gid({\n  uid: 'myuser',\n  gid: 'mygroup'\n}, function(err, status, {uid, gid}){\n  console.log(options.uid)\n  console.log(options.gid)\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = handler: (options, callback) ->\n  options.uid = parseInt options.uid, 10 if typeof options.uid is 'string' and /\\d+/.test options.uid\n  options.gid = parseInt options.gid, 10 if typeof options.gid is 'string' and /\\d+/.test options.gid\n  @file.types.etc_passwd.read\n    if: options.uid and typeof options.uid is 'string'\n    target: options.passwd_target\n    uid: options.uid\n    shy: false\n  , (err, status, user) ->\n    throw err if err\n    return unless status\n    options.uid = user.uid\n    options.default_gid = user.gid\n  @file.types.etc_group.read\n    if: options.gid and typeof options.gid is 'string'\n    target: options.group_target\n    gid: options.gid\n    shy: false\n  , (err, status, group) ->\n    throw err if err\n    return unless status\n    options.gid = group.gid\n  @next (err, status) ->\n    callback err, status, uid: options.uid, gid: options.gid, default_gid: options.default_gid",
            "title": "Uid gid.coffee"
        },
        {
            "location": "/system/uid_gid.coffee/#nikitauid_gidoptions-callback",
            "text": "Normalize the \"uid\" and \"gid\" options. A username defined by the \"uid\" option will\nbe converted to a Unix user ID and a group defined by the \"gid\" option will\nbe converted to a Unix group ID.      At the moment, this only work with Unix username because it only read the\n\"/etc/passwd\" file. A future implementation might execute a system command to\nretrieve information from external identity provideds.",
            "title": "nikita.uid_gid(options, callback)"
        },
        {
            "location": "/system/uid_gid.coffee/#options",
            "text": "cache  (boolean)  \n  Cache the result inside the store.  group_target  (string)  \n  Path to the group definition file, default to \"/etc/group\".  passwd_target  (string)  \n  Path to the passwd definition file, default to \"/etc/passwd\".  uid  (string|integer)  \n  Convert the user name to a Unix ID.  gid  (string|integer)  \n  Convert the group name to a Unix ID.",
            "title": "Options"
        },
        {
            "location": "/system/uid_gid.coffee/#exemple",
            "text": "require('nikita').system.uid_gid({\n  uid: 'myuser',\n  gid: 'mygroup'\n}, function(err, status, {uid, gid}){\n  console.log(options.uid)\n  console.log(options.gid)\n})",
            "title": "Exemple"
        },
        {
            "location": "/system/uid_gid.coffee/#source-code",
            "text": "module.exports = handler: (options, callback) ->\n  options.uid = parseInt options.uid, 10 if typeof options.uid is 'string' and /\\d+/.test options.uid\n  options.gid = parseInt options.gid, 10 if typeof options.gid is 'string' and /\\d+/.test options.gid\n  @file.types.etc_passwd.read\n    if: options.uid and typeof options.uid is 'string'\n    target: options.passwd_target\n    uid: options.uid\n    shy: false\n  , (err, status, user) ->\n    throw err if err\n    return unless status\n    options.uid = user.uid\n    options.default_gid = user.gid\n  @file.types.etc_group.read\n    if: options.gid and typeof options.gid is 'string'\n    target: options.group_target\n    gid: options.gid\n    shy: false\n  , (err, status, group) ->\n    throw err if err\n    return unless status\n    options.gid = group.gid\n  @next (err, status) ->\n    callback err, status, uid: options.uid, gid: options.gid, default_gid: options.default_gid",
            "title": "Source Code"
        },
        {
            "location": "/system/execute/assert.coffee/",
            "text": "nikita.system.execute.assert(options)\n\n\nAssert a shell command.\n\n\nOptions\n\n\n\n\ncontent\n (string|buffer) \n\n  Content to match, optional.\n\n\ncmd\n \n\n  String, Object or array; Command to execute.\n\n\nnot\n (boolean) \n\n  Negates the validation.   \n\n\ntrim\n (boolean) \n\n  Trim the actuel and expected content before matching, default is \"false\".\n\n\n\n\nAssert a command stdout\n\n\nnikita.system.execute({\n  cmd: 'echo hello'\n  assert: 'hello'\n}, function(err){\n  console.log(err || 'ok');\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.trim ?= false\n  options.content = options.content.toString() if Buffer.isBuffer options.content\n  options.content = options.content.trim() if options.content and options.trim\n  @call\n    if: options.content? and (typeof options.content is 'string' or Buffer.isBuffer options.content)\n  , ->\n    @system.execute options.cmd, (err, _, stdout) ->\n      throw err if err\n      stdout = stdout.trim() if options.trim\n      unless options.not\n        unless stdout is options.content\n          options.error ?= \"Invalid content: expect #{JSON.stringify options.content.toString()} and got #{JSON.stringify stdout.toString()}\"\n          err = Error options.error\n      else\n        if stdout is options.content\n          options.error ?= \"Unexpected content: #{JSON.stringify options.content.toString()}\"\n          err = Error options.error\n      throw err if err\n  @call\n    if: options.content? and options.content instanceof RegExp\n  , ->\n    @system.execute options.cmd, (err, _, stdout) ->\n      throw err if err\n      stdout = stdout.trim() if options.trim\n      unless options.not\n        unless options.content.test stdout \n          options.error ?= \"Invalid content match\"\n          err = Error options.error\n      else\n        if options.content.test stdout\n          options.error ?= \"Unexpected content match\"\n          err = Error options.error\n      throw err if err",
            "title": "Assert.coffee"
        },
        {
            "location": "/system/execute/assert.coffee/#nikitasystemexecuteassertoptions",
            "text": "Assert a shell command.",
            "title": "nikita.system.execute.assert(options)"
        },
        {
            "location": "/system/execute/assert.coffee/#options",
            "text": "content  (string|buffer)  \n  Content to match, optional.  cmd   \n  String, Object or array; Command to execute.  not  (boolean)  \n  Negates the validation.     trim  (boolean)  \n  Trim the actuel and expected content before matching, default is \"false\".",
            "title": "Options"
        },
        {
            "location": "/system/execute/assert.coffee/#assert-a-command-stdout",
            "text": "nikita.system.execute({\n  cmd: 'echo hello'\n  assert: 'hello'\n}, function(err){\n  console.log(err || 'ok');\n});",
            "title": "Assert a command stdout"
        },
        {
            "location": "/system/execute/assert.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.trim ?= false\n  options.content = options.content.toString() if Buffer.isBuffer options.content\n  options.content = options.content.trim() if options.content and options.trim\n  @call\n    if: options.content? and (typeof options.content is 'string' or Buffer.isBuffer options.content)\n  , ->\n    @system.execute options.cmd, (err, _, stdout) ->\n      throw err if err\n      stdout = stdout.trim() if options.trim\n      unless options.not\n        unless stdout is options.content\n          options.error ?= \"Invalid content: expect #{JSON.stringify options.content.toString()} and got #{JSON.stringify stdout.toString()}\"\n          err = Error options.error\n      else\n        if stdout is options.content\n          options.error ?= \"Unexpected content: #{JSON.stringify options.content.toString()}\"\n          err = Error options.error\n      throw err if err\n  @call\n    if: options.content? and options.content instanceof RegExp\n  , ->\n    @system.execute options.cmd, (err, _, stdout) ->\n      throw err if err\n      stdout = stdout.trim() if options.trim\n      unless options.not\n        unless options.content.test stdout \n          options.error ?= \"Invalid content match\"\n          err = Error options.error\n      else\n        if options.content.test stdout\n          options.error ?= \"Unexpected content match\"\n          err = Error options.error\n      throw err if err",
            "title": "Source Code"
        },
        {
            "location": "/system/execute/index.coffee/",
            "text": "nikita.system.execute(options, [callback])\n\n\nRun a command locally or with ssh if \nhost\n or \nssh\n is provided.\n\n\nExit codes\n\n\nThe properties \"code\" and \"code_skipped\" are important to determine whether an\naction failed or succeed with or without modifications. An action is expected to\nexecute successfully with modifications if the exit code match one of the value\nin \"code\", by default \"0\". Otherwise, it is considered to have failed and an\nerror is passed to the user callback. The \"code_skipped\" option is used to\ndefine one or more exit codes that are considered successfull but without\ncreating any modifications.\n\n\nOptions\n\n\n\n\narch_chroot\n (boolean|string) \n\n  Run this command inside a root directory with the arc-chroot command or any\n  provided string, require the \"rootdir\" option if activated.\n\n\nbash\n (boolean|string) \n\n  Serialize the command into a file and execute it with bash.\n\n\nrootdir\n (string) \n\n  Path to the mount point corresponding to the root directory, required if\n  the \"arch_chroot\" option is activated.\n\n\ncmd\n \n\n  String, Object or array; Command to execute.\n\n\ncode\n (int|string|array) \n\n  Expected code(s) returned by the command, int or array of int, default to 0.\n\n\ncode_skipped\n (int|string|array) \n\n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.\n\n\ndirty\n (boolean) \n\n  Leave temporary files on the filesystem.\n\n\ntrap\n \n\n  Exit immediately if a commands exits with a non-zero status.\n\n\ncwd\n \n\n  Current working directory.\n\n\nenv\n \n\n  Environment variables, default to \nprocess.env\n.\n\n\ngid\n \n\n  Unix group id.\n\n\nlog\n \n\n  Function called with a log related messages.\n\n\nstdin_log\n (boolean) \n\n  Log the executed command of type stdin, default is \"true\".\n\n\nstdout\n (stream.Writable) \n\n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.\n\n\nstdout_callback\n (boolean) \n\n  Pass stdout output to the callback as fourth argument, default is \"true\".\n\n\nstdout_log\n (boolean) \n\n  Pass stdout output to the logs of type \"stdout_stream\", default is \"true\".\n\n\nstdout_trim\n (boolean) \n\n  Trim stdout argument passed in the callback.\n\n\nstderr\n (stream.Writable) \n\n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.\n\n\nstderr_callback\n (boolean) \n\n  Pass stderr output to the callback as fourth argument, default is \"true\".\n\n\nstderr_log\n (boolean) \n\n  Pass stdout output to the logs of type \"stdout_stream\", default is \"true\".\n\n\nstderr_trim\n (boolean) \n\n  Trim stderr argument passed in the callback.\n\n\nsudo\n (boolean) \n\n  Run a command as sudo, desactivated if user is \"root\".\n\n\ntarget\n (string) \n\n  Temporary path storing the script, only apply with the bash and arch_chroot options, always disposed once executed.\n\n\nuid\n \n\n  Unix user id.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  Value is \"true\" if command exit equals option \"code\", \"0\" by default, \"false\" if\n  command exit equals option \"code_skipped\", none by default.\n\n\nstdout\n \n\n  Stdout value(s) unless \nstdout\n option is provided.\n\n\nstderr\n \n\n  Stderr value(s) unless \nstderr\n option is provided.\n\n\n\n\nCreate a user over SSH:\n\n\nThis example create a user on a remote server with the \nuseradd\n command. It\nprint the error message if the command failed or an information message if it\nsucceed.\n\n\nAn exit code equal to \"9\" defined by the \"code_skipped\" option indicates that\nthe command is considered successfull but without any impact.\n\n\nnikita.system.execute({\n  ssh: ssh,\n  cmd: 'useradd myfriend',\n  code_skipped: 9\n}, function(err, created){\n  if(err) return;\n  if(created){\n    console.log('User created');\n  }else{\n    console.log('User already exists');\n  }\n});\n\n\n\n\nRun a command with bash\n\n\nnikita.system.execute({\n  bash: true,\n  cmd: 'env'\n}, function(err, status, stdout, stderr){\n  console.log(err || stdout);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering execute\", level: 'DEBUG', module: 'nikita/lib/system/execute'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Validate parameters\n  options.cmd = options.argument if typeof options.argument is 'string'\n  options.code ?= [0]\n  options.code = [options.code] unless Array.isArray options.code\n  options.code_skipped ?= []\n  options.code_skipped = [options.code_skipped] unless Array.isArray options.code_skipped\n  options.stdin_log ?= true\n  options.stdout_log ?= true\n  options.stderr_log ?= true\n  options.stdout_callback = true if options.stdout_callback is undefined\n  options.stderr_callback = true if options.stderr_callback is undefined\n  options.cmd = options.cmd.call @, options if typeof options.cmd is 'function'\n  options.bash = 'bash' if options.bash is true\n  options.arch_chroot = 'arch-chroot' if options.arch_chroot is true\n  options.cmd = \"set -e\\n#{options.cmd}\" if options.cmd and options.trap\n  options.cmd_original = \"#{options.cmd}\"\n  throw Error \"Required Option: the \\\"cmd\\\" option is not provided\" unless options.cmd?\n  throw Error \"Incompatible Options: bash, arch_chroot\" if ['bash', 'arch_chroot'].filter((k) -> options[k]).length > 1\n  throw Error \"Required Option: \\\"rootdir\\\" with \\\"arch_chroot\\\"\" if options.arch_chroot and not options.rootdir\n  throw Error \"Invalid Option: the \\\"target\\\" option requires either one of the \\\"bash\\\" or \\\"arch_chroot\\\" options\" if options.target and not ['bash', 'arch_chroot'].filter((k) -> options[k]).length\n  result = stdout: null, stderr: null, code: null\n  # Guess current username\n  current_username =\n    if ssh then ssh.config.username\n    else if /^win/.test(process.platform) then process.env['USERPROFILE'].split(path.sep)[2]\n    else process.env['USER']\n  # Sudo\n  @call ->\n    return unless options.sudo\n    return options.sudo = false if current_username is 'root'\n    options.bash = 'bash' unless ['bash', 'arch_chroot'].some (k) -> options[k]\n  # User substitution\n  # Determines if writing is required and eventually convert uid to username\n  @call shy: true, (_, callback)->\n    return callback null, false unless options.uid\n    return callback null, false if current_username is 'root'\n    return callback null, options.uid isnt current_username unless /\\d/.test \"#{options.uid}\"\n    @system.execute \"awk -v val=#{options.uid} -F \":\" '$3==val{print $1}' /etc/passwd`\", (err, _, stdout) ->\n      options.uid = stdout.trim() unless err\n      options.bash = 'bash' unless options.bash or options.arch_chroot\n      callback err, options.uid isnt current_username\n  # Write script\n  @call\n    if: -> options.bash\n  , ->\n    cmd = options.cmd\n    options.target = \"/tmp/nikita_#{string.hash options.cmd}\" if typeof options.target isnt 'string'\n    options.log message: \"Writing bash script to #{JSON.stringify options.target}\", level: 'INFO'\n    options.cmd = \"#{options.bash} #{options.target}\"\n    options.cmd = \"su - #{options.uid} -c '#{options.cmd}'\" if options.uid\n    @fs.writeFile\n      target: options.target\n      content: cmd\n      uid: options.uid\n      sudo: false\n  @call\n    if: -> options.arch_chroot\n  , ->\n    cmd = options.cmd\n    options.target = \"/var/tmp/nikita_#{string.hash options.cmd}\" if typeof options.target isnt 'string'\n    options.log message: \"Writing arch-chroot script to #{JSON.stringify options.target}\", level: 'INFO'\n    options.cmd = \"arch-chroot #{options.rootdir} bash #{options.target}\"\n    @fs.writeFile\n      target: \"#{path.join options.rootdir, options.target}\"\n      content: \"#{cmd}\"\n      mode: options.mode\n      sudo: false\n  @call ->\n    return unless options.sudo\n    options.cmd = \"sudo #{options.cmd}\" if options.sudo\n  # Execute\n  @call (_, callback) ->\n    options.log message: options.cmd_original, type: 'stdin', level: 'INFO', module: 'nikita/lib/system/execute' if options.stdin_log\n    child = exec options, ssh: ssh\n    result.stdout = []; result.stderr = []\n    child.stdout.pipe options.stdout, end: false if options.stdout\n    child.stderr.pipe options.stderr, end: false if options.stderr\n    stdout_stream_open = stderr_stream_open = false\n    if options.stdout_callback or options.stdout_log\n      child.stdout.on 'data', (data) ->\n        stdout_stream_open = true if options.stdout_log\n        options.log message: data, type: 'stdout_stream', module: 'nikita/lib/system/execute' if options.stdout_log\n        if options.stdout_callback\n          if Array.isArray result.stdout # A string on exit\n            result.stdout.push data\n          else console.log 'stdout coming after child exit'\n    if options.stderr_callback or options.stderr_log\n      child.stderr.on 'data', (data) ->\n        stderr_stream_open = true if options.stderr_log\n        options.log message: data, type: 'stderr_stream', module: 'nikita/lib/system/execute' if options.stderr_log\n        if options.stderr_callback\n          if Array.isArray result.stderr # A string on exit\n            result.stderr.push data\n          else console.log 'stderr coming after child exit'\n    child.on \"exit\", (code) ->\n      result.code = code\n      # Give it some time because the \"exit\" event is sometimes\n      # called before the \"stdout\" \"data\" event when runing\n      # `npm test`\n      setTimeout ->\n        options.log message: null, type: 'stdout_stream', module: 'nikita/lib/system/execute' if stdout_stream_open and options.stdout_log\n        options.log message: null, type: 'stderr_stream', module: 'nikita/lib/system/execute' if  stderr_stream_open and options.stderr_log\n        result.stdout = result.stdout.map((d) -> d.toString()).join('')\n        result.stdout = result.stdout.trim() if options.trim or options.stdout_trim\n        result.stderr = result.stderr.map((d) -> d.toString()).join('')\n        result.stderr = result.stderr.trim() if options.trim or options.stderr_trim\n        options.log message: result.stdout, type: 'stdout', module: 'nikita/lib/system/execute' if result.stdout and result.stdout isnt '' and options.stdout_log\n        options.log message: result.stderr, type: 'stderr', module: 'nikita/lib/system/execute' if result.stderr and result.stderr isnt '' and options.stderr_log\n        if options.stdout\n          child.stdout.unpipe options.stdout\n        if options.stderr\n          child.stderr.unpipe options.stderr\n        if options.code.indexOf(code) is -1 and options.code_skipped.indexOf(code) is -1\n          err = Error \"Invalid Exit Code: #{code}\"\n          err.code = code\n          return callback err, null\n        if options.code_skipped.indexOf(code) is -1\n          status = true\n        else\n          options.log message: \"Skip exit code \\\"#{code}\\\"\", level: 'INFO', module: 'nikita/lib/system/execute'\n        callback null, status\n      , 1\n  @next (err1, status) ->\n    @system.remove\n      if: not options.dirty and options.target\n      target: options.target\n      always: true # todo, need to create this option (run even on error)\n      sudo: false\n    @next (err2) ->\n      callback err1 or err2, status, result.stdout, result.stderr, result.code\n\n\n\nDependencies\n\n\npath = require 'path'\nexec = require 'ssh2-exec'\nmisc = require '../../misc'\nstring = require '../../misc/string'",
            "title": "Index.coffee"
        },
        {
            "location": "/system/execute/index.coffee/#nikitasystemexecuteoptions-callback",
            "text": "Run a command locally or with ssh if  host  or  ssh  is provided.",
            "title": "nikita.system.execute(options, [callback])"
        },
        {
            "location": "/system/execute/index.coffee/#exit-codes",
            "text": "The properties \"code\" and \"code_skipped\" are important to determine whether an\naction failed or succeed with or without modifications. An action is expected to\nexecute successfully with modifications if the exit code match one of the value\nin \"code\", by default \"0\". Otherwise, it is considered to have failed and an\nerror is passed to the user callback. The \"code_skipped\" option is used to\ndefine one or more exit codes that are considered successfull but without\ncreating any modifications.",
            "title": "Exit codes"
        },
        {
            "location": "/system/execute/index.coffee/#options",
            "text": "arch_chroot  (boolean|string)  \n  Run this command inside a root directory with the arc-chroot command or any\n  provided string, require the \"rootdir\" option if activated.  bash  (boolean|string)  \n  Serialize the command into a file and execute it with bash.  rootdir  (string)  \n  Path to the mount point corresponding to the root directory, required if\n  the \"arch_chroot\" option is activated.  cmd   \n  String, Object or array; Command to execute.  code  (int|string|array)  \n  Expected code(s) returned by the command, int or array of int, default to 0.  code_skipped  (int|string|array)  \n  Expected code(s) returned by the command if it has no effect, executed will\n  not be incremented, int or array of int.  dirty  (boolean)  \n  Leave temporary files on the filesystem.  trap   \n  Exit immediately if a commands exits with a non-zero status.  cwd   \n  Current working directory.  env   \n  Environment variables, default to  process.env .  gid   \n  Unix group id.  log   \n  Function called with a log related messages.  stdin_log  (boolean)  \n  Log the executed command of type stdin, default is \"true\".  stdout  (stream.Writable)  \n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.  stdout_callback  (boolean)  \n  Pass stdout output to the callback as fourth argument, default is \"true\".  stdout_log  (boolean)  \n  Pass stdout output to the logs of type \"stdout_stream\", default is \"true\".  stdout_trim  (boolean)  \n  Trim stdout argument passed in the callback.  stderr  (stream.Writable)  \n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.  stderr_callback  (boolean)  \n  Pass stderr output to the callback as fourth argument, default is \"true\".  stderr_log  (boolean)  \n  Pass stdout output to the logs of type \"stdout_stream\", default is \"true\".  stderr_trim  (boolean)  \n  Trim stderr argument passed in the callback.  sudo  (boolean)  \n  Run a command as sudo, desactivated if user is \"root\".  target  (string)  \n  Temporary path storing the script, only apply with the bash and arch_chroot options, always disposed once executed.  uid   \n  Unix user id.",
            "title": "Options"
        },
        {
            "location": "/system/execute/index.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  Value is \"true\" if command exit equals option \"code\", \"0\" by default, \"false\" if\n  command exit equals option \"code_skipped\", none by default.  stdout   \n  Stdout value(s) unless  stdout  option is provided.  stderr   \n  Stderr value(s) unless  stderr  option is provided.",
            "title": "Callback parameters"
        },
        {
            "location": "/system/execute/index.coffee/#create-a-user-over-ssh",
            "text": "This example create a user on a remote server with the  useradd  command. It\nprint the error message if the command failed or an information message if it\nsucceed.  An exit code equal to \"9\" defined by the \"code_skipped\" option indicates that\nthe command is considered successfull but without any impact.  nikita.system.execute({\n  ssh: ssh,\n  cmd: 'useradd myfriend',\n  code_skipped: 9\n}, function(err, created){\n  if(err) return;\n  if(created){\n    console.log('User created');\n  }else{\n    console.log('User already exists');\n  }\n});",
            "title": "Create a user over SSH:"
        },
        {
            "location": "/system/execute/index.coffee/#run-a-command-with-bash",
            "text": "nikita.system.execute({\n  bash: true,\n  cmd: 'env'\n}, function(err, status, stdout, stderr){\n  console.log(err || stdout);\n});",
            "title": "Run a command with bash"
        },
        {
            "location": "/system/execute/index.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering execute\", level: 'DEBUG', module: 'nikita/lib/system/execute'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Validate parameters\n  options.cmd = options.argument if typeof options.argument is 'string'\n  options.code ?= [0]\n  options.code = [options.code] unless Array.isArray options.code\n  options.code_skipped ?= []\n  options.code_skipped = [options.code_skipped] unless Array.isArray options.code_skipped\n  options.stdin_log ?= true\n  options.stdout_log ?= true\n  options.stderr_log ?= true\n  options.stdout_callback = true if options.stdout_callback is undefined\n  options.stderr_callback = true if options.stderr_callback is undefined\n  options.cmd = options.cmd.call @, options if typeof options.cmd is 'function'\n  options.bash = 'bash' if options.bash is true\n  options.arch_chroot = 'arch-chroot' if options.arch_chroot is true\n  options.cmd = \"set -e\\n#{options.cmd}\" if options.cmd and options.trap\n  options.cmd_original = \"#{options.cmd}\"\n  throw Error \"Required Option: the \\\"cmd\\\" option is not provided\" unless options.cmd?\n  throw Error \"Incompatible Options: bash, arch_chroot\" if ['bash', 'arch_chroot'].filter((k) -> options[k]).length > 1\n  throw Error \"Required Option: \\\"rootdir\\\" with \\\"arch_chroot\\\"\" if options.arch_chroot and not options.rootdir\n  throw Error \"Invalid Option: the \\\"target\\\" option requires either one of the \\\"bash\\\" or \\\"arch_chroot\\\" options\" if options.target and not ['bash', 'arch_chroot'].filter((k) -> options[k]).length\n  result = stdout: null, stderr: null, code: null\n  # Guess current username\n  current_username =\n    if ssh then ssh.config.username\n    else if /^win/.test(process.platform) then process.env['USERPROFILE'].split(path.sep)[2]\n    else process.env['USER']\n  # Sudo\n  @call ->\n    return unless options.sudo\n    return options.sudo = false if current_username is 'root'\n    options.bash = 'bash' unless ['bash', 'arch_chroot'].some (k) -> options[k]\n  # User substitution\n  # Determines if writing is required and eventually convert uid to username\n  @call shy: true, (_, callback)->\n    return callback null, false unless options.uid\n    return callback null, false if current_username is 'root'\n    return callback null, options.uid isnt current_username unless /\\d/.test \"#{options.uid}\"\n    @system.execute \"awk -v val=#{options.uid} -F \":\" '$3==val{print $1}' /etc/passwd`\", (err, _, stdout) ->\n      options.uid = stdout.trim() unless err\n      options.bash = 'bash' unless options.bash or options.arch_chroot\n      callback err, options.uid isnt current_username\n  # Write script\n  @call\n    if: -> options.bash\n  , ->\n    cmd = options.cmd\n    options.target = \"/tmp/nikita_#{string.hash options.cmd}\" if typeof options.target isnt 'string'\n    options.log message: \"Writing bash script to #{JSON.stringify options.target}\", level: 'INFO'\n    options.cmd = \"#{options.bash} #{options.target}\"\n    options.cmd = \"su - #{options.uid} -c '#{options.cmd}'\" if options.uid\n    @fs.writeFile\n      target: options.target\n      content: cmd\n      uid: options.uid\n      sudo: false\n  @call\n    if: -> options.arch_chroot\n  , ->\n    cmd = options.cmd\n    options.target = \"/var/tmp/nikita_#{string.hash options.cmd}\" if typeof options.target isnt 'string'\n    options.log message: \"Writing arch-chroot script to #{JSON.stringify options.target}\", level: 'INFO'\n    options.cmd = \"arch-chroot #{options.rootdir} bash #{options.target}\"\n    @fs.writeFile\n      target: \"#{path.join options.rootdir, options.target}\"\n      content: \"#{cmd}\"\n      mode: options.mode\n      sudo: false\n  @call ->\n    return unless options.sudo\n    options.cmd = \"sudo #{options.cmd}\" if options.sudo\n  # Execute\n  @call (_, callback) ->\n    options.log message: options.cmd_original, type: 'stdin', level: 'INFO', module: 'nikita/lib/system/execute' if options.stdin_log\n    child = exec options, ssh: ssh\n    result.stdout = []; result.stderr = []\n    child.stdout.pipe options.stdout, end: false if options.stdout\n    child.stderr.pipe options.stderr, end: false if options.stderr\n    stdout_stream_open = stderr_stream_open = false\n    if options.stdout_callback or options.stdout_log\n      child.stdout.on 'data', (data) ->\n        stdout_stream_open = true if options.stdout_log\n        options.log message: data, type: 'stdout_stream', module: 'nikita/lib/system/execute' if options.stdout_log\n        if options.stdout_callback\n          if Array.isArray result.stdout # A string on exit\n            result.stdout.push data\n          else console.log 'stdout coming after child exit'\n    if options.stderr_callback or options.stderr_log\n      child.stderr.on 'data', (data) ->\n        stderr_stream_open = true if options.stderr_log\n        options.log message: data, type: 'stderr_stream', module: 'nikita/lib/system/execute' if options.stderr_log\n        if options.stderr_callback\n          if Array.isArray result.stderr # A string on exit\n            result.stderr.push data\n          else console.log 'stderr coming after child exit'\n    child.on \"exit\", (code) ->\n      result.code = code\n      # Give it some time because the \"exit\" event is sometimes\n      # called before the \"stdout\" \"data\" event when runing\n      # `npm test`\n      setTimeout ->\n        options.log message: null, type: 'stdout_stream', module: 'nikita/lib/system/execute' if stdout_stream_open and options.stdout_log\n        options.log message: null, type: 'stderr_stream', module: 'nikita/lib/system/execute' if  stderr_stream_open and options.stderr_log\n        result.stdout = result.stdout.map((d) -> d.toString()).join('')\n        result.stdout = result.stdout.trim() if options.trim or options.stdout_trim\n        result.stderr = result.stderr.map((d) -> d.toString()).join('')\n        result.stderr = result.stderr.trim() if options.trim or options.stderr_trim\n        options.log message: result.stdout, type: 'stdout', module: 'nikita/lib/system/execute' if result.stdout and result.stdout isnt '' and options.stdout_log\n        options.log message: result.stderr, type: 'stderr', module: 'nikita/lib/system/execute' if result.stderr and result.stderr isnt '' and options.stderr_log\n        if options.stdout\n          child.stdout.unpipe options.stdout\n        if options.stderr\n          child.stderr.unpipe options.stderr\n        if options.code.indexOf(code) is -1 and options.code_skipped.indexOf(code) is -1\n          err = Error \"Invalid Exit Code: #{code}\"\n          err.code = code\n          return callback err, null\n        if options.code_skipped.indexOf(code) is -1\n          status = true\n        else\n          options.log message: \"Skip exit code \\\"#{code}\\\"\", level: 'INFO', module: 'nikita/lib/system/execute'\n        callback null, status\n      , 1\n  @next (err1, status) ->\n    @system.remove\n      if: not options.dirty and options.target\n      target: options.target\n      always: true # todo, need to create this option (run even on error)\n      sudo: false\n    @next (err2) ->\n      callback err1 or err2, status, result.stdout, result.stderr, result.code",
            "title": "Source Code"
        },
        {
            "location": "/system/execute/index.coffee/#dependencies",
            "text": "path = require 'path'\nexec = require 'ssh2-exec'\nmisc = require '../../misc'\nstring = require '../../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/system/group/index.coffee/",
            "text": "nikita.system.group(options, [callback])\n\n\nCreate or modify a Unix group.\n\n\nOptions\n\n\n\n\ncache\n (boolean) \n\n  Retrieve groups information from cache.\n\n\nname\n \n\n  Login name of the group.   \n\n\nsystem\n \n\n  Create a system account, such user are not created with ahome by default,\n  set the \"home\" option if we it to be created.   \n\n\ngid\n \n\n  Group name or number of the user\u00b4s initial login group.   \n\n\n\n\nCallback Parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value is \"true\" if group was created or modified.   \n\n\n\n\nExample\n\n\nrequire('nikita').system.group({\n  name: 'myself'\n  system: true\n  gid: 490\n}, function(err, status){\n  console.log(err ? err.message : 'Group was created/modified: ' + status);\n});\n\n\n\n\nThe result of the above action can be viewed with the command\n\ncat /etc/group | grep myself\n producing an output similar to\n\"myself:x:490:\".\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering group\", level: 'DEBUG', module: 'nikita/lib/system/group'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  options.name = options.argument if options.argument?\n  throw Error \"Option 'name' is required\" unless options.name\n  options.system ?= false\n  options.gid ?= null\n  options.gid = parseInt options.gid, 10 if typeof options.gid is 'string'\n  throw Error 'Invalid gid option' if options.gid? and isNaN options.gid\n  info = null\n  @file.types.etc_group.read\n    cache: options.cache\n  , (err, status, groups) ->\n    info = groups[options.name]\n    options.log if info\n    then message: \"Got group information for #{JSON.stringify options.name}\", level: 'DEBUG', module: 'nikita/lib/system/group'\n    else message: \"Group #{JSON.stringify options.name} not present\", level: 'DEBUG', module: 'nikita/lib/system/group'\n  # Create group\n  @call unless: (-> info), ->\n    @system.execute\n      cmd: (\n        cmd = 'groupadd'\n        cmd += \" -r\" if options.system\n        cmd += \" -g #{options.gid}\" if options.gid?\n        cmd += \" #{options.name}\"\n      )\n      code_skipped: 9\n    , (err, status) ->\n      throw err if err\n      options.log message: \"Group defined elsewhere than '/etc/group', exit code is 9\", level: 'WARN', module: 'nikita/lib/system/group' unless status\n  # Modify group\n  @call if: (-> info), ->\n    changed = []\n    for k in ['gid']\n      changed.push 'gid' if options[k]? and \"#{info[k]}\" isnt \"#{options[k]}\"\n    options.log if changed.length\n    then message: \"Group information modified\", level: 'WARN', module: 'nikita/lib/system/group'\n    else message: \"Group information unchanged\", level: 'DEBUG', module: 'nikita/lib/system/group'\n    return unless changed.length\n    @system.execute\n      if: changed.length\n      cmd: (\n        cmd = 'groupmod'\n        cmd += \" -g #{options.gid}\" if options.gid\n        cmd += \" #{options.name}\"\n      )\n  # Reset Cache\n  @call\n    if: -> @status()\n  , ->\n    delete  @store['nikita:etc_group']",
            "title": "Index.coffee"
        },
        {
            "location": "/system/group/index.coffee/#nikitasystemgroupoptions-callback",
            "text": "Create or modify a Unix group.",
            "title": "nikita.system.group(options, [callback])"
        },
        {
            "location": "/system/group/index.coffee/#options",
            "text": "cache  (boolean)  \n  Retrieve groups information from cache.  name   \n  Login name of the group.     system   \n  Create a system account, such user are not created with ahome by default,\n  set the \"home\" option if we it to be created.     gid   \n  Group name or number of the user\u00b4s initial login group.",
            "title": "Options"
        },
        {
            "location": "/system/group/index.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value is \"true\" if group was created or modified.",
            "title": "Callback Parameters"
        },
        {
            "location": "/system/group/index.coffee/#example",
            "text": "require('nikita').system.group({\n  name: 'myself'\n  system: true\n  gid: 490\n}, function(err, status){\n  console.log(err ? err.message : 'Group was created/modified: ' + status);\n});  The result of the above action can be viewed with the command cat /etc/group | grep myself  producing an output similar to\n\"myself:x:490:\".",
            "title": "Example"
        },
        {
            "location": "/system/group/index.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering group\", level: 'DEBUG', module: 'nikita/lib/system/group'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  options.name = options.argument if options.argument?\n  throw Error \"Option 'name' is required\" unless options.name\n  options.system ?= false\n  options.gid ?= null\n  options.gid = parseInt options.gid, 10 if typeof options.gid is 'string'\n  throw Error 'Invalid gid option' if options.gid? and isNaN options.gid\n  info = null\n  @file.types.etc_group.read\n    cache: options.cache\n  , (err, status, groups) ->\n    info = groups[options.name]\n    options.log if info\n    then message: \"Got group information for #{JSON.stringify options.name}\", level: 'DEBUG', module: 'nikita/lib/system/group'\n    else message: \"Group #{JSON.stringify options.name} not present\", level: 'DEBUG', module: 'nikita/lib/system/group'\n  # Create group\n  @call unless: (-> info), ->\n    @system.execute\n      cmd: (\n        cmd = 'groupadd'\n        cmd += \" -r\" if options.system\n        cmd += \" -g #{options.gid}\" if options.gid?\n        cmd += \" #{options.name}\"\n      )\n      code_skipped: 9\n    , (err, status) ->\n      throw err if err\n      options.log message: \"Group defined elsewhere than '/etc/group', exit code is 9\", level: 'WARN', module: 'nikita/lib/system/group' unless status\n  # Modify group\n  @call if: (-> info), ->\n    changed = []\n    for k in ['gid']\n      changed.push 'gid' if options[k]? and \"#{info[k]}\" isnt \"#{options[k]}\"\n    options.log if changed.length\n    then message: \"Group information modified\", level: 'WARN', module: 'nikita/lib/system/group'\n    else message: \"Group information unchanged\", level: 'DEBUG', module: 'nikita/lib/system/group'\n    return unless changed.length\n    @system.execute\n      if: changed.length\n      cmd: (\n        cmd = 'groupmod'\n        cmd += \" -g #{options.gid}\" if options.gid\n        cmd += \" #{options.name}\"\n      )\n  # Reset Cache\n  @call\n    if: -> @status()\n  , ->\n    delete  @store['nikita:etc_group']",
            "title": "Source Code"
        },
        {
            "location": "/system/group/remove.coffee/",
            "text": "nikita.system.group.remove(options, [callback])\n\n\nCreate or modify a Unix user.\n\n\nOptions\n\n\n\n\narch_chroot\n (boolean|string) \n\n  Run this command inside a root directory with the arc-chroot command or any\n  provided string, require the \"rootdir\" option if activated.\n\n\nrootdir\n (string) \n\n  Path to the mount point corresponding to the root directory, required if\n  the \"arch_chroot\" option is activated.\n\n\nname\n \n\n  Name of the group to remove\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  Value is \"true\" if user was created or modified.\n\n\n\n\nExample\n\n\nrequire('nikita').group.remove({\n  name: 'a_user'\n}, function(err, status){\n  console.log(err ? err.message : 'User removed: ' + !!status);\n})\n\n\n\n\nThe result of the above action can be viewed with the command\n\ncat /etc/passwd | grep myself\n producing an output similar to\n\"a_user:x:490:490:A System User:/home/a_user:/bin/bash\". You can also check\nyou are a member of the \"wheel\" group (gid of \"10\") with the command\n\nid a\\_user\n producing an output similar to \n\"uid=490(hive) gid=10(wheel) groups=10(wheel)\".\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering remove\", level: 'DEBUG', module: 'nikita/lib/system/group/remove'\n  options.name = options.argument if options.argument?\n  throw Error \"Option 'name' is required\" unless options.name\n  @system.execute\n    cmd: \"groupdel #{options.name}\"\n    code_skipped: 6\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n    sudo: options.sudo",
            "title": "Remove.coffee"
        },
        {
            "location": "/system/group/remove.coffee/#nikitasystemgroupremoveoptions-callback",
            "text": "Create or modify a Unix user.",
            "title": "nikita.system.group.remove(options, [callback])"
        },
        {
            "location": "/system/group/remove.coffee/#options",
            "text": "arch_chroot  (boolean|string)  \n  Run this command inside a root directory with the arc-chroot command or any\n  provided string, require the \"rootdir\" option if activated.  rootdir  (string)  \n  Path to the mount point corresponding to the root directory, required if\n  the \"arch_chroot\" option is activated.  name   \n  Name of the group to remove",
            "title": "Options"
        },
        {
            "location": "/system/group/remove.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  Value is \"true\" if user was created or modified.",
            "title": "Callback parameters"
        },
        {
            "location": "/system/group/remove.coffee/#example",
            "text": "require('nikita').group.remove({\n  name: 'a_user'\n}, function(err, status){\n  console.log(err ? err.message : 'User removed: ' + !!status);\n})  The result of the above action can be viewed with the command cat /etc/passwd | grep myself  producing an output similar to\n\"a_user:x:490:490:A System User:/home/a_user:/bin/bash\". You can also check\nyou are a member of the \"wheel\" group (gid of \"10\") with the command id a\\_user  producing an output similar to \n\"uid=490(hive) gid=10(wheel) groups=10(wheel)\".",
            "title": "Example"
        },
        {
            "location": "/system/group/remove.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering remove\", level: 'DEBUG', module: 'nikita/lib/system/group/remove'\n  options.name = options.argument if options.argument?\n  throw Error \"Option 'name' is required\" unless options.name\n  @system.execute\n    cmd: \"groupdel #{options.name}\"\n    code_skipped: 6\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n    sudo: options.sudo",
            "title": "Source Code"
        },
        {
            "location": "/system/user/index.coffee/",
            "text": "nikita.system.user.add(options, [callback])\n\n\nCreate or modify a Unix user.\n\n\nIf the user home is provided, its parent directory will be created with root \nownerships and 0644 permissions unless it already exists.\n\n\nOptions\n\n\n\n\narch_chroot\n (boolean|string) \n\n  Run this command inside a root directory with the arc-chroot command or any\n  provided string, require the \"rootdir\" option if activated.\n\n\nrootdir\n (string) \n\n  Path to the mount point corresponding to the root directory, required if\n  the \"arch_chroot\" option is activated.\n\n\ncomment\n \n\n  Short description of the login.\n\n\nexpiredate\n \n\n  The date on which the user account is disabled.\n\n\ngid\n \n\n  Group name or number of the user\u00b4s initial login group.\n\n\ngroups\n \n\n  List of supplementary groups which the user is also a member of.\n\n\nhome\n \n\n  Value for the user\u00b4s login directory, default to the login name appended to \"BASE_DIR\".\n\n\ninactive\n \n\n  The number of days after a password has expired before the account will be\n  disabled.\n\n\nname\n \n\n  Login name of the user.\n\n\nno_home_ownership\n (boolean) \n\n  Disable ownership on home directory which default to the \"uid\" and \"gid\"\n  options, default is \"false\".\n\n\npassword\n \n\n  The unencrypted password.\n\n\npassword_sync\n \n\n  Synchronize password, default is \"true\".\n\n\nshell\n \n\n  Path to the user shell, set to \"/sbin/nologin\" if \"false\", \"/bin/bash\" if\n  true or default to the system shell value in \"/etc/default/useradd\", by\n  default \"/bin/bash\".\n\n\nskel\n \n\n  The skeleton directory, which contains files and directories to be copied in\n  the user\u00b4s home directory, when the home directory is created by useradd.\n\n\nsystem\n \n\n  Create a system account, such user are not created with a home by default,\n  set the \"home\" option if we it to be created.\n\n\nuid\n \n\n  Numerical value of the user\u00b4s ID, must not exist.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  Value is \"true\" if user was created or modified.\n\n\n\n\nExample\n\n\nrequire('nikita').user({\n  name: 'a_user',\n  system: true,\n  uid: 490,\n  gid: 10,\n  comment: 'A System User'\n}, function(err, created){\n  console.log(err ? err.message : 'User created: ' + !!created);\n})\n\n\n\n\nThe result of the above action can be viewed with the command\n\ncat /etc/passwd | grep myself\n producing an output similar to\n\"a_user:x:490:490:A System User:/home/a_user:/bin/bash\". You can also check\nyou are a member of the \"wheel\" group (gid of \"10\") with the command\n\nid a\\_user\n producing an output similar to \n\"uid=490(hive) gid=10(wheel) groups=10(wheel)\".\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering user\", level: 'DEBUG', module: 'nikita/lib/system/user/add'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  options.name = options.argument if options.argument?\n  throw Error \"Option 'name' is required\" unless options.name\n  options.shell = \"/sbin/nologin\" if options.shell is false\n  options.shell = \"/bin/bash\" if options.shell is true\n  options.system ?= false\n  options.gid ?= null\n  options.password_sync ?= true\n  options.groups = options.groups.split ',' if typeof options.groups is 'string'\n  throw Error \"Invalid option 'shell': #{JSON.strinfigy options.shell}\" if options.shell? typeof options.shell isnt 'string'\n  user_info = groups_info = null\n  @file.types.etc_passwd.read\n    cache: options.cache\n  , (err, status, users) ->\n    user_info = users[options.name]\n    options.log if user_info\n    then message: \"Got user information for #{JSON.stringify options.name}\", level: 'DEBUG', module: 'nikita/lib/system/group'\n    else message: \"User #{JSON.stringify options.name} not present\", level: 'DEBUG', module: 'nikita/lib/system/group'\n  # Get group information if\n  # * user already exists\n  # * we need to compare groups membership\n  @file.types.etc_group.read\n    if: -> user_info and options.groups\n    cache: options.cache\n  , (err, status, groups) ->\n    groups_info = groups\n    options.log message: \"Got group information for #{JSON.stringify options.name}\", level: 'DEBUG', module: 'nikita/lib/system/group' if groups_info\n  @call if: options.home, ->\n    @system.mkdir\n      unless_exists: path.dirname options.home\n      target: path.dirname options.home\n      uid: 0\n      gid: 0\n      mode: 0o0644 # Same as '/home'\n  @call unless: (-> user_info), ->\n    cmd = 'useradd'\n    cmd += \" -r\" if options.system\n    cmd += \" -M\" unless options.home\n    cmd += \" -m\" if options.home\n    cmd += \" -d #{options.home}\" if options.home\n    cmd += \" -s #{options.shell}\" if options.shell\n    cmd += \" -c #{string.escapeshellarg options.comment}\" if options.comment\n    cmd += \" -u #{options.uid}\" if options.uid\n    cmd += \" -g #{options.gid}\" if options.gid\n    cmd += \" -e #{options.expiredate}\" if options.expiredate\n    cmd += \" -f #{options.inactive}\" if options.inactive\n    cmd += \" -G #{options.groups.join ','}\" if options.groups\n    cmd += \" -k #{options.skel}\" if options.skel\n    cmd += \" #{options.name}\\n\"\n    cmd += \"chown #{options.name}. #{options.home}\" if options.home\n    @system.execute\n      cmd: cmd\n      code_skipped: 9\n      arch_chroot: options.arch_chroot\n      rootdir: options.rootdir\n      sudo: options.sudo\n    , (err, status, stdout) ->\n      throw err if err\n      options.log message: \"User defined elsewhere than '/etc/passwd', exit code is 9\", level: 'WARN', module: 'nikita/lib/system/user/add'\n  @call if: (-> user_info), ->\n    changed = []\n    for k in ['uid', 'home', 'shell', 'comment', 'gid']\n      changed.push k if options[k]? and user_info[k] isnt options[k]\n    if options.groups then for group in options.groups\n      throw Error \"Group does not exist: #{group}\" unless groups_info[group]\n      changed.push 'groups' if groups_info[group].user_list.indexOf(options.name) is -1\n    options.log if changed.length\n    then message: \"User #{options.name} modified\", level: 'WARN', module: 'nikita/lib/system/user/add'\n    else message: \"User #{options.name} not modified\", level: 'DEBUG', module: 'nikita/lib/system/user/add'\n    cmd = 'usermod'\n    cmd += \" -d #{options.home}\" if options.home\n    cmd += \" -s #{options.shell}\" if options.shell\n    cmd += \" -c #{string.escapeshellarg options.comment}\" if options.comment?\n    cmd += \" -g #{options.gid}\" if options.gid\n    cmd += \" -G #{options.groups.join ','}\" if options.groups\n    cmd += \" -u #{options.uid}\" if options.uid\n    cmd += \" #{options.name}\"\n    @system.execute\n      cmd: cmd\n      if: changed.length\n      arch_chroot: options.arch_chroot\n      rootdir: options.rootdir\n      sudo: options.sudo\n    , (err) ->\n      throw Error \"User #{options.name} is logged in\" if err?.code is 8\n    @system.chown\n      if: options.home and (options.uid or options.gid)\n      if_exists: options.home\n      unless: options.no_home_ownership\n      target: options.home\n      uid: options.uid\n      gid: options.gid\n  @call ->\n    # TODO, detect changes in password\n    # echo #{options.password} | passwd --stdin #{options.name}\n    @system.execute\n      cmd: \"\"\"\n      hash=$(echo #{options.password} | openssl passwd -1 -stdin)\n      usermod --pass=\"$hash\" #{options.name}\n      \"\"\"\n      if: options.password_sync and options.password\n      arch_chroot: options.arch_chroot\n      rootdir: options.rootdir\n      sudo: options.sudo\n    , (err, status) ->\n      throw err if err\n      options.log message: \"Password modified\", level: 'WARN', module: 'nikita/lib/system/user/add' if status\n  # Reset Cache\n  @call\n    if: -> @status()\n  , ->\n    delete  @store['nikita:etc_passwd']\n  @call\n    if: -> @status() and options.groups\n  , ->\n    delete  @store['nikita:etc_group']\n\n\n\nDependencies\n\n\npath = require 'path'\nstring = require '../../misc/string'",
            "title": "Index.coffee"
        },
        {
            "location": "/system/user/index.coffee/#nikitasystemuseraddoptions-callback",
            "text": "Create or modify a Unix user.  If the user home is provided, its parent directory will be created with root \nownerships and 0644 permissions unless it already exists.",
            "title": "nikita.system.user.add(options, [callback])"
        },
        {
            "location": "/system/user/index.coffee/#options",
            "text": "arch_chroot  (boolean|string)  \n  Run this command inside a root directory with the arc-chroot command or any\n  provided string, require the \"rootdir\" option if activated.  rootdir  (string)  \n  Path to the mount point corresponding to the root directory, required if\n  the \"arch_chroot\" option is activated.  comment   \n  Short description of the login.  expiredate   \n  The date on which the user account is disabled.  gid   \n  Group name or number of the user\u00b4s initial login group.  groups   \n  List of supplementary groups which the user is also a member of.  home   \n  Value for the user\u00b4s login directory, default to the login name appended to \"BASE_DIR\".  inactive   \n  The number of days after a password has expired before the account will be\n  disabled.  name   \n  Login name of the user.  no_home_ownership  (boolean)  \n  Disable ownership on home directory which default to the \"uid\" and \"gid\"\n  options, default is \"false\".  password   \n  The unencrypted password.  password_sync   \n  Synchronize password, default is \"true\".  shell   \n  Path to the user shell, set to \"/sbin/nologin\" if \"false\", \"/bin/bash\" if\n  true or default to the system shell value in \"/etc/default/useradd\", by\n  default \"/bin/bash\".  skel   \n  The skeleton directory, which contains files and directories to be copied in\n  the user\u00b4s home directory, when the home directory is created by useradd.  system   \n  Create a system account, such user are not created with a home by default,\n  set the \"home\" option if we it to be created.  uid   \n  Numerical value of the user\u00b4s ID, must not exist.",
            "title": "Options"
        },
        {
            "location": "/system/user/index.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  Value is \"true\" if user was created or modified.",
            "title": "Callback parameters"
        },
        {
            "location": "/system/user/index.coffee/#example",
            "text": "require('nikita').user({\n  name: 'a_user',\n  system: true,\n  uid: 490,\n  gid: 10,\n  comment: 'A System User'\n}, function(err, created){\n  console.log(err ? err.message : 'User created: ' + !!created);\n})  The result of the above action can be viewed with the command cat /etc/passwd | grep myself  producing an output similar to\n\"a_user:x:490:490:A System User:/home/a_user:/bin/bash\". You can also check\nyou are a member of the \"wheel\" group (gid of \"10\") with the command id a\\_user  producing an output similar to \n\"uid=490(hive) gid=10(wheel) groups=10(wheel)\".",
            "title": "Example"
        },
        {
            "location": "/system/user/index.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering user\", level: 'DEBUG', module: 'nikita/lib/system/user/add'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  options.name = options.argument if options.argument?\n  throw Error \"Option 'name' is required\" unless options.name\n  options.shell = \"/sbin/nologin\" if options.shell is false\n  options.shell = \"/bin/bash\" if options.shell is true\n  options.system ?= false\n  options.gid ?= null\n  options.password_sync ?= true\n  options.groups = options.groups.split ',' if typeof options.groups is 'string'\n  throw Error \"Invalid option 'shell': #{JSON.strinfigy options.shell}\" if options.shell? typeof options.shell isnt 'string'\n  user_info = groups_info = null\n  @file.types.etc_passwd.read\n    cache: options.cache\n  , (err, status, users) ->\n    user_info = users[options.name]\n    options.log if user_info\n    then message: \"Got user information for #{JSON.stringify options.name}\", level: 'DEBUG', module: 'nikita/lib/system/group'\n    else message: \"User #{JSON.stringify options.name} not present\", level: 'DEBUG', module: 'nikita/lib/system/group'\n  # Get group information if\n  # * user already exists\n  # * we need to compare groups membership\n  @file.types.etc_group.read\n    if: -> user_info and options.groups\n    cache: options.cache\n  , (err, status, groups) ->\n    groups_info = groups\n    options.log message: \"Got group information for #{JSON.stringify options.name}\", level: 'DEBUG', module: 'nikita/lib/system/group' if groups_info\n  @call if: options.home, ->\n    @system.mkdir\n      unless_exists: path.dirname options.home\n      target: path.dirname options.home\n      uid: 0\n      gid: 0\n      mode: 0o0644 # Same as '/home'\n  @call unless: (-> user_info), ->\n    cmd = 'useradd'\n    cmd += \" -r\" if options.system\n    cmd += \" -M\" unless options.home\n    cmd += \" -m\" if options.home\n    cmd += \" -d #{options.home}\" if options.home\n    cmd += \" -s #{options.shell}\" if options.shell\n    cmd += \" -c #{string.escapeshellarg options.comment}\" if options.comment\n    cmd += \" -u #{options.uid}\" if options.uid\n    cmd += \" -g #{options.gid}\" if options.gid\n    cmd += \" -e #{options.expiredate}\" if options.expiredate\n    cmd += \" -f #{options.inactive}\" if options.inactive\n    cmd += \" -G #{options.groups.join ','}\" if options.groups\n    cmd += \" -k #{options.skel}\" if options.skel\n    cmd += \" #{options.name}\\n\"\n    cmd += \"chown #{options.name}. #{options.home}\" if options.home\n    @system.execute\n      cmd: cmd\n      code_skipped: 9\n      arch_chroot: options.arch_chroot\n      rootdir: options.rootdir\n      sudo: options.sudo\n    , (err, status, stdout) ->\n      throw err if err\n      options.log message: \"User defined elsewhere than '/etc/passwd', exit code is 9\", level: 'WARN', module: 'nikita/lib/system/user/add'\n  @call if: (-> user_info), ->\n    changed = []\n    for k in ['uid', 'home', 'shell', 'comment', 'gid']\n      changed.push k if options[k]? and user_info[k] isnt options[k]\n    if options.groups then for group in options.groups\n      throw Error \"Group does not exist: #{group}\" unless groups_info[group]\n      changed.push 'groups' if groups_info[group].user_list.indexOf(options.name) is -1\n    options.log if changed.length\n    then message: \"User #{options.name} modified\", level: 'WARN', module: 'nikita/lib/system/user/add'\n    else message: \"User #{options.name} not modified\", level: 'DEBUG', module: 'nikita/lib/system/user/add'\n    cmd = 'usermod'\n    cmd += \" -d #{options.home}\" if options.home\n    cmd += \" -s #{options.shell}\" if options.shell\n    cmd += \" -c #{string.escapeshellarg options.comment}\" if options.comment?\n    cmd += \" -g #{options.gid}\" if options.gid\n    cmd += \" -G #{options.groups.join ','}\" if options.groups\n    cmd += \" -u #{options.uid}\" if options.uid\n    cmd += \" #{options.name}\"\n    @system.execute\n      cmd: cmd\n      if: changed.length\n      arch_chroot: options.arch_chroot\n      rootdir: options.rootdir\n      sudo: options.sudo\n    , (err) ->\n      throw Error \"User #{options.name} is logged in\" if err?.code is 8\n    @system.chown\n      if: options.home and (options.uid or options.gid)\n      if_exists: options.home\n      unless: options.no_home_ownership\n      target: options.home\n      uid: options.uid\n      gid: options.gid\n  @call ->\n    # TODO, detect changes in password\n    # echo #{options.password} | passwd --stdin #{options.name}\n    @system.execute\n      cmd: \"\"\"\n      hash=$(echo #{options.password} | openssl passwd -1 -stdin)\n      usermod --pass=\"$hash\" #{options.name}\n      \"\"\"\n      if: options.password_sync and options.password\n      arch_chroot: options.arch_chroot\n      rootdir: options.rootdir\n      sudo: options.sudo\n    , (err, status) ->\n      throw err if err\n      options.log message: \"Password modified\", level: 'WARN', module: 'nikita/lib/system/user/add' if status\n  # Reset Cache\n  @call\n    if: -> @status()\n  , ->\n    delete  @store['nikita:etc_passwd']\n  @call\n    if: -> @status() and options.groups\n  , ->\n    delete  @store['nikita:etc_group']",
            "title": "Source Code"
        },
        {
            "location": "/system/user/index.coffee/#dependencies",
            "text": "path = require 'path'\nstring = require '../../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/system/user/remove.coffee/",
            "text": "nikita.system.user.remove(options, [callback])\n\n\nCreate or modify a Unix user.\n\n\nOptions\n\n\n\n\narch_chroot\n (boolean|string) \n\n  Run this command inside a root directory with the arc-chroot command or any\n  provided string, require the \"rootdir\" option if activated.\n\n\nrootdir\n (string) \n\n  Path to the mount point corresponding to the root directory, required if\n  the \"arch_chroot\" option is activated.\n\n\nname\n \n\n  Name of the user to removed.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  Value is \"true\" if user was created or modified.\n\n\n\n\nExample\n\n\nrequire('nikita').user.remove({\n  name: 'a_user'\n}, function(err, status){\n  console.log(err ? err.message : 'User removed: ' + !!status);\n})\n\n\n\n\nThe result of the above action can be viewed with the command\n\ncat /etc/passwd | grep myself\n producing an output similar to\n\"a_user:x:490:490:A System User:/home/a_user:/bin/bash\". You can also check\nyou are a member of the \"wheel\" group (gid of \"10\") with the command\n\nid a\\_user\n producing an output similar to \n\"uid=490(hive) gid=10(wheel) groups=10(wheel)\".\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering remove\", level: 'DEBUG', module: 'nikita/lib/system/user/remove'\n  options.name = options.argument if options.argument?\n  throw Error \"Option 'name' is required\" unless options.name\n  @system.execute\n    cmd: \"userdel #{options.name}\"\n    code_skipped: 6\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n    sudo: options.sudo",
            "title": "Remove.coffee"
        },
        {
            "location": "/system/user/remove.coffee/#nikitasystemuserremoveoptions-callback",
            "text": "Create or modify a Unix user.",
            "title": "nikita.system.user.remove(options, [callback])"
        },
        {
            "location": "/system/user/remove.coffee/#options",
            "text": "arch_chroot  (boolean|string)  \n  Run this command inside a root directory with the arc-chroot command or any\n  provided string, require the \"rootdir\" option if activated.  rootdir  (string)  \n  Path to the mount point corresponding to the root directory, required if\n  the \"arch_chroot\" option is activated.  name   \n  Name of the user to removed.",
            "title": "Options"
        },
        {
            "location": "/system/user/remove.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  Value is \"true\" if user was created or modified.",
            "title": "Callback parameters"
        },
        {
            "location": "/system/user/remove.coffee/#example",
            "text": "require('nikita').user.remove({\n  name: 'a_user'\n}, function(err, status){\n  console.log(err ? err.message : 'User removed: ' + !!status);\n})  The result of the above action can be viewed with the command cat /etc/passwd | grep myself  producing an output similar to\n\"a_user:x:490:490:A System User:/home/a_user:/bin/bash\". You can also check\nyou are a member of the \"wheel\" group (gid of \"10\") with the command id a\\_user  producing an output similar to \n\"uid=490(hive) gid=10(wheel) groups=10(wheel)\".",
            "title": "Example"
        },
        {
            "location": "/system/user/remove.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering remove\", level: 'DEBUG', module: 'nikita/lib/system/user/remove'\n  options.name = options.argument if options.argument?\n  throw Error \"Option 'name' is required\" unless options.name\n  @system.execute\n    cmd: \"userdel #{options.name}\"\n    code_skipped: 6\n    arch_chroot: options.arch_chroot\n    rootdir: options.rootdir\n    sudo: options.sudo",
            "title": "Source Code"
        },
        {
            "location": "/tools/backup.coffee/",
            "text": "nikita.tools.backup(options, [callback])\n\n\nBackup a file, a directory or the output of a command.\n\n\nOptions\n\n\n\n\nname\n (string) \n\n  Backup file name, required.   \n\n\ncmd\n (string)    \n\n  Command from which to pipe the ouptut or generating a file if the \"target\" \n  option is defined.   \n\n\nformat\n (string) \n\n  Format used to name the backup directory, used by [Moment.js], default to \n  \"ISO-8601\".   \n\n\nlocale\n (string) \n\n  Locale used to name the backup directory, used by [Moment.js], default to \n  UTC.   \n\n\ncompress\n \n\n  One of \"tgz\", \"tar\", \"xz\", \"bz2\" or \"zip\", default to \"tgz\" if true or a directory otherwise no compression.   \n\n\nsource\n (string) \n\n  Path to a file or a directory to backup.   \n\n\ntarget\n (string)\n  Directory storing the backup, required.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n (Error) \n\n  Error object if any.   \n\n\nstatus\n  (boolean) \n\n  Value is \"true\" if backup was created.   \n\n\ninfo\n (object) \n\n  backup passes options to a callback. Info contains \noptions\n properties with default\n  and/or generated missing values.   \n\n\n\n\nBackup a directory\n\n\nnikita.tools.backup({\n  name: 'my_backup'\n  source: '/etc'\n  target: '/tmp/backup'\n  algorithm: 'gzip' # Value are \"gzip\", \"bzip2\", \"xz\" or \"none\"\n  extension: 'tgz'\n  # retention: {\n  #   count: 3\n  #   date: '2015-01-01-00:00:00'\n  #   age: month: 2\n  # }\n}, function(err, status, info){\n  console.log(info);\n});\n\n\n\n\nSource code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering backup\", level: 'DEBUG', module: 'nikita/lib/tools/backup'\n  throw  Error 'Missing option: \"target\"' unless options.target\n  throw  Error 'Missing option: \"name\"' unless options.name\n  m = moment()\n  if options.locale then m.locale(options.locale) else m.utc()\n  filename = m.format(options.format)\n  target = \"#{options.target}/#{options.name}/#{filename}\"\n  compress = options.compress\n  compress = 'tgz' if compress is true or not compress\n  options.log message: \"Source is #{JSON.stringify options.source}\", level: 'INFO', module: 'nikita/lib/tools/backup'\n  options.log message: \"Target is #{JSON.stringify target}\", level: 'INFO', module: 'nikita/lib/tools/backup'\n  @system.mkdir \"#{path.dirname target}\"\n  @call if: options.source, ->\n    @system.copy\n      if: options.source\n      # if_exec: \"[ -f #{options.source} ]\"\n      unless: options.compress\n      target: \"#{target}\"\n      source: \"#{options.source}\"\n    @tools.compress\n      source: \"#{options.source}\"\n      target: \"#{target}.#{compress}\"\n      format: \"#{compress}\"\n      if: -> options.compress\n    , (err) ->\n      throw err unless err\n      filename = \"#{filename}.tgz\"\n  @system.execute\n    cmd: \"#{options.cmd} > #{target}\"\n    if: options.cmd\n  @next (err, status) ->\n    callback err, status,\n      base_dir: options.target\n      name: options.name\n      filename: filename\n      target: target\n\n\n\nDependencies\n\n\nmoment = require 'moment'\npath = require 'path'",
            "title": "Backup.coffee"
        },
        {
            "location": "/tools/backup.coffee/#nikitatoolsbackupoptions-callback",
            "text": "Backup a file, a directory or the output of a command.",
            "title": "nikita.tools.backup(options, [callback])"
        },
        {
            "location": "/tools/backup.coffee/#options",
            "text": "name  (string)  \n  Backup file name, required.     cmd  (string)     \n  Command from which to pipe the ouptut or generating a file if the \"target\" \n  option is defined.     format  (string)  \n  Format used to name the backup directory, used by [Moment.js], default to \n  \"ISO-8601\".     locale  (string)  \n  Locale used to name the backup directory, used by [Moment.js], default to \n  UTC.     compress   \n  One of \"tgz\", \"tar\", \"xz\", \"bz2\" or \"zip\", default to \"tgz\" if true or a directory otherwise no compression.     source  (string)  \n  Path to a file or a directory to backup.     target  (string)\n  Directory storing the backup, required.",
            "title": "Options"
        },
        {
            "location": "/tools/backup.coffee/#callback-parameters",
            "text": "err  (Error)  \n  Error object if any.     status   (boolean)  \n  Value is \"true\" if backup was created.     info  (object)  \n  backup passes options to a callback. Info contains  options  properties with default\n  and/or generated missing values.",
            "title": "Callback parameters"
        },
        {
            "location": "/tools/backup.coffee/#backup-a-directory",
            "text": "nikita.tools.backup({\n  name: 'my_backup'\n  source: '/etc'\n  target: '/tmp/backup'\n  algorithm: 'gzip' # Value are \"gzip\", \"bzip2\", \"xz\" or \"none\"\n  extension: 'tgz'\n  # retention: {\n  #   count: 3\n  #   date: '2015-01-01-00:00:00'\n  #   age: month: 2\n  # }\n}, function(err, status, info){\n  console.log(info);\n});",
            "title": "Backup a directory"
        },
        {
            "location": "/tools/backup.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering backup\", level: 'DEBUG', module: 'nikita/lib/tools/backup'\n  throw  Error 'Missing option: \"target\"' unless options.target\n  throw  Error 'Missing option: \"name\"' unless options.name\n  m = moment()\n  if options.locale then m.locale(options.locale) else m.utc()\n  filename = m.format(options.format)\n  target = \"#{options.target}/#{options.name}/#{filename}\"\n  compress = options.compress\n  compress = 'tgz' if compress is true or not compress\n  options.log message: \"Source is #{JSON.stringify options.source}\", level: 'INFO', module: 'nikita/lib/tools/backup'\n  options.log message: \"Target is #{JSON.stringify target}\", level: 'INFO', module: 'nikita/lib/tools/backup'\n  @system.mkdir \"#{path.dirname target}\"\n  @call if: options.source, ->\n    @system.copy\n      if: options.source\n      # if_exec: \"[ -f #{options.source} ]\"\n      unless: options.compress\n      target: \"#{target}\"\n      source: \"#{options.source}\"\n    @tools.compress\n      source: \"#{options.source}\"\n      target: \"#{target}.#{compress}\"\n      format: \"#{compress}\"\n      if: -> options.compress\n    , (err) ->\n      throw err unless err\n      filename = \"#{filename}.tgz\"\n  @system.execute\n    cmd: \"#{options.cmd} > #{target}\"\n    if: options.cmd\n  @next (err, status) ->\n    callback err, status,\n      base_dir: options.target\n      name: options.name\n      filename: filename\n      target: target",
            "title": "Source code"
        },
        {
            "location": "/tools/backup.coffee/#dependencies",
            "text": "moment = require 'moment'\npath = require 'path'",
            "title": "Dependencies"
        },
        {
            "location": "/tools/compress.coffee/",
            "text": "nikita.tools.compress(options, [callback])\n\n\nCompress an archive. Multiple compression types are supported. Unless\nspecified as an option, format is derived from the source extension. At the\nmoment, supported extensions are '.tgz', '.tar.gz', 'tar.xz', 'tar.bz2' and '.zip'.\n\n\nOptions\n\n\n\n\nformat\n \n\n  One of 'tgz', 'tar', 'xz', 'bz2' or 'zip'.   \n\n\nsource\n \n\n  Archive to compress.   \n\n\ntarget\n \n\n  Default to the source parent directory.   \n\n\nclean\n \n\n  Remove the source file or directory\n\n\n\n\nCallback Parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value is \"true\" if file was compressed.   \n\n\n\n\nExample\n\n\nrequire('nikita').tools.compress({\n  source: '/path/to/file.tgz'\n  destation: '/tmp'\n}, function(err, status){\n  console.log(err ? err.message : 'File was compressed: ' + status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering compress\", level: 'DEBUG', module: 'nikita/lib/tools/compress'\n  # Validate parameters\n  throw Error \"Missing source: #{options.source}\" unless options.source\n  throw Error \"Missing target: #{options.target}\" unless options.target\n  options.source = path.normalize options.source\n  options.target = path.normalize options.target\n  dir = path.dirname options.source\n  name = path.basename options.source\n  # Deal with format option\n  if options.format?\n    format = options.format\n  else\n    format = module.exports.ext_to_type options.target\n  # Run compression\n  @system.execute switch format\n    when 'tgz' then \"tar czf #{options.target} -C #{dir} #{name}\"\n    when 'tar' then \"tar cf  #{options.target} -C #{dir} #{name}\"\n    when 'bz2' then \"tar cjf #{options.target} -C #{dir} #{name}\"\n    when 'xz'  then \"tar cJf #{options.target} -C #{dir} #{name}\"\n    when 'zip' then \"(cd #{dir} && zip -r #{options.target} #{name} && cd -)\"\n  @system.remove\n    if: options.clean\n    source: options.source\n\n\n\nType of extension\n\n\nmodule.exports.type_to_ext = (type) ->\n  return \".#{type}\" if type in ['tgz', 'tar', 'zip', 'bz2', 'xz']\n  throw Error \"Unsupported Type: #{JSON.stringify(type)}\"\n\n\n\nExtention to type\n\n\nConvert a full path, a filename or an extension into a supported compression \ntype.\n\n\nmodule.exports.ext_to_type = (name) ->\n  if /((.+\\.)|^\\.|^)(tar\\.gz|tgz)$/.test name then 'tgz'\n  else if /((.+\\.)|^\\.|^)tar$/.test name then 'tar'\n  else if /((.+\\.)|^\\.|^)zip$/.test name then 'zip'\n  else if /((.+\\.)|^\\.|^)bz2$/.test name then 'bz2'\n  else if /((.+\\.)|^\\.|^)xz$/.test name then 'xz'\n  else\n    throw Error \"Unsupported Extension: #{JSON.stringify(path.extname name)}\"\n\n\n\nDependencies\n\n\npath = require 'path'",
            "title": "Compress.coffee"
        },
        {
            "location": "/tools/compress.coffee/#nikitatoolscompressoptions-callback",
            "text": "Compress an archive. Multiple compression types are supported. Unless\nspecified as an option, format is derived from the source extension. At the\nmoment, supported extensions are '.tgz', '.tar.gz', 'tar.xz', 'tar.bz2' and '.zip'.",
            "title": "nikita.tools.compress(options, [callback])"
        },
        {
            "location": "/tools/compress.coffee/#options",
            "text": "format   \n  One of 'tgz', 'tar', 'xz', 'bz2' or 'zip'.     source   \n  Archive to compress.     target   \n  Default to the source parent directory.     clean   \n  Remove the source file or directory",
            "title": "Options"
        },
        {
            "location": "/tools/compress.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value is \"true\" if file was compressed.",
            "title": "Callback Parameters"
        },
        {
            "location": "/tools/compress.coffee/#example",
            "text": "require('nikita').tools.compress({\n  source: '/path/to/file.tgz'\n  destation: '/tmp'\n}, function(err, status){\n  console.log(err ? err.message : 'File was compressed: ' + status);\n});",
            "title": "Example"
        },
        {
            "location": "/tools/compress.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering compress\", level: 'DEBUG', module: 'nikita/lib/tools/compress'\n  # Validate parameters\n  throw Error \"Missing source: #{options.source}\" unless options.source\n  throw Error \"Missing target: #{options.target}\" unless options.target\n  options.source = path.normalize options.source\n  options.target = path.normalize options.target\n  dir = path.dirname options.source\n  name = path.basename options.source\n  # Deal with format option\n  if options.format?\n    format = options.format\n  else\n    format = module.exports.ext_to_type options.target\n  # Run compression\n  @system.execute switch format\n    when 'tgz' then \"tar czf #{options.target} -C #{dir} #{name}\"\n    when 'tar' then \"tar cf  #{options.target} -C #{dir} #{name}\"\n    when 'bz2' then \"tar cjf #{options.target} -C #{dir} #{name}\"\n    when 'xz'  then \"tar cJf #{options.target} -C #{dir} #{name}\"\n    when 'zip' then \"(cd #{dir} && zip -r #{options.target} #{name} && cd -)\"\n  @system.remove\n    if: options.clean\n    source: options.source",
            "title": "Source Code"
        },
        {
            "location": "/tools/compress.coffee/#type-of-extension",
            "text": "module.exports.type_to_ext = (type) ->\n  return \".#{type}\" if type in ['tgz', 'tar', 'zip', 'bz2', 'xz']\n  throw Error \"Unsupported Type: #{JSON.stringify(type)}\"",
            "title": "Type of extension"
        },
        {
            "location": "/tools/compress.coffee/#extention-to-type",
            "text": "Convert a full path, a filename or an extension into a supported compression \ntype.  module.exports.ext_to_type = (name) ->\n  if /((.+\\.)|^\\.|^)(tar\\.gz|tgz)$/.test name then 'tgz'\n  else if /((.+\\.)|^\\.|^)tar$/.test name then 'tar'\n  else if /((.+\\.)|^\\.|^)zip$/.test name then 'zip'\n  else if /((.+\\.)|^\\.|^)bz2$/.test name then 'bz2'\n  else if /((.+\\.)|^\\.|^)xz$/.test name then 'xz'\n  else\n    throw Error \"Unsupported Extension: #{JSON.stringify(path.extname name)}\"",
            "title": "Extention to type"
        },
        {
            "location": "/tools/compress.coffee/#dependencies",
            "text": "path = require 'path'",
            "title": "Dependencies"
        },
        {
            "location": "/tools/extract.coffee/",
            "text": "nikita.tools.extract(options, [callback])\n\n\nExtract an archive. Multiple compression types are supported. Unless\nspecified as an option, format is derived from the source extension. At the\nmoment, supported extensions are '.tgz', '.tar.gz', tar.bz2, 'tar.xz' and '.zip'.\n\n\nOptions\n\n\n\n\ncreates\n \n\n  Ensure the given file is created or an error is send in the callback.  \n\n\nformat\n \n\n  One of 'tgz', 'tar', 'xz', 'bz2' or 'zip'.   \n\n\npreserve_owner\n \n\n  Preserve ownership when extracting. True by default if runned as root, else false.   \n\n\npreserve_permissions\n \n\n  Preserve permissions when extracting. True by default if runned as root, else false.   \n\n\nsource\n \n\n  Archive to decompress.   \n\n\nstrip\n \n\n  Remove the specified number of leading path elements. Apply only to tar(s) formats.   \n\n\ntarget\n \n\n  Default to the source parent directory.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nextracted\n \n\n  Value is \"true\" if archive was extracted.   \n\n\n\n\nExample\n\n\nrequire('nikita').tools.extract({\n  source: '/path/to/file.tgz'\n  destation: '/tmp'\n}, function(err, status){\n  console.log(err ? err.message : 'File was extracted: ' + status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering extract\", level: 'DEBUG', module: 'nikita/lib/tools/extract'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Validate options\n  return callback Error \"Missing source: #{options.source}\" unless options.source\n  target = options.target ? path.dirname options.source\n  tar_opts = []\n  # If undefined, we do not apply flag. Default behaviour depends on the user\n  if options.preserve_owner is true\n    tar_opts.push '--same-owner'\n  else if options.preserve_owner is false\n    tar_opts.push '--no-same-owner'\n  if options.preserve_permissions is true\n    tar_opts.push '-p'\n  else if options.preserve_permissions is false\n    tar_opts.push '--no-same-permissions'\n  if typeof options.strip is 'number'\n    tar_opts.push \"--strip-components #{options.strip}\"\n  # Deal with format option\n  if options.format?\n    format = options.format\n  else\n    if /\\.(tar\\.gz|tgz)$/.test options.source\n      format = 'tgz'\n    else if /\\.tar$/.test options.source\n      format = 'tar'\n    else if /\\.zip$/.test options.source\n      format = 'zip'\n    else if /\\.tar\\.bz2$/.test options.source\n      format = 'bz2'\n    else if /\\.tar\\.xz$/.test options.source\n      format = 'xz'\n    else\n      ext = path.extname options.source\n      return callback Error \"Unsupported extension, got #{JSON.stringify(ext)}\"\n  # Start real work\n  stat = =>\n    @fs.stat ssh: options.ssh, target: options.source, (err, stat) ->\n      return callback Error \"File does not exist: #{options.source}\" if err\n      return callback Error \"Not a File: #{options.source}\" unless stat.isFile()\n      extract()\n  extract = =>\n    cmd = null\n    options.log message: \"Format is #{format}\", level: 'DEBUG', module: 'nikita/lib/tools/extract'\n    switch format\n      when 'tgz' then cmd = \"tar xzf #{options.source} -C #{target} #{tar_opts.join ' '}\"\n      when 'tar' then cmd = \"tar xf #{options.source} -C #{target} #{tar_opts.join ' '}\"\n      when 'bz2' then cmd = \"tar xjf #{options.source} -C #{target} #{tar_opts.join ' '}\"\n      when 'xz'  then cmd = \"tar xJf #{options.source} -C #{target} #{tar_opts.join ' '}\"\n      when 'zip' then cmd = \"unzip -u #{options.source} -d #{target}\"\n    @system.execute\n      cmd: cmd\n    , (err, created) ->\n      return callback err if err\n      creates()\n  # Step for `creates`\n  creates = =>\n    return success() unless options.creates?\n    @fs.exists ssh: options.ssh, target: options.creates, (err, exists) ->\n      return callback Error \"Failed to create '#{path.basename options.creates}'\" unless exists\n      success()\n  # Final step\n  success = ->\n    callback null, true\n  stat()\n\n\n\nDependencies\n\n\npath = require 'path'",
            "title": "Extract.coffee"
        },
        {
            "location": "/tools/extract.coffee/#nikitatoolsextractoptions-callback",
            "text": "Extract an archive. Multiple compression types are supported. Unless\nspecified as an option, format is derived from the source extension. At the\nmoment, supported extensions are '.tgz', '.tar.gz', tar.bz2, 'tar.xz' and '.zip'.",
            "title": "nikita.tools.extract(options, [callback])"
        },
        {
            "location": "/tools/extract.coffee/#options",
            "text": "creates   \n  Ensure the given file is created or an error is send in the callback.    format   \n  One of 'tgz', 'tar', 'xz', 'bz2' or 'zip'.     preserve_owner   \n  Preserve ownership when extracting. True by default if runned as root, else false.     preserve_permissions   \n  Preserve permissions when extracting. True by default if runned as root, else false.     source   \n  Archive to decompress.     strip   \n  Remove the specified number of leading path elements. Apply only to tar(s) formats.     target   \n  Default to the source parent directory.",
            "title": "Options"
        },
        {
            "location": "/tools/extract.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     extracted   \n  Value is \"true\" if archive was extracted.",
            "title": "Callback parameters"
        },
        {
            "location": "/tools/extract.coffee/#example",
            "text": "require('nikita').tools.extract({\n  source: '/path/to/file.tgz'\n  destation: '/tmp'\n}, function(err, status){\n  console.log(err ? err.message : 'File was extracted: ' + status);\n});",
            "title": "Example"
        },
        {
            "location": "/tools/extract.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering extract\", level: 'DEBUG', module: 'nikita/lib/tools/extract'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Validate options\n  return callback Error \"Missing source: #{options.source}\" unless options.source\n  target = options.target ? path.dirname options.source\n  tar_opts = []\n  # If undefined, we do not apply flag. Default behaviour depends on the user\n  if options.preserve_owner is true\n    tar_opts.push '--same-owner'\n  else if options.preserve_owner is false\n    tar_opts.push '--no-same-owner'\n  if options.preserve_permissions is true\n    tar_opts.push '-p'\n  else if options.preserve_permissions is false\n    tar_opts.push '--no-same-permissions'\n  if typeof options.strip is 'number'\n    tar_opts.push \"--strip-components #{options.strip}\"\n  # Deal with format option\n  if options.format?\n    format = options.format\n  else\n    if /\\.(tar\\.gz|tgz)$/.test options.source\n      format = 'tgz'\n    else if /\\.tar$/.test options.source\n      format = 'tar'\n    else if /\\.zip$/.test options.source\n      format = 'zip'\n    else if /\\.tar\\.bz2$/.test options.source\n      format = 'bz2'\n    else if /\\.tar\\.xz$/.test options.source\n      format = 'xz'\n    else\n      ext = path.extname options.source\n      return callback Error \"Unsupported extension, got #{JSON.stringify(ext)}\"\n  # Start real work\n  stat = =>\n    @fs.stat ssh: options.ssh, target: options.source, (err, stat) ->\n      return callback Error \"File does not exist: #{options.source}\" if err\n      return callback Error \"Not a File: #{options.source}\" unless stat.isFile()\n      extract()\n  extract = =>\n    cmd = null\n    options.log message: \"Format is #{format}\", level: 'DEBUG', module: 'nikita/lib/tools/extract'\n    switch format\n      when 'tgz' then cmd = \"tar xzf #{options.source} -C #{target} #{tar_opts.join ' '}\"\n      when 'tar' then cmd = \"tar xf #{options.source} -C #{target} #{tar_opts.join ' '}\"\n      when 'bz2' then cmd = \"tar xjf #{options.source} -C #{target} #{tar_opts.join ' '}\"\n      when 'xz'  then cmd = \"tar xJf #{options.source} -C #{target} #{tar_opts.join ' '}\"\n      when 'zip' then cmd = \"unzip -u #{options.source} -d #{target}\"\n    @system.execute\n      cmd: cmd\n    , (err, created) ->\n      return callback err if err\n      creates()\n  # Step for `creates`\n  creates = =>\n    return success() unless options.creates?\n    @fs.exists ssh: options.ssh, target: options.creates, (err, exists) ->\n      return callback Error \"Failed to create '#{path.basename options.creates}'\" unless exists\n      success()\n  # Final step\n  success = ->\n    callback null, true\n  stat()",
            "title": "Source Code"
        },
        {
            "location": "/tools/extract.coffee/#dependencies",
            "text": "path = require 'path'",
            "title": "Dependencies"
        },
        {
            "location": "/tools/git.coffee/",
            "text": "nikita.tools.git(options, [callback])\n\n\nCreate and synchronize a git repository.\n\n\nOptions\n\n\n\n\nsource\n \n\n  Git source repository address.   \n\n\ntarget\n \n\n  Directory where to clone the repository.   \n\n\nrevision\n \n\n  Git revision, branch or tag.   \n\n\n\n\nCallback Parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value \"true\" if repository was created or modified.   \n\n\n\n\nExample\n\n\nThe following action make sure the git repository is synchronized to the latest\nHEAD revision.\n\n\nrequire('nikita').tools.git({\n  source: 'https://github.com/wdavidw/node-nikita.git'\n  target: '/tmp/nikita'\n}, function(err, synchronized){\n  console.log(err ? err.message : 'Repo was synchronized: ' + synchronized);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering git\", level: 'DEBUG', module: 'nikita/lib/tools/git'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Sanitize options\n  options.revision ?= 'HEAD'\n  # Start real work\n  repo_exists = false\n  repo_uptodate = false\n  @call (_, callback) ->\n    @fs.exists ssh: options.ssh, target: options.target, (err, exists) ->\n      return callback err if err\n      repo_exists = exists\n      return callback() unless exists # todo, isolate inside call when they receive conditions\n      # return callback Error \"Destination not a directory, got #{options.target}\" unless stat.isDirectory()\n      gitDir = \"#{options.target}/.git\"\n      @fs.exists ssh: options.ssh, target: gitDir, (err, exists) ->\n        return callback Error \"Not a git repository\" unless exists\n        callback()\n  @system.execute\n    cmd: \"git clone #{options.source} #{options.target}\"\n    cwd: path.dirname options.target\n    unless: -> repo_exists\n  @system.execute\n    cmd: \"\"\"\n    current=`git log --pretty=format:'%H' -n 1`\n    target=`git rev-list --max-count=1 #{options.revision}`\n    echo \"current revision: $current\"\n    echo \"expected revision: $target\"\n    if [ $current != $target ]; then exit 3; fi\n    \"\"\"\n    # stdout: process.stdout\n    cwd: options.target\n    trap: true\n    code_skipped: 3\n    if: -> repo_exists\n    shy: true\n  , (err, uptodate) ->\n    throw err if err\n    repo_uptodate = uptodate\n  @system.execute\n    cmd: \"git checkout #{options.revision}\"\n    cwd: options.target\n    unless: -> repo_uptodate\n\n\n\nDependencies\n\n\npath = require 'path'",
            "title": "Git.coffee"
        },
        {
            "location": "/tools/git.coffee/#nikitatoolsgitoptions-callback",
            "text": "Create and synchronize a git repository.",
            "title": "nikita.tools.git(options, [callback])"
        },
        {
            "location": "/tools/git.coffee/#options",
            "text": "source   \n  Git source repository address.     target   \n  Directory where to clone the repository.     revision   \n  Git revision, branch or tag.",
            "title": "Options"
        },
        {
            "location": "/tools/git.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value \"true\" if repository was created or modified.",
            "title": "Callback Parameters"
        },
        {
            "location": "/tools/git.coffee/#example",
            "text": "The following action make sure the git repository is synchronized to the latest\nHEAD revision.  require('nikita').tools.git({\n  source: 'https://github.com/wdavidw/node-nikita.git'\n  target: '/tmp/nikita'\n}, function(err, synchronized){\n  console.log(err ? err.message : 'Repo was synchronized: ' + synchronized);\n});",
            "title": "Example"
        },
        {
            "location": "/tools/git.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering git\", level: 'DEBUG', module: 'nikita/lib/tools/git'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Sanitize options\n  options.revision ?= 'HEAD'\n  # Start real work\n  repo_exists = false\n  repo_uptodate = false\n  @call (_, callback) ->\n    @fs.exists ssh: options.ssh, target: options.target, (err, exists) ->\n      return callback err if err\n      repo_exists = exists\n      return callback() unless exists # todo, isolate inside call when they receive conditions\n      # return callback Error \"Destination not a directory, got #{options.target}\" unless stat.isDirectory()\n      gitDir = \"#{options.target}/.git\"\n      @fs.exists ssh: options.ssh, target: gitDir, (err, exists) ->\n        return callback Error \"Not a git repository\" unless exists\n        callback()\n  @system.execute\n    cmd: \"git clone #{options.source} #{options.target}\"\n    cwd: path.dirname options.target\n    unless: -> repo_exists\n  @system.execute\n    cmd: \"\"\"\n    current=`git log --pretty=format:'%H' -n 1`\n    target=`git rev-list --max-count=1 #{options.revision}`\n    echo \"current revision: $current\"\n    echo \"expected revision: $target\"\n    if [ $current != $target ]; then exit 3; fi\n    \"\"\"\n    # stdout: process.stdout\n    cwd: options.target\n    trap: true\n    code_skipped: 3\n    if: -> repo_exists\n    shy: true\n  , (err, uptodate) ->\n    throw err if err\n    repo_uptodate = uptodate\n  @system.execute\n    cmd: \"git checkout #{options.revision}\"\n    cwd: options.target\n    unless: -> repo_uptodate",
            "title": "Source Code"
        },
        {
            "location": "/tools/git.coffee/#dependencies",
            "text": "path = require 'path'",
            "title": "Dependencies"
        },
        {
            "location": "/tools/iptables.coffee/",
            "text": "nikita.system.iptables(options, [callback])\n\n\nIptables  is  used to set up, maintain, and inspect the tables of IPv4 packet \nfilter rules in the Linux kernel.\n\n\nIptables rules are only inserted if the service is started on the target system.\n\n\nOptions\n\n\n\n\nlog\n (function)  \n\n  Function called with a log related messages.   \n\n\nrules\n (object | array) \n\n  One or more objects containing iptables rule definitions.   \n\n\nstdout\n (stream writer) \n\n  Stream writer to pipe the standart output stream of the executed commands.   \n\n\nstderr\n (stream writer) \n\n  Stream writer to pipe the standart error stream of the executed commands.   \n\n\nssh\n (object|ssh2) \n\n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.   \n\n\nstdout\n (stream.Writable) \n\n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.   \n\n\nstderr\n (stream.Writable) \n\n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.   \n\n\n\n\nCallback Parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Value is \"true\" if Iptables rules were created or modified.   \n\n\n\n\nUsage\n\n\nRule objects may contains the following keys:\n\n\n\n\nrulenum\n   \n\n\nprotocol\n   \n\n\njump\n   \n\n\nin-interface\n \n\n  Name of an interface via which a packet was received.   \n\n\nout-interface\n \n\n  Name of an interface via which a packet is going to be sent.   \n\n\nsource\n \n\n  Source specification. Address can be either a network name, a hostname, a\n  network IP address (with /mask), or a plain IP address.   \n\n\ntarget\n \n\n  Destination specification. See the description of the -s (source) flag for\n  a detailed description of the syntax.   \n\n\ncomment\n   \n\n\nstate\n   \n\n\ndport\n \n\n  Destination port or port range specification, see the \"tcp\" and \"udp\"\n  modules.   \n\n\nsport\n \n\n  Source port or port range specification, see the \"tcp\" and \"udp\" modules.   \n\n\n\n\nIptables comes with many modules. Each of them which must be specifically \nintegrated to the parser part of this code. For this reason, we could only\nintegrate a limited set of modules and more are added based on usages. Supported\nmodules are:\n\n\n\n\nstate\n \n\n  This module, when combined with connection tracking, allows access to the\n  connection tracking state for this packet.   \n\n\ncomment\n \n\n  Allows you to add comments (up to 256 characters) to any rule.   \n\n\nlimit\n \n\n  Matches at a limited rate using a token bucket filter.   \n\n\ntcp\n \n\n  Used if protocol is set to \"tcp\", the supported properties are \"dport\" and\n  \"sport\".   \n\n\nudp\n \n\n  Used if protocol is set to \"udp\", the supported properties are \"dport\" and\n  \"sport\".   \n\n\n\n\nExample\n\n\nvar after = {chain: 'INPUT', jump: 'ACCEPT', 'in-interface': 'lo'}\nrequire('nikita').iptables({\n  ssh: ssh,\n  rules: [\n    chain: 'INPUT', after: after, jump: 'ACCEPT', dport: 22, protocol: 'tcp'\n  ]\n}, function(err, updated){\n  console.log(err ? err.message : 'Iptables was updated: ' + !!written);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering iptables\", level: 'DEBUG', module: 'nikita/lib/iptables'\n  options.log message: \"List existing rules\", level: 'INFO', module: 'nikita/lib/iptables'\n  @system.execute\n    cmd: \"service iptables status &>/dev/null && iptables -S\"\n    code_skipped: 3\n  , (err, executed, stdout) =>\n    return callback err if err\n    return callback Error \"Service iptables not started\" unless executed\n    oldrules = iptables.parse stdout\n    newrules = iptables.normalize options.rules\n    cmd = iptables.cmd oldrules, newrules\n    return callback() unless cmd.length\n    options.log message: \"#{cmd.length} modified rules\", level: 'WARN', module: 'nikita/lib/iptables'\n    @system.execute\n      cmd: \"#{cmd.join '; '}; service iptables save;\"\n      trap: true\n    , (err, executed) ->\n      callback err, true\n\n\n\nDependencies\n\n\niptables = require '../misc/iptables'\n\n\n\nIPTables References\n\n\nList rules in readable format: \niptables -L --line-numbers -nv\n\nList rules in save format: \niptables -S -v",
            "title": "Iptables.coffee"
        },
        {
            "location": "/tools/iptables.coffee/#nikitasystemiptablesoptions-callback",
            "text": "Iptables  is  used to set up, maintain, and inspect the tables of IPv4 packet \nfilter rules in the Linux kernel.  Iptables rules are only inserted if the service is started on the target system.",
            "title": "nikita.system.iptables(options, [callback])"
        },
        {
            "location": "/tools/iptables.coffee/#options",
            "text": "log  (function)   \n  Function called with a log related messages.     rules  (object | array)  \n  One or more objects containing iptables rule definitions.     stdout  (stream writer)  \n  Stream writer to pipe the standart output stream of the executed commands.     stderr  (stream writer)  \n  Stream writer to pipe the standart error stream of the executed commands.     ssh  (object|ssh2)  \n  Run the action on a remote server using SSH, an ssh2 instance or an\n  configuration object used to initialize the SSH connection.     stdout  (stream.Writable)  \n  Writable EventEmitter in which the standard output of executed commands will\n  be piped.     stderr  (stream.Writable)  \n  Writable EventEmitter in which the standard error output of executed command\n  will be piped.",
            "title": "Options"
        },
        {
            "location": "/tools/iptables.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Value is \"true\" if Iptables rules were created or modified.",
            "title": "Callback Parameters"
        },
        {
            "location": "/tools/iptables.coffee/#usage",
            "text": "Rule objects may contains the following keys:   rulenum      protocol      jump      in-interface   \n  Name of an interface via which a packet was received.     out-interface   \n  Name of an interface via which a packet is going to be sent.     source   \n  Source specification. Address can be either a network name, a hostname, a\n  network IP address (with /mask), or a plain IP address.     target   \n  Destination specification. See the description of the -s (source) flag for\n  a detailed description of the syntax.     comment      state      dport   \n  Destination port or port range specification, see the \"tcp\" and \"udp\"\n  modules.     sport   \n  Source port or port range specification, see the \"tcp\" and \"udp\" modules.      Iptables comes with many modules. Each of them which must be specifically \nintegrated to the parser part of this code. For this reason, we could only\nintegrate a limited set of modules and more are added based on usages. Supported\nmodules are:   state   \n  This module, when combined with connection tracking, allows access to the\n  connection tracking state for this packet.     comment   \n  Allows you to add comments (up to 256 characters) to any rule.     limit   \n  Matches at a limited rate using a token bucket filter.     tcp   \n  Used if protocol is set to \"tcp\", the supported properties are \"dport\" and\n  \"sport\".     udp   \n  Used if protocol is set to \"udp\", the supported properties are \"dport\" and\n  \"sport\".",
            "title": "Usage"
        },
        {
            "location": "/tools/iptables.coffee/#example",
            "text": "var after = {chain: 'INPUT', jump: 'ACCEPT', 'in-interface': 'lo'}\nrequire('nikita').iptables({\n  ssh: ssh,\n  rules: [\n    chain: 'INPUT', after: after, jump: 'ACCEPT', dport: 22, protocol: 'tcp'\n  ]\n}, function(err, updated){\n  console.log(err ? err.message : 'Iptables was updated: ' + !!written);\n});",
            "title": "Example"
        },
        {
            "location": "/tools/iptables.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering iptables\", level: 'DEBUG', module: 'nikita/lib/iptables'\n  options.log message: \"List existing rules\", level: 'INFO', module: 'nikita/lib/iptables'\n  @system.execute\n    cmd: \"service iptables status &>/dev/null && iptables -S\"\n    code_skipped: 3\n  , (err, executed, stdout) =>\n    return callback err if err\n    return callback Error \"Service iptables not started\" unless executed\n    oldrules = iptables.parse stdout\n    newrules = iptables.normalize options.rules\n    cmd = iptables.cmd oldrules, newrules\n    return callback() unless cmd.length\n    options.log message: \"#{cmd.length} modified rules\", level: 'WARN', module: 'nikita/lib/iptables'\n    @system.execute\n      cmd: \"#{cmd.join '; '}; service iptables save;\"\n      trap: true\n    , (err, executed) ->\n      callback err, true",
            "title": "Source Code"
        },
        {
            "location": "/tools/iptables.coffee/#dependencies",
            "text": "iptables = require '../misc/iptables'",
            "title": "Dependencies"
        },
        {
            "location": "/tools/iptables.coffee/#iptables-references",
            "text": "List rules in readable format:  iptables -L --line-numbers -nv \nList rules in save format:  iptables -S -v",
            "title": "IPTables References"
        },
        {
            "location": "/tools/repo.coffee/",
            "text": "nikita.tools.repo(options, callback)\n\n\nSetup packet manager repository. Only support yum for now.\n\n\nOptions\n\n\n\n\nsource\n (string) \n\n  The source file(s) containing the repository(ies)   \n\n\nlocal\n (boolean) \n\n  Treat the source as local instead of remote, only apply with \"ssh\"\n  option.   \n\n\ncontent\n \n\n  Content to write inside the file. can not be used with source.   \n\n\nclean\n (string) \n\n  Globing expression used to match replaced files, path will resolve to\n  '/etc/yum.repos.d' if relative.   \n\n\ngpg_dir\n (string) \n\n  Directory storing GPG keys.   \n\n\ntarget\n (string) \n\n  Path of the repository definition file, relative to '/etc/yum.repos.d'.\n\n\nupdate\n (boolean) \n\n  Run yum update enabling only the ids present in repo file. Default to false.   \n\n\nverify\n \n\n  Download the PGP keys if it's enabled in the repo file, keys are by default\n  placed inside \"/etc/pki/rpm-gpg\" defined by the gpg_dir option and the \n  filename is derivated from the url.   \n\n\n\n\nExample\n\n\nrequire('nikita').tools.repo({\n  source: '/tmp/centos.repo',\n  clean: 'CentOs*'\n}, function(err, written){\n  console.info(err ? err.message : 'Repo updated: ' + !!written);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering tools.repo\", level: 'DEBUG', module: 'nikita/lib/tools/repo'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  throw Error \"Can not specify source and content\"if options.source and options.content\n  throw Error \"Missing source or content: \" unless options.source or options.content\n  # TODO wdavidw 180115, target should be mandatory and not default to the source filename\n  options.target ?= path.resolve \"/etc/yum.repos.d\", path.basename options.source if options.source?\n  throw Error \"Missing target\" unless options.target?\n  options.target = path.posix.resolve '/etc/yum.repos.d', options.target\n  options.verify ?= true\n  throw Error \"Invalid Option: option 'clean' must be a 'string'\" if options.clean and typeof options.clean isnt 'string'\n  options.clean = path.resolve '/etc/yum.repos.d', options.clean if options.clean\n  options.update ?= false\n  options.gpg_dir ?= '/etc/pki/rpm-gpg'\n  remote_files = []\n  repoids = []\n  # Delete\n  @call\n    if: options.clean\n  , (_, callback) ->\n    options.log message: \"Searching repositories inside \\\"/etc/yum.repos.d/\\\"\", level: 'DEBUG', module: 'nikita/lib/tools/repo'\n    glob ssh, options.clean, (err, files) ->\n      return callback err if err\n      remote_files = for file in files\n        continue if file is options.target\n        file\n      callback()\n  @call -> @system.remove remote_files\n  #download source\n  @file.download\n    if: options.source?\n    source: options.source\n    target: options.target\n    headers: options.headers\n    md5: options.md5\n    proxy: options.proxy\n    location: options.location\n    cache: false\n  # Write\n  @file.types.yum_repo\n    if: options.content?\n    content: options.content\n    mode: options.mode\n    uid: options.uid\n    gid: options.gid\n    target: options.target\n  # Parse the definition file\n  keys = []\n  options.log \"Read GPG keys from #{options.target}\", level: 'DEBUG', module: 'nikita/lib/tools/repo'\n  @fs.readFile\n    ssh: options.ssh\n    target: options.target\n    encoding: 'utf8'\n  , (err, content) =>\n    throw err if err\n    data  = misc.ini.parse_multi_brackets content\n    keys = for name, section of data\n      repoids.push name\n      continue unless section.gpgcheck is '1'\n      throw Error 'Missing gpgkey' unless section.gpgkey?\n      continue unless /^http(s)??:\\/\\//.test section.gpgkey\n      section.gpgkey\n  # Download GPG Keys\n  @call\n    if: options.verify\n  , ->\n    for key in keys\n      options.log \"Downloading GPG keys from #{key}\", level: 'DEBUG', module: 'nikita/lib/tools/repo'\n      @file.download\n        source: key\n        target: \"#{options.gpg_dir}/#{path.basename key}\"\n      @system.execute\n        if: -> @status -1\n        cmd: \"rpm --import #{options.gpg_dir}/#{path.basename key}\"\n  # Clean Metadata\n  @system.execute\n    if: -> path.relative('/etc/yum.repos.d', options.target) isnt '..' and @status()\n    # wdavidw: 180114, was \"yum clean metadata\", ensure an appropriate\n    # explanation is provided in case of revert.\n    # expire-cache is much faster,  It forces yum to go redownload the small\n    # repo files only, then if there's newer repo data, it will downloaded it.\n    cmd: 'yum clean expire-cache; yum repolist -y'\n  @call \n    if: -> options.update and @status()\n  , ->\n    @system.execute\n      cmd: \"\"\"\n      yum update -y --disablerepo=* --enablerepo='#{repoids.join(',')}'\n      yum repolist\n      \"\"\"\n      trap: true\n\n\n\nDependencies\n\n\nstring = require '../misc/string'\npath = require 'path'\nglob = require '../misc/glob'\nmisc = require '../misc'\nurl = require 'url'",
            "title": "Repo.coffee"
        },
        {
            "location": "/tools/repo.coffee/#nikitatoolsrepooptions-callback",
            "text": "Setup packet manager repository. Only support yum for now.",
            "title": "nikita.tools.repo(options, callback)"
        },
        {
            "location": "/tools/repo.coffee/#options",
            "text": "source  (string)  \n  The source file(s) containing the repository(ies)     local  (boolean)  \n  Treat the source as local instead of remote, only apply with \"ssh\"\n  option.     content   \n  Content to write inside the file. can not be used with source.     clean  (string)  \n  Globing expression used to match replaced files, path will resolve to\n  '/etc/yum.repos.d' if relative.     gpg_dir  (string)  \n  Directory storing GPG keys.     target  (string)  \n  Path of the repository definition file, relative to '/etc/yum.repos.d'.  update  (boolean)  \n  Run yum update enabling only the ids present in repo file. Default to false.     verify   \n  Download the PGP keys if it's enabled in the repo file, keys are by default\n  placed inside \"/etc/pki/rpm-gpg\" defined by the gpg_dir option and the \n  filename is derivated from the url.",
            "title": "Options"
        },
        {
            "location": "/tools/repo.coffee/#example",
            "text": "require('nikita').tools.repo({\n  source: '/tmp/centos.repo',\n  clean: 'CentOs*'\n}, function(err, written){\n  console.info(err ? err.message : 'Repo updated: ' + !!written);\n});",
            "title": "Example"
        },
        {
            "location": "/tools/repo.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering tools.repo\", level: 'DEBUG', module: 'nikita/lib/tools/repo'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Options\n  throw Error \"Can not specify source and content\"if options.source and options.content\n  throw Error \"Missing source or content: \" unless options.source or options.content\n  # TODO wdavidw 180115, target should be mandatory and not default to the source filename\n  options.target ?= path.resolve \"/etc/yum.repos.d\", path.basename options.source if options.source?\n  throw Error \"Missing target\" unless options.target?\n  options.target = path.posix.resolve '/etc/yum.repos.d', options.target\n  options.verify ?= true\n  throw Error \"Invalid Option: option 'clean' must be a 'string'\" if options.clean and typeof options.clean isnt 'string'\n  options.clean = path.resolve '/etc/yum.repos.d', options.clean if options.clean\n  options.update ?= false\n  options.gpg_dir ?= '/etc/pki/rpm-gpg'\n  remote_files = []\n  repoids = []\n  # Delete\n  @call\n    if: options.clean\n  , (_, callback) ->\n    options.log message: \"Searching repositories inside \\\"/etc/yum.repos.d/\\\"\", level: 'DEBUG', module: 'nikita/lib/tools/repo'\n    glob ssh, options.clean, (err, files) ->\n      return callback err if err\n      remote_files = for file in files\n        continue if file is options.target\n        file\n      callback()\n  @call -> @system.remove remote_files\n  #download source\n  @file.download\n    if: options.source?\n    source: options.source\n    target: options.target\n    headers: options.headers\n    md5: options.md5\n    proxy: options.proxy\n    location: options.location\n    cache: false\n  # Write\n  @file.types.yum_repo\n    if: options.content?\n    content: options.content\n    mode: options.mode\n    uid: options.uid\n    gid: options.gid\n    target: options.target\n  # Parse the definition file\n  keys = []\n  options.log \"Read GPG keys from #{options.target}\", level: 'DEBUG', module: 'nikita/lib/tools/repo'\n  @fs.readFile\n    ssh: options.ssh\n    target: options.target\n    encoding: 'utf8'\n  , (err, content) =>\n    throw err if err\n    data  = misc.ini.parse_multi_brackets content\n    keys = for name, section of data\n      repoids.push name\n      continue unless section.gpgcheck is '1'\n      throw Error 'Missing gpgkey' unless section.gpgkey?\n      continue unless /^http(s)??:\\/\\//.test section.gpgkey\n      section.gpgkey\n  # Download GPG Keys\n  @call\n    if: options.verify\n  , ->\n    for key in keys\n      options.log \"Downloading GPG keys from #{key}\", level: 'DEBUG', module: 'nikita/lib/tools/repo'\n      @file.download\n        source: key\n        target: \"#{options.gpg_dir}/#{path.basename key}\"\n      @system.execute\n        if: -> @status -1\n        cmd: \"rpm --import #{options.gpg_dir}/#{path.basename key}\"\n  # Clean Metadata\n  @system.execute\n    if: -> path.relative('/etc/yum.repos.d', options.target) isnt '..' and @status()\n    # wdavidw: 180114, was \"yum clean metadata\", ensure an appropriate\n    # explanation is provided in case of revert.\n    # expire-cache is much faster,  It forces yum to go redownload the small\n    # repo files only, then if there's newer repo data, it will downloaded it.\n    cmd: 'yum clean expire-cache; yum repolist -y'\n  @call \n    if: -> options.update and @status()\n  , ->\n    @system.execute\n      cmd: \"\"\"\n      yum update -y --disablerepo=* --enablerepo='#{repoids.join(',')}'\n      yum repolist\n      \"\"\"\n      trap: true",
            "title": "Source Code"
        },
        {
            "location": "/tools/repo.coffee/#dependencies",
            "text": "string = require '../misc/string'\npath = require 'path'\nglob = require '../misc/glob'\nmisc = require '../misc'\nurl = require 'url'",
            "title": "Dependencies"
        },
        {
            "location": "/tools/sysctl.coffee/",
            "text": "nikita.tools.sysctl(options, callback)\n\n\nConfigure kernel parameters at runtime.\n\n\nTarget file will be overwritten by default, use the \nmerge\n option to preserve existing variables.\n\n\nComments will be preserved if the \ncomments\n and \nmerge\n options are enabled.\n\n\nOptions\n\n\n\n\nbackup\n (string|boolean) \n\n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.\n\n\ncomment\n (boolean) \n\n  Preserve comments.\n\n\nload\n (boolean) \n\n  Load properties if target is modified, default is \"true\".\n\n\nmerge\n (boolean)  \n\n  Preserve existing variables in the target file.\n\n\nproperties\n (object) \n\n  Key/value object representing sysctl properties and values.\n\n\ntarget\n (string)\n  Destination to write properties and load in sysctl settings, default to \"/etc/sysctl.conf\" if none given.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n (Error) \n\n  Error object if any.   \n\n\nstatus\n  (boolean) \n\n  Value is \"true\" if the property was created or updated.\n\n\n\n\nUsefull Commands\n\n\n\n\nDisplay all sysctl variables \n\n\nsysctl -a\n\n\nDisplay value for a kernel variable \n\n\nsysctl -n kernel.hostname\n\n\nSet a kernel variable\n  \necho \"value\" > /proc/sys/location/variable\n\n  \necho 'variable = value' >> /etc/sysctl.conf && sysctl -p\n\n\n\n\nExample\n\n\nrequire('nikita').tools.sysctl({\n  source: '/etc/sysctl.conf',\n  properties: {\n    'vm.swappiness': 1\n  }\n}, function(err, status){\n  console.log(err ? err.message : 'Systcl reloaded: ' + !!status);\n});\n\n\n\n\nSource Code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering sysctl\", level: 'DEBUG', module: 'nikita/lib/tools/sysctl'\n  # Options\n  options.load ?= true\n  options.target ?= '/etc/sysctl.conf'\n  # Read current properties\n  current = {}\n  @call (_, callback) ->\n    status = false\n    options.log message: \"Read target: #{options.target}\", level: 'DEBUG', module: 'nikita/lib/tools/sysctl'\n    @fs.readFile\n      ssh: options.ssh\n      target: options.target\n      encoding: 'ascii'\n    , (err, data) =>\n      return callback() if err and err.code is 'ENOENT'\n      return callback err if err\n      for line in string.lines data\n        # Preserve comments\n        if /^#/.test line\n          current[line] = null if options.comment\n          continue\n        if /^\\s*$/.test line\n          current[line] = null\n          continue\n        [key, value] = line.split '='\n        # Trim\n        key = key.trim()\n        value = value.trim()\n        # Skip property\n        if key in options.properties and not options.properties[key]?\n          options.log \"Removing Property: #{key}, was #{value}\", level: 'INFO', module: 'nikita/lib/tools/sysctl'\n          status = true\n          continue\n        # Set property\n        current[key] = value\n      callback null, status\n  # Merge user properties\n  final = {}\n  @call (_, callback) ->\n    final[k] = v for k, v of current if options.merge\n    status = false\n    for key, value of options.properties\n      continue unless value?\n      value = \"#{value}\" if typeof value is 'number'\n      continue if current[key] is value\n      options.log \"Update Property: key \\\"#{key}\\\" from \\\"#{final[key]}\\\" to \\\"#{value}\\\"\", level: 'INFO', module: 'nikita/lib/tools/sysctl'\n      final[key] = value\n      status = true\n    callback null, status\n  @call\n    if: -> @status()\n  , ->\n    @file\n      target: options.target\n      backup: options.backup\n      content: (\n        for key, value of final\n          if value?\n            \"#{key} = #{value}\"\n          else\n            \"#{key}\"\n      ).join '\\n'\n  @system.execute\n    if: [\n      options.load\n      -> @status()\n    ]\n    cmd: \"sysctl -p #{options.target}\"\n\n\n\nDependencies\n\n\nstring = require '../misc/string'",
            "title": "Sysctl.coffee"
        },
        {
            "location": "/tools/sysctl.coffee/#nikitatoolssysctloptions-callback",
            "text": "Configure kernel parameters at runtime.  Target file will be overwritten by default, use the  merge  option to preserve existing variables.  Comments will be preserved if the  comments  and  merge  options are enabled.",
            "title": "nikita.tools.sysctl(options, callback)"
        },
        {
            "location": "/tools/sysctl.coffee/#options",
            "text": "backup  (string|boolean)  \n  Create a backup, append a provided string to the filename extension or a\n  timestamp if value is not a string, only apply if the target file exists and\n  is modified.  comment  (boolean)  \n  Preserve comments.  load  (boolean)  \n  Load properties if target is modified, default is \"true\".  merge  (boolean)   \n  Preserve existing variables in the target file.  properties  (object)  \n  Key/value object representing sysctl properties and values.  target  (string)\n  Destination to write properties and load in sysctl settings, default to \"/etc/sysctl.conf\" if none given.",
            "title": "Options"
        },
        {
            "location": "/tools/sysctl.coffee/#callback-parameters",
            "text": "err  (Error)  \n  Error object if any.     status   (boolean)  \n  Value is \"true\" if the property was created or updated.",
            "title": "Callback parameters"
        },
        {
            "location": "/tools/sysctl.coffee/#usefull-commands",
            "text": "Display all sysctl variables   sysctl -a  Display value for a kernel variable   sysctl -n kernel.hostname  Set a kernel variable\n   echo \"value\" > /proc/sys/location/variable \n   echo 'variable = value' >> /etc/sysctl.conf && sysctl -p",
            "title": "Usefull Commands"
        },
        {
            "location": "/tools/sysctl.coffee/#example",
            "text": "require('nikita').tools.sysctl({\n  source: '/etc/sysctl.conf',\n  properties: {\n    'vm.swappiness': 1\n  }\n}, function(err, status){\n  console.log(err ? err.message : 'Systcl reloaded: ' + !!status);\n});",
            "title": "Example"
        },
        {
            "location": "/tools/sysctl.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering sysctl\", level: 'DEBUG', module: 'nikita/lib/tools/sysctl'\n  # Options\n  options.load ?= true\n  options.target ?= '/etc/sysctl.conf'\n  # Read current properties\n  current = {}\n  @call (_, callback) ->\n    status = false\n    options.log message: \"Read target: #{options.target}\", level: 'DEBUG', module: 'nikita/lib/tools/sysctl'\n    @fs.readFile\n      ssh: options.ssh\n      target: options.target\n      encoding: 'ascii'\n    , (err, data) =>\n      return callback() if err and err.code is 'ENOENT'\n      return callback err if err\n      for line in string.lines data\n        # Preserve comments\n        if /^#/.test line\n          current[line] = null if options.comment\n          continue\n        if /^\\s*$/.test line\n          current[line] = null\n          continue\n        [key, value] = line.split '='\n        # Trim\n        key = key.trim()\n        value = value.trim()\n        # Skip property\n        if key in options.properties and not options.properties[key]?\n          options.log \"Removing Property: #{key}, was #{value}\", level: 'INFO', module: 'nikita/lib/tools/sysctl'\n          status = true\n          continue\n        # Set property\n        current[key] = value\n      callback null, status\n  # Merge user properties\n  final = {}\n  @call (_, callback) ->\n    final[k] = v for k, v of current if options.merge\n    status = false\n    for key, value of options.properties\n      continue unless value?\n      value = \"#{value}\" if typeof value is 'number'\n      continue if current[key] is value\n      options.log \"Update Property: key \\\"#{key}\\\" from \\\"#{final[key]}\\\" to \\\"#{value}\\\"\", level: 'INFO', module: 'nikita/lib/tools/sysctl'\n      final[key] = value\n      status = true\n    callback null, status\n  @call\n    if: -> @status()\n  , ->\n    @file\n      target: options.target\n      backup: options.backup\n      content: (\n        for key, value of final\n          if value?\n            \"#{key} = #{value}\"\n          else\n            \"#{key}\"\n      ).join '\\n'\n  @system.execute\n    if: [\n      options.load\n      -> @status()\n    ]\n    cmd: \"sysctl -p #{options.target}\"",
            "title": "Source Code"
        },
        {
            "location": "/tools/sysctl.coffee/#dependencies",
            "text": "string = require '../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/tools/rubygems/fetch.coffee/",
            "text": "nikita.tools.gem.fetch(options, [callback])\n\n\nFetch a Ruby gem.\n\n\nOptions\n\n\n\n\ncwd\n (string) \n\n  Directory storing gems.\n\n\ngem_bin\n (string) \n\n  Path to the gem command, default to 'gem'\n\n\nname\n (string) \n\n  Name of the gem, required.   \n\n\nversion\n (string) \n\n  Version of the gem.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Indicate if a gem was fetch.   \n\n\nfilename\n \n\n  Name of the gem file.   \n\n\nfilepath\n \n\n  Path of the gem file.   \n\n\n\n\nExemple\n\n\nrequire('nikita')\n.tools.rubygems.fetch({\n  name: 'json',\n  version: '2.1.0',\n  cwd: '/tmp/my_gems'\n}, function(err, status, filename, filepath){\n  console.log( err ? err.messgage : 'Gem fetched: ' + status);\n});\n\n\n\n\nImplementation\n\n\nWe do not support gem returning specification with binary strings because we\ncouldn't find any suitable parser on NPM.\n\n\nSource code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering rubygem.fetch\", level: 'DEBUG', module: 'nikita/lib/tools/rubygem/fetch'\n  # Global Options\n  options.ruby ?= {}\n  options[k] ?= v for k, v of options.ruby\n  options.gem_bin ?= 'gem'\n  @system.execute\n    unless: options.version\n    cmd: \"\"\"\n    #{options.gem_bin} specification #{options.name} version -r | grep '^version' | sed 's/.*: \\\\(.*\\\\)$/\\\\1/'\n    \"\"\"\n    cwd: options.cwd\n    shy: true\n    bash: options.bash\n  , (err, status, stdout) ->\n    throw err if err\n    options.version = stdout.trim() if status\n    options.target = \"#{options.name}-#{options.version}.gem\"\n  @call ->\n    @system.execute\n      cmd: \"\"\"\n      #{options.gem_bin} fetch #{options.name} -v #{options.version}\n      \"\"\"\n      cwd: options.cwd\n      bash: options.bash\n  @next (err, status) ->\n    callback err, status, options.target, path.resolve options.cwd, options.target\n\n\n\nDependencies\n\n\npath = require 'path'",
            "title": "Fetch.coffee"
        },
        {
            "location": "/tools/rubygems/fetch.coffee/#nikitatoolsgemfetchoptions-callback",
            "text": "Fetch a Ruby gem.",
            "title": "nikita.tools.gem.fetch(options, [callback])"
        },
        {
            "location": "/tools/rubygems/fetch.coffee/#options",
            "text": "cwd  (string)  \n  Directory storing gems.  gem_bin  (string)  \n  Path to the gem command, default to 'gem'  name  (string)  \n  Name of the gem, required.     version  (string)  \n  Version of the gem.",
            "title": "Options"
        },
        {
            "location": "/tools/rubygems/fetch.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Indicate if a gem was fetch.     filename   \n  Name of the gem file.     filepath   \n  Path of the gem file.",
            "title": "Callback parameters"
        },
        {
            "location": "/tools/rubygems/fetch.coffee/#exemple",
            "text": "require('nikita')\n.tools.rubygems.fetch({\n  name: 'json',\n  version: '2.1.0',\n  cwd: '/tmp/my_gems'\n}, function(err, status, filename, filepath){\n  console.log( err ? err.messgage : 'Gem fetched: ' + status);\n});",
            "title": "Exemple"
        },
        {
            "location": "/tools/rubygems/fetch.coffee/#implementation",
            "text": "We do not support gem returning specification with binary strings because we\ncouldn't find any suitable parser on NPM.",
            "title": "Implementation"
        },
        {
            "location": "/tools/rubygems/fetch.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering rubygem.fetch\", level: 'DEBUG', module: 'nikita/lib/tools/rubygem/fetch'\n  # Global Options\n  options.ruby ?= {}\n  options[k] ?= v for k, v of options.ruby\n  options.gem_bin ?= 'gem'\n  @system.execute\n    unless: options.version\n    cmd: \"\"\"\n    #{options.gem_bin} specification #{options.name} version -r | grep '^version' | sed 's/.*: \\\\(.*\\\\)$/\\\\1/'\n    \"\"\"\n    cwd: options.cwd\n    shy: true\n    bash: options.bash\n  , (err, status, stdout) ->\n    throw err if err\n    options.version = stdout.trim() if status\n    options.target = \"#{options.name}-#{options.version}.gem\"\n  @call ->\n    @system.execute\n      cmd: \"\"\"\n      #{options.gem_bin} fetch #{options.name} -v #{options.version}\n      \"\"\"\n      cwd: options.cwd\n      bash: options.bash\n  @next (err, status) ->\n    callback err, status, options.target, path.resolve options.cwd, options.target",
            "title": "Source code"
        },
        {
            "location": "/tools/rubygems/fetch.coffee/#dependencies",
            "text": "path = require 'path'",
            "title": "Dependencies"
        },
        {
            "location": "/tools/rubygems/install.coffee/",
            "text": "nikita.tools.gem.install(options, [callback])\n\n\nInstall a Ruby gem.\n\n\nRuby gems package a ruby library with a common layout. Inside gems are the \nfollowing components:\n\n\n\n\nCode (including tests and supporting utilities)\n\n\nDocumentation\n\n\ngemspec\n\n\n\n\nOptions\n\n\n\n\nbindir\n (string) \n\n  Directory where binary files are located.\n\n\nbuild_flags\n (string) \n\n  Pass flags to the compiler.\n\n\ngem_bin\n (string) \n\n  Path to the gem command, default to 'gem'\n\n\nname\n (string) \n\n  Name of the gem, required.   \n\n\ntarget\n (string) \n\n  Install directory.\n\n\nversion\n (string) \n\n  Version of the gem.\n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.\n\n\nstatus\n \n\n  Indicate if a gem was installed.\n\n\n\n\nExemples\n\n\nInstall a gem from its name and version:\n\n\nrequire('nikita')\n.tools.rubygems.install({\n  name: 'json',\n  version: '2.1.0',\n}, function(err, status){\n  console.log( err ? err.messgage : 'Gem installed: ' + status);\n});\n\n\n\n\nInstall a gem from a local file:\n\n\nrequire('nikita')\n.tools.rubygems.install({\n  source: '/path/to/json-2.1.0.gem',\n}, function(err, status){\n  console.log( err ? err.messgage : 'Gem installed: ' + status);\n});\n\n\n\n\nInstall gems from a glob expressoin:\n\n\nrequire('nikita')\n.tools.rubygems.install({\n  source: '/path/to/*.gem',\n}, function(err, status){\n  console.log( err ? err.messgage : 'Gem installed: ' + status);\n});\n\n\n\n\nSource code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering rubygem.install\", level: 'DEBUG', module: 'nikita/lib/tools/rubygem/install'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Global Options\n  options.ruby ?= {}\n  options[k] ?= v for k, v of options.ruby\n  options.gem_bin ?= 'gem'\n  options.gems ?= {}\n  options.gems[options.name] ?= options.version if options.name\n  options.sources ?= []\n  current_gems = {}\n  @system.execute\n    cmd: \"\"\"\n    #{options.gem_bin} list --versions\n    \"\"\"\n    shy: true\n    bash: options.bash\n  , (err, _, stdout) ->\n    for line in string.lines stdout\n      continue if line.trim() is ''\n      [name, version] = line.match(/(.*?)(?:$| \\((?:default:\\s+)?([\\d\\., ]+)\\))/)[1..3]\n      current_gems[name] = version.split(', ')\n  @call if: options.source, (_, callback) ->\n    glob ssh, options.source, (err, sources) ->\n      return callback err if err\n      options.source = sources.filter (source) ->\n        filename = path.basename source\n        current_filenames = for n, v of current_gems then \"#{n}-#{v}.gem\"\n        true unless filename in current_filenames\n      callback()\n  @call ->\n    for name, version of options.gems\n      # Install if Gem isnt yet there\n      continue unless current_gems[name]\n      # Install if a version is demanded and no installed versio satisfy it\n      is_version_matching = current_gems[name].some (current_version) -> semver.satisfies version, current_version\n      continue if version and not is_version_matching\n      delete options.gems[name]\n  @call ->\n    if: options.sources.length\n  , ->\n    @system.execute\n      if: options.sources.length\n      cmd: (\n        for source in options.sources\n          [\n            \"#{options.gem_bin}\"\n            \"install\"\n            \"--bindir '#{options.bindir}'\" if options.bindir\n            \"--install-dir '#{options.target}'\" if options.target\n            \"--local '#{options.source}'\" if options.source\n            \"--build-flags options.build_flags\" if options.build_flags\n          ].join ' '\n        ).join '\\n'\n      code: [0, 2]\n      bash: options.bash\n  @call ->\n    @system.execute\n      if: Object.keys(options.gems).length\n      cmd: (\n        for name, version of options.gems\n          [\n            \"#{options.gem_bin}\"\n            \"install\"\n            \"#{options.name}\"\n            \"--bindir '#{options.bindir}'\" if options.bindir\n            \"--install-dir '#{options.target}'\" if options.target\n            \"--version '#{options.version}'\" if options.version\n            \"--build-flags options.build_flags\" if options.build_flags\n          ].join ' '\n        ).join '\\n'\n      code: [0, 2]\n      bash: options.bash\n\n\n\nDependencies\n\n\npath = require 'path'\nsemver = require 'semver'\nglob = require '../../misc/glob'\nstring = require '../../misc/string'",
            "title": "Install.coffee"
        },
        {
            "location": "/tools/rubygems/install.coffee/#nikitatoolsgeminstalloptions-callback",
            "text": "Install a Ruby gem.  Ruby gems package a ruby library with a common layout. Inside gems are the \nfollowing components:   Code (including tests and supporting utilities)  Documentation  gemspec",
            "title": "nikita.tools.gem.install(options, [callback])"
        },
        {
            "location": "/tools/rubygems/install.coffee/#options",
            "text": "bindir  (string)  \n  Directory where binary files are located.  build_flags  (string)  \n  Pass flags to the compiler.  gem_bin  (string)  \n  Path to the gem command, default to 'gem'  name  (string)  \n  Name of the gem, required.     target  (string)  \n  Install directory.  version  (string)  \n  Version of the gem.",
            "title": "Options"
        },
        {
            "location": "/tools/rubygems/install.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.  status   \n  Indicate if a gem was installed.",
            "title": "Callback parameters"
        },
        {
            "location": "/tools/rubygems/install.coffee/#exemples",
            "text": "Install a gem from its name and version:  require('nikita')\n.tools.rubygems.install({\n  name: 'json',\n  version: '2.1.0',\n}, function(err, status){\n  console.log( err ? err.messgage : 'Gem installed: ' + status);\n});  Install a gem from a local file:  require('nikita')\n.tools.rubygems.install({\n  source: '/path/to/json-2.1.0.gem',\n}, function(err, status){\n  console.log( err ? err.messgage : 'Gem installed: ' + status);\n});  Install gems from a glob expressoin:  require('nikita')\n.tools.rubygems.install({\n  source: '/path/to/*.gem',\n}, function(err, status){\n  console.log( err ? err.messgage : 'Gem installed: ' + status);\n});",
            "title": "Exemples"
        },
        {
            "location": "/tools/rubygems/install.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering rubygem.install\", level: 'DEBUG', module: 'nikita/lib/tools/rubygem/install'\n  # SSH connection\n  ssh = @ssh options.ssh\n  # Global Options\n  options.ruby ?= {}\n  options[k] ?= v for k, v of options.ruby\n  options.gem_bin ?= 'gem'\n  options.gems ?= {}\n  options.gems[options.name] ?= options.version if options.name\n  options.sources ?= []\n  current_gems = {}\n  @system.execute\n    cmd: \"\"\"\n    #{options.gem_bin} list --versions\n    \"\"\"\n    shy: true\n    bash: options.bash\n  , (err, _, stdout) ->\n    for line in string.lines stdout\n      continue if line.trim() is ''\n      [name, version] = line.match(/(.*?)(?:$| \\((?:default:\\s+)?([\\d\\., ]+)\\))/)[1..3]\n      current_gems[name] = version.split(', ')\n  @call if: options.source, (_, callback) ->\n    glob ssh, options.source, (err, sources) ->\n      return callback err if err\n      options.source = sources.filter (source) ->\n        filename = path.basename source\n        current_filenames = for n, v of current_gems then \"#{n}-#{v}.gem\"\n        true unless filename in current_filenames\n      callback()\n  @call ->\n    for name, version of options.gems\n      # Install if Gem isnt yet there\n      continue unless current_gems[name]\n      # Install if a version is demanded and no installed versio satisfy it\n      is_version_matching = current_gems[name].some (current_version) -> semver.satisfies version, current_version\n      continue if version and not is_version_matching\n      delete options.gems[name]\n  @call ->\n    if: options.sources.length\n  , ->\n    @system.execute\n      if: options.sources.length\n      cmd: (\n        for source in options.sources\n          [\n            \"#{options.gem_bin}\"\n            \"install\"\n            \"--bindir '#{options.bindir}'\" if options.bindir\n            \"--install-dir '#{options.target}'\" if options.target\n            \"--local '#{options.source}'\" if options.source\n            \"--build-flags options.build_flags\" if options.build_flags\n          ].join ' '\n        ).join '\\n'\n      code: [0, 2]\n      bash: options.bash\n  @call ->\n    @system.execute\n      if: Object.keys(options.gems).length\n      cmd: (\n        for name, version of options.gems\n          [\n            \"#{options.gem_bin}\"\n            \"install\"\n            \"#{options.name}\"\n            \"--bindir '#{options.bindir}'\" if options.bindir\n            \"--install-dir '#{options.target}'\" if options.target\n            \"--version '#{options.version}'\" if options.version\n            \"--build-flags options.build_flags\" if options.build_flags\n          ].join ' '\n        ).join '\\n'\n      code: [0, 2]\n      bash: options.bash",
            "title": "Source code"
        },
        {
            "location": "/tools/rubygems/install.coffee/#dependencies",
            "text": "path = require 'path'\nsemver = require 'semver'\nglob = require '../../misc/glob'\nstring = require '../../misc/string'",
            "title": "Dependencies"
        },
        {
            "location": "/tools/rubygems/remove.coffee/",
            "text": "nikita.tools.gem.remove(options, [callback])\n\n\nRemove a Ruby gem.\n\n\nRuby Gems package a ruby library with a common layout. Inside gems are the \nfollowing components:\n\n\n\n\nCode (including tests and supporting utilities)\n\n\nDocumentation\n\n\ngemspec\n\n\n\n\nOptions\n\n\n\n\ngem_bin\n (string) \n\n  Path to the gem command, default to 'gem'\n\n\nname\n (string) \n\n  Name of the gem, required.   \n\n\nversion\n (string) \n\n  Version of the gem, default to all versions.   \n\n\n\n\nCallback parameters\n\n\n\n\nerr\n \n\n  Error object if any.   \n\n\nstatus\n \n\n  Indicate if a gem was removed.   \n\n\n\n\nRuby behavior\n\n\nRuby place global gems inside \"/usr/share/gems/gems\" and user gems are by \ndefault installed inside \"/usr/local/share/gems\".\n\n\nAny attempt to remove a gem installed globally and not in the user repository \nwill result with the error \"{gem} is not installed in GEM_HOME, try: gem \nuninstall -i /usr/share/gems json\"\n\n\nSource code\n\n\nmodule.exports = (options) ->\n  options.log message: \"Entering rubygem.remove\", level: 'DEBUG', module: 'nikita/lib/tools/rubygem/remove'\n  # Global Options\n  options.ruby ?= {}\n  options[k] ?= v for k, v of options.ruby\n  options.gem_bin ?= 'gem'\n  version = if options.version then \"-v #{options.version}\" else '-a'\n  gems = null\n  @system.execute\n    cmd: \"\"\"\n    #{options.gem_bin} list -i #{options.name} || exit 3\n    #{options.gem_bin} uninstall #{options.name} #{version}\n    \"\"\"\n    code_skipped: 3\n    bash: options.bash",
            "title": "Remove.coffee"
        },
        {
            "location": "/tools/rubygems/remove.coffee/#nikitatoolsgemremoveoptions-callback",
            "text": "Remove a Ruby gem.  Ruby Gems package a ruby library with a common layout. Inside gems are the \nfollowing components:   Code (including tests and supporting utilities)  Documentation  gemspec",
            "title": "nikita.tools.gem.remove(options, [callback])"
        },
        {
            "location": "/tools/rubygems/remove.coffee/#options",
            "text": "gem_bin  (string)  \n  Path to the gem command, default to 'gem'  name  (string)  \n  Name of the gem, required.     version  (string)  \n  Version of the gem, default to all versions.",
            "title": "Options"
        },
        {
            "location": "/tools/rubygems/remove.coffee/#callback-parameters",
            "text": "err   \n  Error object if any.     status   \n  Indicate if a gem was removed.",
            "title": "Callback parameters"
        },
        {
            "location": "/tools/rubygems/remove.coffee/#ruby-behavior",
            "text": "Ruby place global gems inside \"/usr/share/gems/gems\" and user gems are by \ndefault installed inside \"/usr/local/share/gems\".  Any attempt to remove a gem installed globally and not in the user repository \nwill result with the error \"{gem} is not installed in GEM_HOME, try: gem \nuninstall -i /usr/share/gems json\"",
            "title": "Ruby behavior"
        },
        {
            "location": "/tools/rubygems/remove.coffee/#source-code",
            "text": "module.exports = (options) ->\n  options.log message: \"Entering rubygem.remove\", level: 'DEBUG', module: 'nikita/lib/tools/rubygem/remove'\n  # Global Options\n  options.ruby ?= {}\n  options[k] ?= v for k, v of options.ruby\n  options.gem_bin ?= 'gem'\n  version = if options.version then \"-v #{options.version}\" else '-a'\n  gems = null\n  @system.execute\n    cmd: \"\"\"\n    #{options.gem_bin} list -i #{options.name} || exit 3\n    #{options.gem_bin} uninstall #{options.name} #{version}\n    \"\"\"\n    code_skipped: 3\n    bash: options.bash",
            "title": "Source code"
        },
        {
            "location": "/wait/execute.coffee/",
            "text": "nikita.wait.execute(options, [callback])\n\n\nRun a command periodically and continue once the command succeed. Status will be\nset to \"false\" if the user command succeed right away, considering that no\nchange had occured. Otherwise it will be set to \"true\".   \n\n\nOptions\n\n\n\n\nquorum\n (number|boolean)  \n\n  Number of minimal successful connection, 50%+1 if \"true\".   \n\n\ncmd\n (string|array) \n\n  The commands to be executed.    \n\n\ninterval\n \n\n  Time interval between which we should wait before re-executing the command,\n  default to 2s.   \n\n\ncode\n \n\n  Expected exit code to recieve to exit and call the user callback, default to \"0\".   \n\n\ncode_skipped\n \n\n  Expected code to be returned when the command failed and should be scheduled\n  for later execution, default to \"1\".   \n\n\nstdin_log\n (boolean) \n\n  Pass stdin output to the logs of type \"stdin_stream\", default is \"true\".\n\n\nstdout_log\n (boolean) \n\n  Pass stdout output to the logs of type \"stdout_stream\", default is \"true\".\n\n\nstderr_log\n (boolean) \n\n  Pass stderr output to the logs of type \"stderr_stream\", default is \"true\".\n\n\n\n\nExample\n\n\nrequire('nikita')\n.wait.execute({\n  cmd: \"test -f /tmp/sth\"\n}, function(err, status){\n  // Command succeed, the file \"/tmp/sth\" now exists\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering wait for execution\", level: 'DEBUG', module: 'nikita/lib/wait/execute'\n  # Validate parameters\n  options.cmd ?= options.argument if typeof options.argument?\n  return callback Error \"Missing cmd: #{options.cmd}\" unless options.cmd?\n  options.cmd = [options.cmd] unless Array.isArray options.cmd\n  options.quorum = options.quorum\n  if options.quorum and options.quorum is true\n    options.quorum = Math.ceil options.cmd.length / 2\n  else unless options.quorum?\n    options.quorum = options.cmd.length\n  options.interval ?= 2000\n  options.code_skipped ?= 1\n  options.log message: \"Entering wait for execution\", level: 'DEBUG', module: 'nikita/lib/wait/execute'\n  quorum_current = 0\n  modified = false\n  each options.cmd\n  .call (cmd, next) =>\n    count = 0\n    return next() if quorum_current >= options.quorum\n    run = =>\n      count++\n      options.log message: \"Attempt ##{count}\", level: 'INFO', module: 'nikita/lib/wait/execute'\n      @system.execute\n        cmd: cmd\n        code: options.code or 0\n        code_skipped: options.code_skipped\n        stdin_log: options.stdin_log\n        stdout_log: options.stdout_log\n        stderr_log: options.stderr_log\n      , (err, ready) =>\n        if not err and not ready\n          setTimeout run, options.interval\n          return\n        return next err if err\n        options.log message: \"Finish wait for execution\", level: 'INFO', module: 'nikita/lib/wait/execute'\n        quorum_current++\n        modified = true if count > 1\n        next()\n    run()\n  .next (err) ->\n    callback err, modified\n\n\n\nDependencies\n\n\neach = require 'each'",
            "title": "Execute.coffee"
        },
        {
            "location": "/wait/execute.coffee/#nikitawaitexecuteoptions-callback",
            "text": "Run a command periodically and continue once the command succeed. Status will be\nset to \"false\" if the user command succeed right away, considering that no\nchange had occured. Otherwise it will be set to \"true\".",
            "title": "nikita.wait.execute(options, [callback])"
        },
        {
            "location": "/wait/execute.coffee/#options",
            "text": "quorum  (number|boolean)   \n  Number of minimal successful connection, 50%+1 if \"true\".     cmd  (string|array)  \n  The commands to be executed.      interval   \n  Time interval between which we should wait before re-executing the command,\n  default to 2s.     code   \n  Expected exit code to recieve to exit and call the user callback, default to \"0\".     code_skipped   \n  Expected code to be returned when the command failed and should be scheduled\n  for later execution, default to \"1\".     stdin_log  (boolean)  \n  Pass stdin output to the logs of type \"stdin_stream\", default is \"true\".  stdout_log  (boolean)  \n  Pass stdout output to the logs of type \"stdout_stream\", default is \"true\".  stderr_log  (boolean)  \n  Pass stderr output to the logs of type \"stderr_stream\", default is \"true\".",
            "title": "Options"
        },
        {
            "location": "/wait/execute.coffee/#example",
            "text": "require('nikita')\n.wait.execute({\n  cmd: \"test -f /tmp/sth\"\n}, function(err, status){\n  // Command succeed, the file \"/tmp/sth\" now exists\n})",
            "title": "Example"
        },
        {
            "location": "/wait/execute.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering wait for execution\", level: 'DEBUG', module: 'nikita/lib/wait/execute'\n  # Validate parameters\n  options.cmd ?= options.argument if typeof options.argument?\n  return callback Error \"Missing cmd: #{options.cmd}\" unless options.cmd?\n  options.cmd = [options.cmd] unless Array.isArray options.cmd\n  options.quorum = options.quorum\n  if options.quorum and options.quorum is true\n    options.quorum = Math.ceil options.cmd.length / 2\n  else unless options.quorum?\n    options.quorum = options.cmd.length\n  options.interval ?= 2000\n  options.code_skipped ?= 1\n  options.log message: \"Entering wait for execution\", level: 'DEBUG', module: 'nikita/lib/wait/execute'\n  quorum_current = 0\n  modified = false\n  each options.cmd\n  .call (cmd, next) =>\n    count = 0\n    return next() if quorum_current >= options.quorum\n    run = =>\n      count++\n      options.log message: \"Attempt ##{count}\", level: 'INFO', module: 'nikita/lib/wait/execute'\n      @system.execute\n        cmd: cmd\n        code: options.code or 0\n        code_skipped: options.code_skipped\n        stdin_log: options.stdin_log\n        stdout_log: options.stdout_log\n        stderr_log: options.stderr_log\n      , (err, ready) =>\n        if not err and not ready\n          setTimeout run, options.interval\n          return\n        return next err if err\n        options.log message: \"Finish wait for execution\", level: 'INFO', module: 'nikita/lib/wait/execute'\n        quorum_current++\n        modified = true if count > 1\n        next()\n    run()\n  .next (err) ->\n    callback err, modified",
            "title": "Source Code"
        },
        {
            "location": "/wait/execute.coffee/#dependencies",
            "text": "each = require 'each'",
            "title": "Dependencies"
        },
        {
            "location": "/wait/exist.coffee/",
            "text": "nikita.wait.exist(options, [callback])\n\n\nWait for a file or directory to exists. Status will be\nset to \"false\" if the file already existed, considering that no\nchange had occured. Otherwise it will be set to \"true\".   \n\n\nOptions\n\n\n\n\ntarget\n (string|array) \n\n  Path to a file or directory.    \n\n\ninterval\n \n\n  Time interval between which we should wait before re-executing the check,\n  default to 2s.     \n\n\n\n\nExample:\n\n\nrequire('nikita')\n.wait.exist({\n  target: \"/path/to/file_or_directory\"\n}, function(err, status){\n  // Command succeed, the file now exists\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.log message: \"Entering wait.exists\", level: 'DEBUG', module: 'nikita/lib/wait/exist'\n  # SSH connection\n  ssh = @ssh options.ssh\n  status = false\n  # Validate parameters\n  return callback Error \"Missing target: #{options.target}\" unless options.target?\n  options.target = [options.target] unless Array.isArray options.target\n  options.interval ?= 2000\n  options.log message: \"Entering wait for file\", level: 'DEBUG', module: 'nikita/wait/exist'\n  status = false\n  each options.target\n  .call (target, next) =>\n    count = 0\n    run = =>\n      count++\n      options.log message: \"Attempt ##{count}\", level: 'INFO', module: 'nikita/wait/exist'\n      @fs.stat ssh: options.ssh, target: options.target, (err, stat) ->\n        return next err if err and err.code isnt 'ENOENT'\n        return setTimeout run, options.interval if err\n        options.log message: \"Finish wait for file\", level: 'INFO', module: 'nikita/wait/exist'\n        status = true if count > 1\n        next()\n    run()\n  .next (err) ->\n    callback err, status\n\neach = require 'each'",
            "title": "Exist.coffee"
        },
        {
            "location": "/wait/exist.coffee/#nikitawaitexistoptions-callback",
            "text": "Wait for a file or directory to exists. Status will be\nset to \"false\" if the file already existed, considering that no\nchange had occured. Otherwise it will be set to \"true\".",
            "title": "nikita.wait.exist(options, [callback])"
        },
        {
            "location": "/wait/exist.coffee/#options",
            "text": "target  (string|array)  \n  Path to a file or directory.      interval   \n  Time interval between which we should wait before re-executing the check,\n  default to 2s.        Example:  require('nikita')\n.wait.exist({\n  target: \"/path/to/file_or_directory\"\n}, function(err, status){\n  // Command succeed, the file now exists\n})",
            "title": "Options"
        },
        {
            "location": "/wait/exist.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.log message: \"Entering wait.exists\", level: 'DEBUG', module: 'nikita/lib/wait/exist'\n  # SSH connection\n  ssh = @ssh options.ssh\n  status = false\n  # Validate parameters\n  return callback Error \"Missing target: #{options.target}\" unless options.target?\n  options.target = [options.target] unless Array.isArray options.target\n  options.interval ?= 2000\n  options.log message: \"Entering wait for file\", level: 'DEBUG', module: 'nikita/wait/exist'\n  status = false\n  each options.target\n  .call (target, next) =>\n    count = 0\n    run = =>\n      count++\n      options.log message: \"Attempt ##{count}\", level: 'INFO', module: 'nikita/wait/exist'\n      @fs.stat ssh: options.ssh, target: options.target, (err, stat) ->\n        return next err if err and err.code isnt 'ENOENT'\n        return setTimeout run, options.interval if err\n        options.log message: \"Finish wait for file\", level: 'INFO', module: 'nikita/wait/exist'\n        status = true if count > 1\n        next()\n    run()\n  .next (err) ->\n    callback err, status\n\neach = require 'each'",
            "title": "Source Code"
        },
        {
            "location": "/wait/index.coffee/",
            "text": "nikita.wait(options, [callback])\n\n\nSimple nikita action that calls setTimeout. Thus, time is in millisecond.\n\n\nOptions\n\n\n\n\ntime\n (number)  \n\n  Time in millisecond to wait to.   \n\n\n\n\nExample\n\n\nbefore = Date.now();\nrequire('nikita')\n.wait({\n  time: 5000\n}, function(err, status){\n  throw Error 'TOO LATE!' if (Date.now() - before) > 5200\n  throw Error 'TOO SOON!' if (Date.now() - before) < 5000\n})\n\n\n\n\nSource Code\n\n\nmodule.exports = (options, callback) ->\n  options.time ?= options.argument\n  return callback Error \"Missing time: #{JSON.stringify options.time}\" unless options.time?\n  options.time = parseInt options.time if typeof options.time is 'string'\n  return callback Error \"Invalid time format: #{JSON.stringify options.time}\" unless typeof options.time is 'number'\n  setTimeout callback, options.time",
            "title": "Index.coffee"
        },
        {
            "location": "/wait/index.coffee/#nikitawaitoptions-callback",
            "text": "Simple nikita action that calls setTimeout. Thus, time is in millisecond.",
            "title": "nikita.wait(options, [callback])"
        },
        {
            "location": "/wait/index.coffee/#options",
            "text": "time  (number)   \n  Time in millisecond to wait to.",
            "title": "Options"
        },
        {
            "location": "/wait/index.coffee/#example",
            "text": "before = Date.now();\nrequire('nikita')\n.wait({\n  time: 5000\n}, function(err, status){\n  throw Error 'TOO LATE!' if (Date.now() - before) > 5200\n  throw Error 'TOO SOON!' if (Date.now() - before) < 5000\n})",
            "title": "Example"
        },
        {
            "location": "/wait/index.coffee/#source-code",
            "text": "module.exports = (options, callback) ->\n  options.time ?= options.argument\n  return callback Error \"Missing time: #{JSON.stringify options.time}\" unless options.time?\n  options.time = parseInt options.time if typeof options.time is 'string'\n  return callback Error \"Invalid time format: #{JSON.stringify options.time}\" unless typeof options.time is 'number'\n  setTimeout callback, options.time",
            "title": "Source Code"
        }
    ]
}